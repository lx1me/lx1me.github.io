<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Tomcat</title>
    <link href="/2025/06/09/Tomcat/"/>
    <url>/2025/06/09/Tomcat/</url>
    
    <content type="html"><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs ada">微服务架构<br>  微服务架构是一种构建应用程序的方法，其中应用程序被拆分为一组小型、自治的服务。每个服务都有自己的数据存储，可以使用不同的技术栈，并通过轻量级的通信机制（例如HTTP/REST或消息队列）相互通信。微服务架构强调独立开发、部署和运行每个服务，以及容错和弹性。这种架构使得团队可以使用不同的技术栈和语言，更容易实现持续集成和持续交付<br>   三种模式的细节区别:<br>     单体式应用 - 适合小型应用或快速开发的项目<br>     SOA式应用 - 适用于大型企业应用，强调服务的重用和集成<br>     微服务式应用 - 更适合需要快速迭代和高度可扩展性的互联网应用<br>   微服务的特点:<br>     - 应用被分解为小型、自治的服务；<br>     - 每个服务都有自己的数据库，可以使用不同的技术栈；<br>     - 服务之间通过API进行通信，通常是通过HTTP/REST或消息队列；<br>     - 强调独立部署、自动化和容错；    <br><br>java动态网页技术:<br>  servlet:<br>     Servlet是Java编程语言的一种服务器端程序，主要用于扩展Web服务器的功能。Servlet运行在Web服     务器中，接收并响应来自客户端（通常是Web浏览器）的请求。如果要用 Serviet 构建 Web 应用，则需要将 Html 标签嵌套在 Java 的逻辑代码中，而 Html 代码又要频繁迭代，相应的，需要重新编译，这种开发模式非常不方便。         <br>  JSP:<br>    JSP（Java Server Pages）是一种用于创建动态Web页面的Java技术。与Servlet一样，JSP也是在<br>服务器端执行的，但其主要目标是简化Web页面的开发，允许开发者在HTML页面中嵌入简单的Java程序逻辑代码;       <br>  虽然Servlet和JSP在某些方面有区别，但它们通常会一起使用。Servlet用于处理业务逻辑，而JSP用于呈现用户界面。在实际的Web应用中，Servlet和JSP经常一起协同工作，以达到更好的代码组织和可维护性<br>开发框架:<br>  MVC:<br>    MVC（Model-View-Controller）是一种设计模式，用于组织和管理软件应用程序的结构。它将应用程序分为三个主要组件，分别是模型（Model）、视图（View）和控制器（Controller）<br><br>tomcat入门:<br>  Tomcat（全称为Apache Tomcat）是一个开源的、轻量级的应用服务器,使用Tomcat 时，将 Java Web 应用程序（包括Servlet、JSP等文件）部署到 Tomcat 服务器中，然后通过 HTTP 协议访问这些应用程序，Tomcat提供了一个简单而强大的方式来托管和运行Java Web应用程序。  <br>  特点:<br>    - Servlet容器：<br>      Tomcat是一个Servlet容器，负责处理和执行Java Servlet。Servlet是一种用Java编写的服务器端程序，用于处理Web请求和生成动态Web内容；<br>    - JSP支持：<br>      Tomcat还支持JavaServer Pages（JSP），一种将Java代码嵌入HTML中的技术，用于创建动态Web页面；<br>    - 轻量级：<br>      Tomcat被设计为轻量级的应用服务器，易于安装和配置。它专注于提供基本的Servlet和JSP支持，而不像一些其他应用服务器那样包含大量的附加功能；<br>    - 开源：<br>      Tomcat是开源软件，可以免费使用，并且其源代码是开 放的，允许用户根据需要进行修改和定制；<br>    - 连接器支持：<br>      Tomcat支持多种连接器，可以与不同的Web服务器进行集成。最常见的是与Apache HTTP服务器一起使用的AJP（Apache JServ Protocol）连接器；      <br>    - 管理工具：<br>      Tomcat提供了Web-based管理工具，允许管理员轻松地配置和监控Tomcat服务器。这包括一个Web界面，可以用来管理Web应用程序、虚拟主机、连接器等；<br>    - 安全性：<br>      Tomcat内置了一些安全特性，包括对SSL/TLS的支持，以及一些安全的配置选项，帮助保护Web应用程序免受攻击；<br>    - 跨平台性：<br>      Tomcat是跨平台的，可以在不同的操作系统上运行，包括Windows、Linux、和macOS等                      <br><br>Tomcat 的核心分为三个部份<br>    - Web 容器：用作处理静态页面<br>    - JSP 容器：把 jsp 翻译成一般的 servlet<br>    - catalina：是一个 servlet 容器，用于处理 servlet<br><br>Tomcat组件：<br>  Server组件<br>   是Tomcat的顶级管理组件，代表着整个Tomcat的运行实例。它定义了全局服务器配置。<br>  Service组件：<br>   是Server组件的子元素，是对外提供服务的实体。<br>  Connector组件: 用于接收客户端请求<br>  Engine组件: 用于响应用户请求然后转交给后面的真实服务来处理请求。         <br>     <br>web部署：(三种方式)<br>  <span class="hljs-number">1</span> 以文件或war 包直接部署<br>    将应用文件夹或 war 包文件直接复制到 tomcat 的 webapps 目录下，这样 tomcat 启动的时候会将 webapps 目录下的文件夹或 war 文件的内容当成应用部署。这种方式最简单且无须书写任何配置文件  <br>  <span class="hljs-number">2</span> 编辑 /data/server/tomcat/conf/server.xml 配置文件，添加 Context 标签<br>    在 tomcat 的 server.xml 配置文件中的 Host 节点下增加 Context 子节点，配置域名，文件路径等       <br>  <span class="hljs-number">3</span> 在 /data/server/tomcat/conf/[Engine]/[Host]/ 目录下创建独立配置<br>    在该目录下新建 xml 文件，文件名为应用名，然后在配置文件中添加 Context子节点，配置域名，文件路径等    <br><br>JAVA程序编译流程:<br>  <span class="hljs-number">1</span>. 获取 Java 程序源码<br>  <span class="hljs-number">2</span>. 进入源码目录，运行 mvn 命令，mvn 会根据项目中的 pom.xml 文件和编译参数编译源码，得到 .war  或 .jar 结尾的目标文件<br>  <span class="hljs-number">3</span>. 部署运行         <br>java构建工具(Maven)基础介绍:<br>  Maven 是一个项目管理工具，可以对  Java 项目进行构建、解决打包依赖  <br>  Maven的仓库:<br>    Maven 仓库使用流程:<br>      <span class="hljs-number">1</span>. 首先，在本地repo搜索指定的依赖，而后是Maven的repo服务<br>      <span class="hljs-number">2</span>. 若配置了远程repo服务，Maven还是搜索该repo<br>      <span class="hljs-number">3</span>. Maven默认使用的是其官方存储库，在国内的下载速度较慢，因而建议使用国内的Maven镜像仓库，例如阿里的镜像仓库等         <br><br>使用 Nexus 构建私有仓库:<br>  Nexus Repository Manager 是一个用于管理软件构建和依赖关系的存储库管理器。它支持多种包类型，包括 Maven、npm、Docker、RubyGems、PyPI 等。     <br>  主要功能和用途:<br>    - 包管理：开发人员可以使用 Nexus Repository Manager 来存储、管理和共享各种软件包和构建组件；<br>    - 代理远程存储库：Nexus 可以代理远程存储库，使您能够在本地缓存外部依赖项，提高构建速度和稳定性；<br>    - 安全和权限：Nexus 具有丰富的安全功能，可以管理用户访问权限，设置安全策略，保护组织的代码库免受潜在的安全漏洞；<br>    - 镜像和同步：Nexus 支持镜像和同步功能，让您能够创建多个存储库实例，并确保它们之间的数据同步；       <br>     <br>     <br>     <br>     <br>     <br>     <br>         <br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/Tomcat/image_lU7g-_Kmw4.png"></p><p>!!!!<img src="/../image/Tomcat/image_Pm5VjhTz4-.png"></p><p>!!!!<img src="/../image/Tomcat/image_DprWxAWOIp.png"></p><p>!!!!<img src="/../image/Tomcat/image_t2fFpDE7Y1.png"></p><p><img src="/image/image_IjCkbfH9Je.png" alt="java的jsp文件执行过程 java的jsp文件执行过程 " title="java的jsp文件执行过程 java的jsp文件执行过程 "></p><p><img src="/image/image_gDkqnCb00E.png" alt="Maven 仓库使用流程示意图 Maven 仓库使用流程示意图 " title="Maven 仓库使用流程示意图 Maven 仓库使用流程示意图 "></p><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td>Server</td><td>服务器，Tomcat运行的进程实例，一个Server中可以有多个service，但通常就一个</td></tr><tr><td>Service</td><td>服务，用来组织Engine和Connector的对应关系，一个service中只有一个Engine</td></tr><tr><td>Connector</td><td>连接器，负责客户端的HTTP、HTTPS、A JP等协议连接，一个Connector只属于某一个Engine</td></tr><tr><td>Engine</td><td>引擎，用来响应并处理用户请求。一个Engine上可以绑定多个Connector</td></tr><tr><td>Host</td><td>虚拟主机，可以实现多虚拟主机,例如使用不同的主机头区分</td></tr><tr><td>Context</td><td>应用的上下文，配置特定url路径映射和目录的映射关系：url &#x3D;&gt; directory</td></tr></tbody></table><p>xmllint 检查文件格式是否正确</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell编程</title>
    <link href="/2025/06/09/shell%E7%BC%96%E7%A8%8B/"/>
    <url>/2025/06/09/shell%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><p>循环逻辑</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs ada">循环逻辑<br>循环逻辑语法解析：<br>     关键字 [ 条件 ]<br>     <span class="hljs-keyword">do</span><br>         执行语句<br>     done<br> <br>  注意：<br>     这里的关键字主要有四种：<br>     <span class="hljs-keyword">for</span> - 循环遍历一个元素列表<br>     <span class="hljs-keyword">while</span> - 满足条件情况下一直循环下去<br>     until - 不满足条件情况下一直循环下去<br><br><span class="hljs-keyword">for</span>循环<br>  场景：遍历列表<br>      <span class="hljs-keyword">for</span> 值 <span class="hljs-keyword">in</span> 列表<br>      <span class="hljs-keyword">do</span><br>         执行语句<br>      done<br>  列表生成 <br>    样式<span class="hljs-number">1</span>：手工列表<br>      - <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br>    样式<span class="hljs-number">2</span>：定制列表<br>      - &#123;<span class="hljs-number">1</span>..<span class="hljs-number">7</span>&#125;<br>    样式<span class="hljs-number">3</span>：命令生成<br>      - $(seq <span class="hljs-number">1</span> <span class="hljs-number">7</span>)<br>    样式<span class="hljs-number">4</span>：脚本参数<br>      - $@ $*<br><br><span class="hljs-keyword">while</span>循环<br>  场景：只要条件满足，就一直循环下去<br>    <span class="hljs-keyword">while</span> [ 条件判断 ]<br>    <span class="hljs-keyword">do</span><br>       执行语句<br>    done  <br>  注意：<br>    条件支持的样式 命令、[[ 字符串表达式 ]]、(( 数字表达式 ))<br>    <span class="hljs-literal">true</span>是一个特殊的条件，代表条件永远成立<br><br>until循环<br>  场景：只要条件不满足，就一直循环下去<br>    until [ 条件判断 ]<br>    <span class="hljs-keyword">do</span><br>       执行语句<br>    done  <br>    注意：<br>    条件支持的样式 命令、[[ 字符串表达式 ]]、(( 数字表达式 ))<br>    <span class="hljs-literal">false</span>是一个特殊的条件，代表条件永远不成立  <br><br>循环控制<br>  所谓的流程控制，主要针对的是，当我们处于流程步骤执行的过程中，因为某些特殊的原因，不得不停止<br>既定的操作进行步骤的调整  <br>  <br>  continue控制<br>     - 满足条件的情况下，临时停止当前的循环，直接进入到下一循环<br>    continue主要有两种场景的表现样式：<br>        单循环场景下，continue是跳出当前循环<br>           - 仅有一层 <span class="hljs-keyword">while</span> 、<span class="hljs-keyword">for</span>、until等<br>        嵌套循环场景下，continue是可以跳出内层循环和外层循环。<br>           - 存在多层<span class="hljs-keyword">while</span>、<span class="hljs-keyword">for</span>、until嵌套等   <br>    <br>   continue语法格式：<br>        <span class="hljs-keyword">for</span> 循环列表<br>        <span class="hljs-keyword">do</span><br>           ...<br>           continue num<br>        done<br> 注意：<br> 单循环下，continue就代表跳出当前循环<br> 多循环下，continue的num就代表要继续的循环级别 <br>     <br>     <br>     <br>  break控制<br>     - 满足条件的情况下，提前退出当前的循环<br>    break命令是在处理过程中终止循环的一种简单方法。可以使用break命令退出任何类型的循环，包括<br><span class="hljs-keyword">for</span>、<span class="hljs-keyword">while</span>、until等。     <br>     break主要有两种场景的表现样式：<br>         单循环场景下，break是终止循环<br>              - 仅有一层 <span class="hljs-keyword">while</span> 、<span class="hljs-keyword">for</span>、until等<br>         嵌套循环场景下，break是可以终止内层循环和外层循环。<br>              - 存在多层<span class="hljs-keyword">while</span>、<span class="hljs-keyword">for</span>、until嵌套等     <br>       <br>       break语法格式：<br>          <span class="hljs-keyword">for</span> 循环列表<br>          <span class="hljs-keyword">do</span><br>               ...<br>               break num<br>          done<br> 注意：<br> 单循环下，break就代表退出循环<br> 多循环下，break的num大于嵌套的层数，就代表退出循环<br>     <br> <br> <br>  <span class="hljs-keyword">exit</span>控制<br>     - 直接退出当前循环的程序<br>  shift控制<br>     - 依次从循环列表中读取读取内容，并将读取的内容从列表中剔除      <br>    <br> <br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/shell%E7%BC%96%E7%A8%8B/image_tegX53efeC.png"></p><p>!!!!<img src="/../image/shell%E7%BC%96%E7%A8%8B/image__lvjriwNww.png"></p><p>函数</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs ada">基础知识<br><br><br>  函数的优势：<br>    <span class="hljs-number">1</span>. 代码模块化，调用方便，节省内存<br>    <span class="hljs-number">2</span>. 代码模块化，代码量少，排错简单<br>    <span class="hljs-number">3</span>. 代码模块化，可以改变代码的执行顺序<br>  <br>  基本语法<br>    定义函数：<br>      <br>      样式<span class="hljs-number">1</span>：标准格式<br>      <span class="hljs-keyword">function</span> <span class="hljs-title">函数名&#123;</span> <br>          函数体 <br>      &#125; <br>      <br>      样式2：简约格式<br>      函数名() &#123; <br>         函数体 <br>      &#125;<br>注意：<br> <span class="hljs-keyword">function</span> <span class="hljs-title">的作用和</span> () 的作用是一样的，都是定义一个函数。<br> 函数的名称是自定义的，而且在脚本范围内必须唯一。<br> 函数体内是普通的能够正常执行的命令，命令的执行流程符合顺序逻辑。<br>    <br>    调用函数： <br>       函数名 <br>    注意：<br>        函数名出现在任何位置，就代表在该位置调用函数内代码块的执行。<br>        函数名一般在函数定义后调用，否则的话会发生报错。     <br><br>函数表现样式：<br>  1.最简单的功能代码块<br>     关注的是命令的执行<br>  2.稍显繁琐的功能代码块<br>      -最简单的功能代码块+简单逻辑判断<br>  3.更复杂的函数调用<br>     关注的是代码逻辑的实现<br><br><br>传参函数：<br>  定义函数：<br>    函数名() &#123; <br>        函数体 $&#123;变量名&#125; <br>    &#125;<br>注意：<br>   函数体内通过 $&#123;变量名&#125; 来实现函数体的功能通用性。    <br><br>调用函数： <br>   函数名 参数 <br>注意：<br>   函数在调用的时候，接收一些参数并传输到函数体内部。<br><br>函数退出：<br>  样式1-默认的退出状态<br>       默认情况下，函数的退出状态是函数体内的最后一条命令的退出状态，可以通过 $? 来获取<br>  样式2-<span class="hljs-keyword">return</span>定制状态返回值<br>       在函数体内部，通过<span class="hljs-keyword">return</span>定制状态返回值的内容<br>       应用场景：主动退出函数的功能<br>  注意：<br>      <span class="hljs-keyword">return</span>的状态返回值必须尽快使用，否则会被其他<span class="hljs-keyword">return</span>的值覆盖<br>      <span class="hljs-keyword">return</span>的状态返回值必须在 0-255，否则失效      <br><br>函数变量：<br>  变量类型：<br>    全局变量:<br>        默认情况下，脚本中的普通变量就是全局变量，作用范围是shell脚本的所有地方，在函数内部也可以正常使用<br>        而且函数内可以可以修改脚本级别的全局变量<br>    局部变量:<br>        我们可以通过local语法，将变量的作用范围限制在一段代码块范围中。<br>        注意：脚本内无法使用local语法，仅限于函数体内     <br></code></pre></td></tr></table></figure><p>脚本自动化</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs ada">当我们在构建一些更高级的脚本的时候，就会涉及到如何在linux系统上来更好的运行和控制它们，到目前为止，我们运行脚本的方式都是以实时的模式，在命令行来运行它。但是这并不是脚本唯一的运行方式，我们可以在linux系统中以更丰富的方式来运行它们，甚至在脚本遇到不可查的异常中止时候，以关闭linux终端界面的方式终止脚本。<br>   这些能力都是基于信号的机制来实现了<br><br>重复性工作|无需人工干预，可以实现自动根据书记来进行判断并执行<br>获取数据的方式：<br>  半自动化：read<br>  自动化（代码级别）：信号|expect<br><br>ps aux 查看进程<br><br>生成信号<br>  终止进程：<br>     ctrl+c,<br>  暂停进程:(挂起进程)<br>     ctrl+z,停止的进程继续保留在内存中，并能从停止的位置继续运行<br>  恢复进程:<br>     jobs查看运行任务，fg num 重新执行<br>  杀死进程:<br>     kill -<span class="hljs-number">9</span> pid<br><br>expect基础<br>  场景需求:<br>    在日常工作中，经常会遇到各种重复性的<span class="hljs-string">&quot;手工交互&quot;</span>操作，虽然没有什么技术含量，但是相当的重要。在实际的工作场景中，这种重复性的手工操作动作，非常的繁多，但是对于量大的工作来说，效率就非常低效了。所以我们就需要有一种工具，能够简化我们重复的手工操作。  <br><br>  expect是一个免费的编程工具它可以根据程序的提示，模拟标准输入提供给程序，从而实现自动的交互式任务，而无需人为干预,可以用作Unix系统中进行应用程序的自动化控制和测试的软件工具。  <br>  yum install expect -y 安装软件<br>  expect  进入专用的命令交互界面       <br>     <br>常见符号:<br>  &#123; &#125;：代码块<br>      作用<span class="hljs-number">2</span>：代码块儿，但是两个 &#123;&#125; 边界必须在一起。<br>         正确样式：<br>         <span class="hljs-keyword">if</span> &#123;代码块<span class="hljs-number">1</span> &#125; &#123;<br>             代码块<span class="hljs-number">2</span><br>             &#125;<br>         错误示例：<br>         <span class="hljs-keyword">if</span> &#123;$count &lt; <span class="hljs-number">0</span>&#125;<br>            &#123;<br>             break;<br>            &#125;<br> 注意：<br> 无论什么时候，&#123;&#125;边界符号与其他内容都最好有空格隔开，尤其是边界外的内容  <br><br>常用命令:<br>  set 设定环境变量      #在shell中是变量名=变量值<br>     格式：set 变量名 变量值<br>     样式：set host <span class="hljs-string">&quot;192.168.8.12&quot;</span><br> <br>  spawn 启动新的进程，模拟手工在命令行启动服务<br>     格式：spawn 手工执行命令<br>     样式：spawn ssh python@$host<br>  expect 接收一个新进程的反馈信息，我们根据进程的反馈，再发送对应的交互命令<br>     格式：expect <span class="hljs-string">&quot;交互界面用户输入处的关键字&quot;</span><br>     样式：expect <span class="hljs-string">&quot;*password*&quot;</span><br> <br>  send 接收一个字符串参数，并将该参数发送到新进程。<br>     格式：send <span class="hljs-string">&quot;用户输入的信息&quot;</span> <br>     样式：send <span class="hljs-string">&quot;$password\r&quot;</span><br> <br>  interact 退出自动化交互界面，进入用户交互状态，如果需要用户交互的话，这条命令必须在最后一行<br>     格式：interact<br>     样式：interact  <br><br>脚本结合:<br>  expect 除了使用专用的expect脚本来实现特定功能之外，它还可以与其他脚本嵌套在一起进行使用。最常用的结合方式就是 shell结合。<br>  在于shell结合使用的时候，无非就是将expect的执行命令使用 &lt;&lt;-EOF  。。。 EOF 包装在一起即可。<br>  样式：<br>  /usr/bin/expect&lt;&lt;-EOF<br>  spawn ...<br>  ...<br>  expect eof <br>  EOF<br>注意：<br>  由于expect在shell中是作为一个子部分而存在的，所以，一般情况下，expect结束的时候，使用eof命令表示expect的内容到此结束<br>  <br>高级赋值:<br>  所谓的高级赋值，是另外的一种变量值获取方法，这里涉及到更多我们学习之外的一些shell内置变量格式,其实这部分的内容主要还是在字符串的基础上，如何更精细的获取特定的信息内容：主要涉及到的内容样式<br><br>  字符串截取按分隔符截取: # 右 % 左<br>    $&#123;file#/&#125;   删除匹配结果，保留第一个/右边的字符串<br>    $&#123;file##/&#125; 删除匹配结果，保留最后一个/右边的字符串<br>    $&#123;file%/&#125; 删除匹配结果，保留第一个/左边的字符串<br>    $&#123;file%%/&#125; 删除匹配结果，保留最后一个/左边的字符串<br>    注意：<br>        匹配内容的正则表达式，尽量不要出现特殊边界字符    <br><br>  字符串替换<br>    $&#123;file/dir/path&#125; 把第一个dir替换成path：/path1/dir2/dir3/n<br>    $&#123;file//dir/path&#125; 把所有dir替换成path：/path1/path2/path3/n<br>    $&#123;file/#dir/path&#125; 将从左侧能匹配到的dir，则替换成 path 然后返回；否则直接返回$&#123;var&#125;。<br>    $&#123;file/%dir/path&#125; 将从右侧能匹配到的dir，则替换成 path 然后返回；否则直接返回$&#123;var&#125;。<br>    注意：<br>        如果匹配内容使用的是正则符号，应该注意正则符号的写法  <br><br>  字符串转换<br>    $&#123;file^^&#125; 把file中的所有小写字母转换为大写<br>    $&#123;file,,&#125; 把file中的所有大写字母转换为小写   <br>  <br>嵌套变量:<br>  场景<span class="hljs-number">1</span>：我们知道，命令变量的的表现样式：<br>      ver=$(命令)<br>      <span class="hljs-comment">-- 执行原理是，当`` 或者 $() 范围中存在能够正常解析的命令的话，会先执行命令，然后将命令执行的结果交个一个变量名。</span><br>  场景<span class="hljs-number">2</span>：它还有另外一种样式 <span class="hljs-comment">-- 普通变量的第三种样式双引号</span><br>     ming=shuji; name=<span class="hljs-string">&quot;wang-$ming&quot;</span><br>     <span class="hljs-comment">-- 解析原理：双引号会首先查看变量值范围内是否有可以解析的变量名，如果有的话，将解析后的结果放到变量值范围内，组合成一个新的变量值，然后交给变量名。    </span><br>  <br>在shell中，它提供了一个专属的命令，可以实现多层隐藏命令的解析，不仅仅能够解析，还能够将相关环境的属性重现，从而实现多层隐藏命令的顺利执行。这个命令就是 eval。 <br>eval原理<br> <span class="hljs-number">1</span> eval命令将会首先扫描命令行整体<br> <span class="hljs-number">2</span> 发现解析则解析，发现执行则预先执行，实现所有隐藏命令的成功执行<br> <span class="hljs-number">3</span> 将隐藏命令执行的最终结果进行置换<br> <span class="hljs-number">4</span> 最后执行命令行表面的命令。    <br>    <br><br><br><br><br><br><br><br>     <br><br></code></pre></td></tr></table></figure><p>案例(跨主机免密码认证)</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs ada">使用密钥认证<br><span class="hljs-number">1</span>.本地主机生成密钥对<br>  ssh-keygen -t rsa -P <span class="hljs-string">&quot;&quot;</span> -f ~/.ssh/id_rsa<br>  <br><span class="hljs-number">2</span>.把公钥信息传递给远程主机的指定用户<br>  ssh-copy-id -i /root/.ssh/id_rsa.pub root@<span class="hljs-number">10.0</span>.<span class="hljs-number">0.15</span>  <br><br><span class="hljs-number">3</span>.在主机上测试一下<br>  ssh root@<span class="hljs-number">10.0</span>.<span class="hljs-number">0.15</span> ip a<br>  <br>定制脚本文件  remotehost_sshkey_auth.sh<br>  <br><br><br>#!bin/bash<br>user_dir=<span class="hljs-string">&quot;/root&quot;</span><br>login_user=<span class="hljs-symbol">&#x27;root</span>&#x27;<br>login_pass=&#x27;<span class="hljs-number">123456</span>&#x27;<br># 定制数组变量<br>target_type=(部署 免密 退出)<br># 定制安装软件的函数<br>expect_install()&#123;<br>    yum install expect -y &gt;&gt; /dev/null<br>    echo <span class="hljs-string">&quot;软件安装完毕&quot;</span><br>&#125;<br># 定制ssh秘钥对的生成<br>sshkey_create()&#123;<br>    # 清理历史秘钥<br>    [ -d $&#123;user_dir&#125;/.ssh ] &amp;&amp; rm -rf $&#123;user_dir&#125;/.ssh<br>    # 生成新的秘钥<br>    ssh-keygen -t rsa -P <span class="hljs-string">&quot;&quot;</span> -f $&#123;user_dir&#125;/.ssh/id_rsa &gt;&gt; /dev/null<br>    echo <span class="hljs-string">&quot;秘钥生成完毕&quot;</span><br>&#125;<br># 定制expect的认证逻辑<br>expect_process()&#123;<br>    command=<span class="hljs-string">&quot;$@&quot;</span><br>    expect -c <span class="hljs-string">&quot;</span><br><span class="hljs-string">        spawn $&#123;command&#125;</span><br><span class="hljs-string">        expect &#123;</span><br><span class="hljs-string">            \&quot;</span>*yes/no*\<span class="hljs-string">&quot; &#123;send \&quot;</span>yes\r\<span class="hljs-string">&quot;; exp_continue&#125;</span><br><span class="hljs-string">            \&quot;</span>*password*\<span class="hljs-string">&quot; &#123;send \&quot;</span>$&#123;login_pass&#125;\r\<span class="hljs-string">&quot;; exp_continue&#125;</span><br><span class="hljs-string">            \&quot;</span>*Password*\<span class="hljs-string">&quot; &#123;send \&quot;</span>$&#123;login_pass&#125;\r\<span class="hljs-string">&quot;;&#125;</span><br><span class="hljs-string">        &#125;&quot;</span><br>&#125;<br># 跨主机密码认证<br>sshkey_auth()&#123;<br>    local host_list=<span class="hljs-string">&quot;$1&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> $&#123;host_list&#125;; <span class="hljs-keyword">do</span><br>        command=<span class="hljs-string">&quot;/usr/bin/ssh-copy-id -i /root/.ssh/id_rsa.pub&quot;</span><br>        remote=<span class="hljs-string">&quot;$&#123;login_user&#125;@$i&quot;</span><br>        expect_process <span class="hljs-string">&quot;$&#123;command&#125; $&#123;remote&#125;&quot;</span><br>    done<br>&#125;<br># 定制服务的操作提示功能函数<br>menu()&#123;<br>    echo -e <span class="hljs-string">&quot;\e[31m---------------管理平台操作界面---------------&quot;</span><br>    echo -e <span class="hljs-string">&quot; 1: 秘钥准备 2: 免密认证 3: 退出操作&quot;</span><br>    echo -e <span class="hljs-string">&quot;-------------------------------------------\033[0m&quot;</span><br>&#125;<br># 定制脚本帮助信息<br>Usage()&#123;<br>    echo <span class="hljs-string">&quot;请输入有效的操作标识!!!&quot;</span><br>&#125;<br># 定制业务逻辑<br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span>; <span class="hljs-keyword">do</span><br>    menu<br>    read -p <span class="hljs-string">&quot;&gt; 请输入要操作的目标类型: &quot;</span> target_id<br><br>    <span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;$&#123;target_type[$((target_id-1))]&#125;&quot;</span> == <span class="hljs-string">&quot;部署&quot;</span> ]; <span class="hljs-keyword">then</span><br>        echo <span class="hljs-string">&quot;开始部署秘钥环境...&quot;</span><br>        expect_install<br>        sshkey_create<br>    elif [ <span class="hljs-string">&quot;$&#123;target_type[$((target_id-1))]&#125;&quot;</span> == <span class="hljs-string">&quot;免密&quot;</span> ]; <span class="hljs-keyword">then</span><br>        read -p <span class="hljs-string">&quot;&gt; 请输入免密10.0.0网段主机的范围，示例&#123;12..19&#125;: &quot;</span> num_list<br>        # 验证输入格式<br>        <span class="hljs-keyword">if</span> [[ ! $num_list =~ ^\&#123;[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+\.\.[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]+\&#125;$ ]]; <span class="hljs-keyword">then</span><br>            echo <span class="hljs-string">&quot;输入的网段范围格式不正确！请使用 &#123;start..end&#125; 格式&quot;</span><br>            continue<br>        fi<br>        # 解析网段范围<br>        ip_list=$(eval echo <span class="hljs-number">10.0</span>.<span class="hljs-number">0</span>.$&#123;num_list&#125;)<br>        sshkey_auth <span class="hljs-string">&quot;$&#123;ip_list&#125;&quot;</span><br>    elif [ <span class="hljs-string">&quot;$&#123;target_type[$((target_id-1))]&#125;&quot;</span> == <span class="hljs-string">&quot;退出&quot;</span> ]; <span class="hljs-keyword">then</span><br>        echo <span class="hljs-string">&quot;准备退出管理操作界面...&quot;</span><br>        <span class="hljs-keyword">exit</span><br>    <span class="hljs-keyword">else</span><br>        Usage<br>    fi<br>done<br><br><br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/shell%E7%BC%96%E7%A8%8B/image_WVA8hRwnNT.png"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>企业级容器技术 Docker</title>
    <link href="/2025/06/09/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%20Docker/"/>
    <url>/2025/06/09/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%20Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="企业级容器技术-Docker"><a href="#企业级容器技术-Docker" class="headerlink" title="企业级容器技术 Docker"></a>企业级容器技术 Docker</h1><h4 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Docker 相比虚拟机的交付速度更快，资源消耗更低，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器，docker 的三大理念是build(构建)、ship(运输)、 run(运行)，Docker遵从apache <span class="hljs-number">2.0</span>协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障等，所以Docke容器在运行时不需要类似虚拟机（空运行的虚拟机占用物理机<span class="hljs-number">6</span><span class="hljs-literal">-8</span>%性能）的额外资源开销，因此可以大幅提高资源利用率,总而言之Docker是一种用了新颖方式实现的轻量级虚拟机.类似于VM但是在原理和应用上和VM的差别还是很大的，并且docker的专业叫法是应用容器(Application Container)。<br></code></pre></td></tr></table></figure><h4 id="Docker-的主要目标"><a href="#Docker-的主要目标" class="headerlink" title="Docker 的主要目标"></a>Docker 的主要目标</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Build, Ship and Run Any App, Anywhere，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了应用和运行环境的兼容性问题，从而极大提升了部署效率，减少故障的可能性<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级容器技术 Docker&#x2F;image-20250408140309188.png)</p><h4 id="使用Docker-容器化封装应用程序的意义"><a href="#使用Docker-容器化封装应用程序的意义" class="headerlink" title="使用Docker 容器化封装应用程序的意义"></a>使用Docker 容器化封装应用程序的意义</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">统一基础设施环境<span class="hljs-literal">-docker</span>环境<br>  硬件的组成配置<br>  操作系统的版本<br>  运行时环境的异构<br>统一程序打包（装箱）方式<span class="hljs-literal">-docker</span>镜像<br>  java程序<br>  python程序<br>  nodejs程序<br>统一程序部署（运行）方式<span class="hljs-literal">-docker</span>容器<br>  java <span class="hljs-literal">-jar</span>...→ docker run...<br>  python manage.py runserver... → docker run...<br>  npm run dev ... → docker run...<br></code></pre></td></tr></table></figure><h4 id="Docker-和虚拟机，物理主机"><a href="#Docker-和虚拟机，物理主机" class="headerlink" title="Docker 和虚拟机，物理主机"></a>Docker 和虚拟机，物理主机</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">```<br><br>!!!!![](../image/企业级容器技术 Docker/image<span class="hljs-literal">-20250408140442265</span>.png)<br><br><span class="hljs-comment">#### 容器和虚拟机技术比较</span><br><br>```powershell<br>传统虚拟机是虚拟出一个主机硬件,并且运行一个完整的操作系统 ,然后在这个系统上安装和运行软件<br>容器内的应用直接运行在宿主机的内核之上,容器并没有自己的内核,也不需要虚拟硬件,相当轻量化<br>每个容器间是互相隔离,每个容器内都有一个属于自己的独立文件系统,独立的进程空间,网络空间,用<br>户空间等,所以在同一个宿主机上的多个容器之间彼此不会相互影响<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级容器技术 Docker&#x2F;image-20250408140931358.png)</p><h4 id="容器和虚拟机比较"><a href="#容器和虚拟机比较" class="headerlink" title="容器和虚拟机比较"></a>容器和虚拟机比较</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">资源利用率更高: 开销更小,不需要启动单独的虚拟机OS内核占用硬件资源,可以将服务器性能压榨至极致.虚拟机一般会有<span class="hljs-number">5</span><span class="hljs-literal">-20</span>%的损耗,容器运行基本无损耗,所以生产中一台物理机只能运行数十个虚拟机，但是一般可以运行数百个容器<br>启动速度更快: 可以在数秒内完成启动<br>占用空间更小: 容器一般占用的磁盘空间以MB为单位,而虚拟机以GB<br>集成性更好: 和 CI/<span class="hljs-built_in">CD</span>（持续集成/持续部署）相关技术结合性更好，实现打包镜像发布测试可以一键运行,做到自动化并快速的部署管理,实现高效的开发生命周期<br></code></pre></td></tr></table></figure><h4 id="Docker-的组成"><a href="#Docker-的组成" class="headerlink" title="Docker 的组成"></a>Docker 的组成</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Docker 主机(Host): 一个物理机或虚拟机，用于运行Docker服务进程和容器，也称为宿主机，node节点<br>Docker 服务端(Server): Docker守护进程，运行docker容器 docker engine<br>Docker 客户端(Client): 客户端使用 docker 命令或其他工具调用docker API<br>Docker 镜像(Images): 镜像可以理解为创建实例使用的模板,本质上就是一些程序文件的集合<br>Docker 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/，可以搭建私有仓库harbor<br>Docker 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务,其本质就是将镜像中的程序启动后生成的进程<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级容器技术 Docker&#x2F;image-20250408141033462.png)</p><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">一个宿主机运行了N个容器，多个容器共用一个 OS，必然带来的以下问题:<br>怎么样保证每个容器都有不同的文件系统并且能互不影响？<br>一个docker主进程内的各个容器都是其子进程，那么如果实现同一个主进程下不同类型的子进程？<br>各个容器子进程间能相互通信(内存数据)吗？<br>每个容器怎么解决IP及端口分配的问题？<br>多个容器的主机名能一样吗？<br>每个容器都要不要有root用户？怎么解决账户重名问题？<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级容器技术 Docker&#x2F;image-20250408141141555.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">namespace是Linux系统的底层概念，在LInux内核层实现，即有一些不同类型的命名空间被部署在内核，各个docker容器运行在同一个docker主进程并且共用同一个宿主机系统内核，各docker容器运行在宿主机的用户空间，每个容器都要有类似于虚拟机一样的相互隔离的运行空间，但是容器技术是在一个进程内实现运行指定服务的运行环境，并且还可以保护宿主机内核不受其他进程的干扰和影响，如文件系统空间、网络空间、进程空间等，目前主要通过以下技术实现容器运行空间的相互隔离:<br></code></pre></td></tr></table></figure><table><thead><tr><th>隔离类型</th><th>功能</th><th>系统调用参数</th><th>内核版本</th></tr></thead><tbody><tr><td>MNT Namespace(mount)</td><td>提供磁盘挂载点和文件系统的隔离能力</td><td>CLONE_NEWNS</td><td>2.4.19</td></tr><tr><td>PID Namespace(Process Identification)</td><td>提供进程隔离能力</td><td>CLONE_NEWPID</td><td>2.6.24</td></tr><tr><td>IPC Namespace(Inter - Process Communication)</td><td>提供进程间通信的隔离能力，包括信号量、消息队列和共享内存</td><td>CLONE_NEWIPC</td><td>2.6.19</td></tr><tr><td>Net Namespace(network)</td><td>提供网络隔离能力，包括网络设备、网络栈、端口等</td><td>CLONE_NEWNET</td><td>2.6.29</td></tr><tr><td>UTS Namespace(UNIX Timesharing System)</td><td>提供内核、主机名和域名隔离能力</td><td>CLONE_NEWUTS</td><td>2.6.19</td></tr><tr><td>User Namespace(user)</td><td>提供用户隔离能力，包括用户和组</td><td></td><td></td></tr></tbody></table><h3 id="Namespace-类型概述"><a href="#Namespace-类型概述" class="headerlink" title="Namespace 类型概述"></a>Namespace 类型概述</h3><ul><li>Pid namespace<ul><li>不同用户的进程通过 Pid namespace 隔离开，不同 namespace 中可存在相同 Pid。</li><li>借助 Pid namespace，各 namespace 中的 Pid 能够相互隔离。</li></ul></li><li>net namespace<ul><li>网络隔离由 net namespace 实现。</li><li>每个 net namespace 具备独立的 network devices、IP addresses、IP routing tables 以及 &#x2F;proc&#x2F;net 目录。</li><li>Docker 默认采用 veth 的方式，将 container 中的虚拟网卡与 host 上的 docker bridge（docker0）连接起来。</li></ul></li><li>ipc namespace<ul><li>Container 中进程交互采用 Linux 常见的进程间交互方法（IPC），如信号量、消息队列和共享内存。</li><li>container 的进程间交互实质是 host 上具有相同 Pid namespace 中的进程间交互，所以在 IPC 资源申请时需加入 namespace 信息，每个 IPC 资源有唯一的 32 位 ID。</li></ul></li><li>mnt namespace<ul><li>mnt namespace 允许不同 namespace 的进程看到不同的文件结构，从而隔离各 namespace 中进程所看到的文件目录。</li></ul></li><li>uts namespace<ul><li>UTS（“UNIX Time - sharing System”）namespace 使每个 container 拥有独立的 hostname 和 domain name，使其在网络上可被视为独立节点，而非 Host 上的一个进程。</li></ul></li><li>user namespace<ul><li>每个 container 能有不同的 user 和 group id，可在 container 内部使用 container 内部的用户执行程序，而非 Host 上的用户。</li></ul></li></ul><h4 id="容器管理工具"><a href="#容器管理工具" class="headerlink" title="容器管理工具"></a>容器管理工具</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">有了以上的namespace、cgroups就具备了基础的容器运行环境，但是还需要有相应的容器创建与删除的管理工具、以及怎么样把容器运行起来、容器数据怎么处理、怎么进行启动与关闭等问题需要解决，于是容器管理技术出现了。目前主要是使用docker，containerd等，早期使用 LXC<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级容器技术 Docker&#x2F;image-20250408142745319.png)</p><h4 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">快速部署: 短时间内可以部署成百上千个应用，更快速交付到线上<br>高效虚拟化: 不需要额外hypervisor支持，基于linux内核实现应用虚拟化，相比虚拟机大幅提高性能和效率<br>节省开支: 提高服务器利用率，降低IT支出<br>简化配置: 将运行环境打包保存至容器，使用时直接启动即可<br>环境统一: 将开发，测试，生产的应用运行环境进行标准化和统一，减少环境不一样带来的各种问题<br>快速迁移和扩展: 可实现跨平台运行在物理机、虚拟机、公有云等环境，良好的兼容性可以方便将应用从A宿主机迁移到B宿主机，甚至是A平台迁移到B平台<br>更好的实现面向服务的架构,推荐一个容器只运行一个应用,实现分布的应用模型,可以方便的进行横向扩展,符合开发中高内聚,低耦合的要求,减少不同服务之间的相互影响<br></code></pre></td></tr></table></figure><h4 id="Docker-的缺点"><a href="#Docker-的缺点" class="headerlink" title="Docker 的缺点"></a>Docker 的缺点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">多个容器共用宿主机的内核，各应用之间的隔离不如虚拟机彻底<br>由于和宿主机之间的进程也是隔离的,需要进入容器查看和调试容器内进程等资源,变得比较困难和繁琐<br>如果容器内进程需要查看和调试,需要在每个容器内都需要安装相应的工具,这也造成存储空间的重复浪费<br></code></pre></td></tr></table></figure><h4 id="镜像仓库-Registry"><a href="#镜像仓库-Registry" class="headerlink" title="镜像仓库 Registry"></a>镜像仓库 Registry</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">统一保存镜像而且是多个不同镜像版本的地方，叫做镜像仓库<br>  Docker hub: docker官方的公共仓库，已经保存了大量的常用镜像，可以方便大家直接使用<br>  阿里云，网易等第三方镜像的公共仓库<br>  Image registry: docker 官方提供的私有仓库部署工具，无web管理界面，目前使用较少<br>  Harbor: vmware 提供的自带web界面自带认证功能的镜像私有仓库，目前有很多公司使用<br></code></pre></td></tr></table></figure><h4 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">官方文档 : https://docs.docker.com/engine/install/<br>阿里云文档: https://developer.aliyun.com/mirror/docker<span class="hljs-literal">-ce</span>?spm=a2c6<span class="hljs-built_in">h</span>.<span class="hljs-number">13651102.0</span>.<span class="hljs-number">0.3</span>e221b11guHCWE<br>安装方法<br>内置仓库<br>官方仓库（国内镜像）<br>二进制安装（离线）<br>官方脚本<br>Ubuntu 包安装和删除Docker<br>官方文档: https://docs.docker.com/install/linux/docker<span class="hljs-literal">-ce</span>/ubuntu/<br></code></pre></td></tr></table></figure><h5 id="配置daemon-json-优化docker"><a href="#配置daemon-json-优化docker" class="headerlink" title="配置daemon.json   优化docker"></a>配置daemon.json   优化docker</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs powershell">/etc/docker/daemon.json<br><br><br><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>,<br>    <span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br>    <span class="hljs-string">&quot;https://si7y70hh.mirror.aliyuncs.com&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;exec-opts&quot;</span>: [<br>    <span class="hljs-string">&quot;native.cgroupdriver=systemd&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;data-root&quot;</span>: <span class="hljs-string">&quot;/data/docker&quot;</span>,<br>  <span class="hljs-string">&quot;max-concurrent-downloads&quot;</span>: <span class="hljs-number">10</span>,<br>  <span class="hljs-string">&quot;max-concurrent-uploads&quot;</span>: <span class="hljs-number">5</span>,<br>  <span class="hljs-string">&quot;log-opts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;max-size&quot;</span>: <span class="hljs-string">&quot;300m&quot;</span>,<br>    <span class="hljs-string">&quot;max-file&quot;</span>: <span class="hljs-string">&quot;2&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;dns&quot;</span>: [<span class="hljs-string">&quot;8.8.8.8&quot;</span>, <span class="hljs-string">&quot;8.8.4.4&quot;</span>]<br>&#125;<br><br><br><br><br><br><br><br>sudo systemctl daemon<span class="hljs-literal">-reexec</span><br>sudo systemctl daemon<span class="hljs-literal">-reload</span><br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h5 id="配置http-proxy-conf"><a href="#配置http-proxy-conf" class="headerlink" title="配置http-proxy.conf"></a>配置http-proxy.conf</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mkdir <span class="hljs-literal">-p</span> /etc/systemd/system/docker.service.d<br>vim /etc/systemd/system/docker.service.d/http<span class="hljs-literal">-proxy</span>.conf<br><br><br><br>[<span class="hljs-type">Service</span>]<br>Environment=<span class="hljs-string">&quot;HTTP_PROXY=http://172.22.101.168:7890&quot;</span><br>Environment=<span class="hljs-string">&quot;HTTPS_PROXY=http://172.22.101.168:7890&quot;</span><br>Environment=<span class="hljs-string">&quot;NO_PROXY=localhost,127.0.0.1,::1&quot;</span><br><br><br><br><br><br>sudo systemctl daemon<span class="hljs-literal">-reexec</span><br>sudo systemctl daemon<span class="hljs-literal">-reload</span><br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><h4 id="容器镜像管理"><a href="#容器镜像管理" class="headerlink" title="容器镜像管理"></a>容器镜像管理</h4><h5 id="镜像结构和原理"><a href="#镜像结构和原理" class="headerlink" title="镜像结构和原理"></a>镜像结构和原理</h5><p>!!!!![](..&#x2F;image&#x2F;企业级容器技术 Docker&#x2F;image-20250410103914849.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">```<br><br><span class="hljs-comment">#### 搜索镜像</span><br><br>```powershell<br>http://hub.docker.com<br>http://dockerhub.com<br>https://hub<span class="hljs-literal">-stage</span>.docker.com/<br><br><br><br>执行docker search命令进行搜索<br>docker search centos<br></code></pre></td></tr></table></figure><h4 id="Alpine"><a href="#Alpine" class="headerlink" title="Alpine"></a>Alpine</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Alpine 操作系统是一个面向安全的轻型 Linux 发行版。<br>alpine 管理软件<br><br><br><span class="hljs-comment">#更新源</span><br>apk update = apt update<br><span class="hljs-comment">#安装软件</span><br>apk add vim = apt install vim<br><span class="hljs-comment">#删除软件</span><br>apk <span class="hljs-built_in">del</span> openssh openntp vim = apt remove openssh<br><span class="hljs-comment">#安装常见软件</span><br>apk update &amp;&amp; apk <span class="hljs-literal">--no-cache</span> add bash <span class="hljs-built_in">curl</span> telnet <span class="hljs-built_in">wget</span> net<span class="hljs-literal">-tools</span> pstree zip<br>unzip<br><span class="hljs-comment">#安装常用编译工具</span><br>apk update &amp;&amp; apk <span class="hljs-literal">--no-cache</span> add gcc make <span class="hljs-built_in">curl</span> zip unzip net<span class="hljs-literal">-tools</span> pstree <span class="hljs-built_in">wget</span><br>libgcc libc<span class="hljs-literal">-dev</span> libcurl libc<span class="hljs-literal">-utils</span> pcre<span class="hljs-literal">-dev</span> zlib<span class="hljs-literal">-dev</span> libnfs pcre pcre2 libevent<br>libevent<span class="hljs-literal">-dev</span> iproute2<br><span class="hljs-comment">#修改时区</span><br>apk update &amp;&amp; apk <span class="hljs-literal">--no-cache</span> add tzdata &amp;&amp; ln <span class="hljs-literal">-s</span><br>/usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Asia/Shanghai&quot;</span> &gt;<br>/etc/timezone<br></code></pre></td></tr></table></figure><h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker pull [<span class="hljs-type">OPTIONS</span>] NAME[:<span class="hljs-type">TAG</span>|@<span class="hljs-type">DIGEST</span>]<br>Options:<br><span class="hljs-literal">-a</span>, <span class="hljs-literal">--all-tags</span> Download all tagged images <span class="hljs-keyword">in</span> the repository<br><span class="hljs-literal">--disable-content-trust</span> Skip image verification (default true)<br><span class="hljs-literal">--platform</span> string <span class="hljs-built_in">Set</span> platform <span class="hljs-keyword">if</span> server is multi<span class="hljs-literal">-platform</span> capable<br><span class="hljs-literal">-q</span>, <span class="hljs-literal">--quiet</span> Suppress verbose output<br>NAME: 是镜像名,一般的形式 仓库服务器:端口/项目名称/镜像名称<br>:TAG: 即版本号,如果不指定:TAG,则下载最新版镜像<br></code></pre></td></tr></table></figure><h4 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker images [<span class="hljs-type">OPTIONS</span>] [<span class="hljs-type">REPOSITORY</span>[:<span class="hljs-type">TAG</span>]]<br>docker image <span class="hljs-built_in">ls</span> [<span class="hljs-type">OPTIONS</span>] [<span class="hljs-type">REPOSITORY</span>[:<span class="hljs-type">TAG</span>]]<br><br>[<span class="hljs-type">root</span>@<span class="hljs-type">bogon</span> <span class="hljs-type">docker</span>]<span class="hljs-variable">$</span> docker image <span class="hljs-built_in">ls</span><br>REPOSITORY                                 TAG       IMAGE ID       CREATED         SIZE<br>ubuntu                                     latest    <span class="hljs-number">602</span>eb6fb314b   <span class="hljs-number">40</span> hours ago    <span class="hljs-number">78.1</span>MB<br>alpine                                     <span class="hljs-number">3.21</span>.<span class="hljs-number">3</span>    aded1e1a5b37   <span class="hljs-number">7</span> weeks ago     <span class="hljs-number">7.83</span>MB<br>nginx                                      latest    <span class="hljs-number">4</span>cad75abc83d   <span class="hljs-number">2</span> months ago    <span class="hljs-number">192</span>MB<br>hello<span class="hljs-literal">-world</span>                                latest    <span class="hljs-number">74</span>cc54e27dc4   <span class="hljs-number">2</span> months ago    <span class="hljs-number">10.1</span>kB<br>redis                                      latest    <span class="hljs-number">65750</span>d044ac8   <span class="hljs-number">3</span> months ago    <span class="hljs-number">117</span>MB<br>registry.k8s.io/ingress<span class="hljs-literal">-nginx</span>/controller   v1.<span class="hljs-number">7.1</span>    <span class="hljs-number">2</span>db0b57c8712   <span class="hljs-number">23</span> months ago   <span class="hljs-number">289</span>MB<br><br><br>执行结果的显示信息说明:<br>REPOSITORY                  <span class="hljs-comment">#镜像所属的仓库名称</span><br>TAG                         <span class="hljs-comment">#镜像版本号（标识符），默认为latest</span><br>IMAGE ID                    <span class="hljs-comment">#镜像唯一ID标识,如果ID相同,说明是同一个镜像有多个名称</span><br>CREATED                     <span class="hljs-comment">#镜像在仓库中被创建时间</span><br>VIRTUAL SIZE                <span class="hljs-comment">#镜像的大小</span><br><br><br>docker images <span class="hljs-literal">--format</span>命令用于指定在输出中显示映像信息的格式。格式字符串由多个占位符组成，每个占位符代表映像的特定属性。<br><br><span class="hljs-comment">#常用的格式占位符：</span><br>&#123;&#123;.Repository&#125;&#125;：映像的仓库名称。<br>&#123;&#123;.Tag&#125;&#125;：映像的标签。<br>&#123;&#123;.ID&#125;&#125;：映像的ID。<br>&#123;&#123;.Digest&#125;&#125;：映像的摘要值。<br>&#123;&#123;.CreatedAt&#125;&#125;：映像的创建时间。<br>&#123;&#123;.Size&#125;&#125;：映像的大小。<br><br><br><span class="hljs-comment">#示例</span><br>docker images <span class="hljs-literal">--format</span> <span class="hljs-string">&quot;&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;\t&#123;&#123;.Size&#125;&#125;&quot;</span><br>docker images <span class="hljs-literal">--format</span> <span class="hljs-string">&quot;&#123;&#123;.CreatedAt&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;&quot;</span> | <span class="hljs-built_in">sort</span> <span class="hljs-literal">-k</span> <span class="hljs-number">1</span> <span class="hljs-literal">-r</span><br><br></code></pre></td></tr></table></figure><h5 id="查看指定镜像的详细信息"><a href="#查看指定镜像的详细信息" class="headerlink" title="查看指定镜像的详细信息"></a>查看指定镜像的详细信息</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker inspect redis<br></code></pre></td></tr></table></figure><h4 id="镜像导出"><a href="#镜像导出" class="headerlink" title="镜像导出"></a>镜像导出</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker save [<span class="hljs-type">OPTIONS</span>] IMAGE [<span class="hljs-type">IMAGE...</span>]<br>选项:<br><span class="hljs-literal">-o</span>, <span class="hljs-literal">--output</span> string <span class="hljs-built_in">Write</span> to a file, instead of STDOUT<br><span class="hljs-comment">#说明:</span><br>Docker save 使用IMAGE ID导出，在导入后的镜像没有REPOSITORY和TAG,显示为&lt;none&gt;<br><br>常见用法:<br><span class="hljs-comment">#导出为tar格式</span><br>docker save <span class="hljs-literal">-o</span> /path/file.tar IMAGE1 IMAGE2 ...<br>docker save IMAGE1 IMAGE2 ... &gt; /path/file.tar<br><span class="hljs-comment">#导出为压缩格式</span><br>docker save IMAGE1 IMAGE2 ... | gzip &gt; /path/file.tar.gz<br><br>docker save nginx:<span class="hljs-number">1.27</span>.<span class="hljs-number">4</span> <span class="hljs-literal">-o</span> /<span class="hljs-keyword">data</span>/myimages.tar<br></code></pre></td></tr></table></figure><h4 id="镜像导入"><a href="#镜像导入" class="headerlink" title="镜像导入"></a>镜像导入</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">利用docker load命令可以将镜像导出的打包或压缩文件再导入<br>注意：镜像导入只能支持单个镜像导入，不支持多个镜像导入<br>docker load [<span class="hljs-type">OPTIONS</span>]<br><span class="hljs-comment">#选项</span><br><span class="hljs-literal">-i</span>, <span class="hljs-literal">--input</span> string Read from tar archive file, instead of STDIN<br><span class="hljs-literal">-q</span>, <span class="hljs-literal">--quiet</span> Suppress the load output<br><br>常见用法:<br>docker load <span class="hljs-literal">-i</span> /path/file.tar<br>docker load &lt; /path/file.tar.gz<br><br>docker load <span class="hljs-literal">-i</span> /<span class="hljs-keyword">data</span>/myimages.tar<br></code></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker rmi 命令可以删除本地镜像<br>docker rmi [<span class="hljs-type">OPTIONS</span>] IMAGE [<span class="hljs-type">IMAGE...</span>]<br>docker image <span class="hljs-built_in">rm</span> [<span class="hljs-type">OPTIONS</span>] IMAGE [<span class="hljs-type">IMAGE...</span>]<br><span class="hljs-comment">#选项:</span><br><span class="hljs-operator">-f</span>, <span class="hljs-literal">--force</span> Force removal of the image  强制删除<br><span class="hljs-literal">--no-prune</span> <span class="hljs-keyword">Do</span> not delete untagged parents<br></code></pre></td></tr></table></figure><h4 id="镜像打标签"><a href="#镜像打标签" class="headerlink" title="镜像打标签"></a>镜像打标签</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker tag 可以给镜像打标签，类似于起别名<br>docker tag SOURCE_IMAGE[:<span class="hljs-type">TAG</span>] TARGET_IMAGE[:<span class="hljs-type">TAG</span>]<br><span class="hljs-comment">#TARGET_IMAGE[:TAG]格式一般形式</span><br>仓库主机FQDN或IP[:端口]/项目名(或用户名)/image名字:版本<br><br>docker tag redis redis:<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="容器操作基础命令"><a href="#容器操作基础命令" class="headerlink" title="容器操作基础命令"></a>容器操作基础命令</h3><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run 可以启动容器，进入到容器，并随机生成容器ID和名称<br>docker run [选项] [镜像名] [<span class="hljs-type">shell</span>命令] [参数]<br><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span>  查看启动过容器<br></code></pre></td></tr></table></figure><h4 id="启动容器的流程"><a href="#启动容器的流程" class="headerlink" title="启动容器的流程"></a>启动容器的流程</h4><p>!!!!![](..&#x2F;image&#x2F;企业级容器技术 Docker&#x2F;image-20250410143651598.png)</p><h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">从容器内退出,并停止容器<br><span class="hljs-keyword">exit</span><br><br>从容器内退出,且容器不停止<br>同时按三个键，ctrl+p+q<br></code></pre></td></tr></table></figure><h4 id="守护式-持续运行-容器"><a href="#守护式-持续运行-容器" class="headerlink" title="守护式(持续运行)容器"></a>守护式(持续运行)容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">能够长期运行<br>无需交互式会话<br>适合运行应用程序和服务<br><br>docker run <span class="hljs-literal">-d</span> nginx<br><br>docker run <span class="hljs-literal">-td</span> <span class="hljs-literal">--name</span> alpine5 alpine<br></code></pre></td></tr></table></figure><h4 id="开机自启动容器"><a href="#开机自启动容器" class="headerlink" title="开机自启动容器"></a>开机自启动容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><br>docker run <span class="hljs-literal">-d</span> <span class="hljs-literal">--name</span> nginx <span class="hljs-literal">--restart</span>=always <span class="hljs-literal">-p</span> <span class="hljs-number">80</span>:<span class="hljs-number">80</span> nginx<br><br><span class="hljs-literal">--restart</span>=always  自启动选项<br></code></pre></td></tr></table></figure><h4 id="–privileged-选项"><a href="#–privileged-选项" class="headerlink" title="–privileged 选项"></a>–privileged 选项</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">使用该参数，container内的root拥有真正的root权限。否则，container内的root只是外部的一个普通用户权限<br></code></pre></td></tr></table></figure><h3 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h3><h4 id="显示当前存在容器"><a href="#显示当前存在容器" class="headerlink" title="显示当前存在容器"></a>显示当前存在容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">ps</span> [<span class="hljs-type">OPTIONS</span>]<br>docker container <span class="hljs-built_in">ls</span> [<span class="hljs-type">OPTIONS</span>]<br><br><span class="hljs-comment">#显示运行的容器</span><br>docker <span class="hljs-built_in">ps</span><br><span class="hljs-comment">#显示全部容器，包括退出状态的容器</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><br><span class="hljs-comment">#只显示容器ID</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span><br><span class="hljs-comment">#显示容器大小</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-s</span><br><span class="hljs-comment">#显示最新创建的容器(停止的容器也能显示)</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-l</span><br><span class="hljs-comment">#查看运行状态的容器</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-operator">-f</span> <span class="hljs-string">&#x27;status=running&#x27;</span><br><span class="hljs-comment">#查看退出状态的容器</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-operator">-f</span> <span class="hljs-string">&#x27;status=exited&#x27;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">--format</span> 命令中，你可以使用不同的占位符来指定要在输出中显示的容器信息。<br><span class="hljs-comment">#以下是一些常用的占位符：</span><br>&#123;&#123;.ID&#125;&#125;：容器的ID。<br>&#123;&#123;.Image&#125;&#125;：容器使用的映像名称。<br>&#123;&#123;.Command&#125;&#125;：容器的启动命令。<br>&#123;&#123;.CreatedAt&#125;&#125;：容器的创建时间。<br>&#123;&#123;.RunningFor&#125;&#125;：容器运行的时间。<br>&#123;&#123;.Ports&#125;&#125;：容器的端口映射信息。<br>&#123;&#123;.Status&#125;&#125;：容器的状态。<br>&#123;&#123;.Size&#125;&#125;：容器的大小。<br>&#123;&#123;.Names&#125;&#125;：容器的名称。<br>&#123;&#123;.Label&#125;&#125;：容器的标签。<br><span class="hljs-comment">#示例</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">--format</span> <span class="hljs-string">&quot;&#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Status&#125;&#125;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker top CONTAINER [<span class="hljs-type">ps</span> <span class="hljs-type">OPTIONS</span>]<br><br><span class="hljs-comment">#示例</span><br>docker top <span class="hljs-number">2</span>bf0af811f0<br></code></pre></td></tr></table></figure><h4 id="查看容器资源使用情况"><a href="#查看容器资源使用情况" class="headerlink" title="查看容器资源使用情况"></a>查看容器资源使用情况</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker stats [<span class="hljs-type">OPTIONS</span>] [<span class="hljs-type">CONTAINER...</span>]<br><br><span class="hljs-comment">#示例</span><br>docker stats <span class="hljs-number">2</span>bf0af811f0ab95bf0d54<br></code></pre></td></tr></table></figure><h4 id="查看容器的详细信息"><a href="#查看容器的详细信息" class="headerlink" title="查看容器的详细信息"></a>查看容器的详细信息</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker inspect [<span class="hljs-type">OPTIONS</span>] NAME|ID [<span class="hljs-type">NAME</span>|<span class="hljs-type">ID...</span>]<br><br><span class="hljs-comment">#示例</span><br>docker inspect <span class="hljs-number">4</span>a0879b2e89b<br><span class="hljs-comment">#查看容器IP</span><br>docker inspect <span class="hljs-literal">--format</span> <span class="hljs-string">&quot;&#123;&#123;.NetworkSettings.Networks.bridge.IPAddress&#125;&#125;&quot;</span> elasticsearch<br></code></pre></td></tr></table></figure><h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker logs 可以查看容器中运行的进程在控制台的标准输出和标准错误，一般对应是日志信息<br>docker 日志是存放在宿主机的 /var/lib/docker/containers/&lt;container_id&gt;/&lt;container_id&gt;<span class="hljs-literal">-json</span>.log文件中<br><br>docker logs [<span class="hljs-type">OPTIONS</span>] CONTAINER<br><br>docker logs d5337c0d94c7f7316b<br><span class="hljs-comment">#显示时间</span><br>docker logs <span class="hljs-literal">--tail</span> <span class="hljs-number">0</span> <span class="hljs-literal">-t</span> d5337c0d94c7f7316b<br><span class="hljs-comment">#持续跟踪</span><br>docker logs <span class="hljs-operator">-f</span> d5337c0d94c7f7316b<br></code></pre></td></tr></table></figure><h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">rm</span> [<span class="hljs-type">OPTIONS</span>] CONTAINER [<span class="hljs-type">CONTAINER...</span>]<br>docker container <span class="hljs-built_in">rm</span> [<span class="hljs-type">OPTIONS</span>] CONTAINER [<span class="hljs-type">CONTAINER...</span>]<br><br><span class="hljs-comment">#删除所有容器</span><br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> `docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>`<br><span class="hljs-comment">#删除指定状态容器</span><br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> `docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-q</span> <span class="hljs-operator">-f</span> status=running`<br>docker <span class="hljs-built_in">rm</span> `docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-qf</span> status=exited`<br><span class="hljs-comment">#删除所有停止的容器</span><br>docker <span class="hljs-built_in">rm</span> `docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-qf</span> status=exited`<br></code></pre></td></tr></table></figure><h4 id="容器的启动和停止"><a href="#容器的启动和停止" class="headerlink" title="容器的启动和停止"></a>容器的启动和停止</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">start</span>|stop|restart|pause|unpause 容器ID<br><br>批量正常启动或关闭所有容器<br>docker <span class="hljs-built_in">start</span> <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>)<br>docker stop <span class="hljs-variable">$</span>(docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>)<br></code></pre></td></tr></table></figure><h4 id="给正在容器发信号"><a href="#给正在容器发信号" class="headerlink" title="给正在容器发信号"></a>给正在容器发信号</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker <span class="hljs-built_in">kill</span> 可以给容器发信号,默认号SIGKILL,即<span class="hljs-number">9</span>信号<br><br>docker <span class="hljs-built_in">kill</span> [<span class="hljs-type">OPTIONS</span>] CONTAINER [<span class="hljs-type">CONTAINER...</span>]<br><span class="hljs-comment">#选项:</span><br><span class="hljs-literal">-s</span>, <span class="hljs-literal">--signal</span> string Signal to send to the container (default <span class="hljs-string">&quot;KILL&quot;</span>)<br><br><span class="hljs-comment">#强制关闭所有运行中的容器</span><br>docker <span class="hljs-built_in">kill</span> `docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span> <span class="hljs-literal">-q</span>`<br></code></pre></td></tr></table></figure><h4 id="进入正在运行的容器"><a href="#进入正在运行的容器" class="headerlink" title="进入正在运行的容器"></a>进入正在运行的容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">容器只有正在运行状态时，才能进入<br>docker exec [<span class="hljs-type">OPTIONS</span>] CONTAINER COMMAND [<span class="hljs-type">ARG...</span>]<br><br><span class="hljs-comment">#常见用法</span><br>docker exec <span class="hljs-literal">-it</span> 容器ID sh|bash<br><br>docker exec <span class="hljs-number">544</span>d32be9707 <span class="hljs-built_in">ls</span><br>docker exec <span class="hljs-literal">-it</span> <span class="hljs-number">544</span>d32be9707 bas<br><br></code></pre></td></tr></table></figure><h4 id="暴露所有容器端口"><a href="#暴露所有容器端口" class="headerlink" title="暴露所有容器端口"></a>暴露所有容器端口</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">容器启动后,默认处于预定义的NAT网络中,所以外部网络的主机无法直接访问容器中网络服务<br>docker run <span class="hljs-literal">-P</span> 可以将事先容器预定义的所有端口映射宿主机的网卡的随机端口，默认从<span class="hljs-number">32768</span>开始<br>使用随机端口 时,当停止容器后再启动可能会导致端口发生变化<br><br><span class="hljs-literal">-P</span> , <span class="hljs-literal">--publish-all</span>= true | false默认为false<br><span class="hljs-comment">#示例:</span><br>docker run <span class="hljs-literal">-P</span> docker.io/nginx <span class="hljs-comment">#映射容器所有暴露端口至随机本地端口</span><br><br>docker port CONTAINER [<span class="hljs-type">PRIVATE_PORT</span>[/<span class="hljs-type">PROTO</span>]]<br></code></pre></td></tr></table></figure><h4 id="查看-docker-run-启动参数命令"><a href="#查看-docker-run-启动参数命令" class="headerlink" title="查看 docker run 启动参数命令"></a>查看 docker run 启动参数命令</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">忘记之前启动一个容器的启动命令是什么，现在需要找回来 docker run 的运行参数，可以使用 runlike工具实现<br><br>安装 runlike<br><span class="hljs-comment">#安装方式1: pip</span><br>apt install <span class="hljs-literal">-y</span> python3<span class="hljs-literal">-pip</span><br>pip3 install runlike<br><span class="hljs-comment">#安装方法2: by docker</span><br>alias runlike=<span class="hljs-string">&quot;docker run --rm -v /var/run/docker.sock:/var/run/docker.sock</span><br><span class="hljs-string">assaflavie/runlike&quot;</span><br></code></pre></td></tr></table></figure><h4 id="基于CRIU实现容器热迁移"><a href="#基于CRIU实现容器热迁移" class="headerlink" title="基于CRIU实现容器热迁移"></a>基于CRIU实现容器热迁移</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Docker容器热迁移是指在不停止或中断容器的情况下，将正在运行的Docker容器从一个主机迁移到另一个主机的过程。此过程确保了服务的高可用性，特别适用于负载均衡和故障转移场景。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>企业级监控系统 ZABBIX</title>
    <link href="/2025/06/09/%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%20ZABBIX/"/>
    <url>/2025/06/09/%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%20ZABBIX/</url>
    
    <content type="html"><![CDATA[<h1 id="企业级监控系统-ZABBIX"><a href="#企业级监控系统-ZABBIX" class="headerlink" title="企业级监控系统 ZABBIX"></a><strong>企业级监控系统</strong> <strong>ZABBIX</strong></h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs powershell">```<br><br><span class="hljs-comment">#### **数据流程**</span><br><br>!!!!![](../image/企业级监控系统 ZABBIX/image<span class="hljs-literal">-20250324192436841</span>.png)<br><br><br><br>```powershell<br><span class="hljs-number">1</span> 数据采集：根据业务的特性，采取多种方式，进行对一些针对性的数据进行采集<br><span class="hljs-number">2</span> 数据整理：对上报后的数据源进行收集、清晰、整理<br><span class="hljs-number">3</span> 实时分析：对某些重要的核心的业务数据，进行实时分析。<br><span class="hljs-number">4</span> 离线分析：对普通的数据、非紧急的业务数据进行存储，后续进行响应的分析。<br><span class="hljs-number">5</span> 结果输出：将实时分析和离线分析后的数据结果展现出来，供决策参考。<br><span class="hljs-number">6</span> 问题决策：根据当前业务情况，人工或者自动方式对输出的结构进行分析，并判定下一步的行动(警告或修复)，同时将其决策记录保存下来，以便为后序决策提供依据。<br>也就是说：采集、传输、存储、分析、警告这几部分是非常必要的。<br>核心目标:<br>监控的核心目标就是维持网站的可用性<br></code></pre></td></tr></table></figure><h4 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a><strong>监控方式</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">划分为基于Metrics（指标）监控、基于Logging（日志）、 基于Tracing（调用<br>链）监控的监控。<br><br></code></pre></td></tr></table></figure><h4 id="监控功能"><a href="#监控功能" class="headerlink" title="监控功能"></a>监控功能</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">在需要的时刻，提前预警即将出问题,避免故障发生。<br>实时监控系统和业务,当出问题之后，通过发出告警,提醒相关人员,快速可以找到问题的根源,从而及时处理问题。<br>可以实现网站,应用或者服务器的故障自愈, 保证高可用性。<br>以图形或易观察的方式呈现当前以及过往的状态,便于分析和预测系统发展趋势。<br></code></pre></td></tr></table></figure><h4 id="监控方法"><a href="#监控方法" class="headerlink" title="监控方法"></a>监控方法</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">使用率较高的有四种:<br>软件层面：<br> agent: 专用的软件的一种应用机制。<br> ssh: 系统常见的一种应用通信机制，但是并非所有。<br> SNMP: 简单网络管理协议(Simple Network Management Protocol),是工作在各种网络设备中的<br>一种机制。<br>硬件层面：<br> IPMI: 智慧平台管理接口(Intelligent Platform Management Interface)是一种工业标准用<br>于采集硬件设备的各种物理健康状态数据，如温度、电压、风扇工作状态、电源状态等。<br><br>实现方法:<br>主要有系统命令,开源软件,监控平台<br><br></code></pre></td></tr></table></figure><h4 id="开源软件"><a href="#开源软件" class="headerlink" title="开源软件"></a>开源软件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Cacti:<br>Cacti是基于LAMP平台展现的网络流量监测及分析工具,通过SNMP技术或自定义脚本从目标设备/主机获取监控指标信息. 其次还可以进行数据存储，调用模板将数据存到数据库，使用rrdtool存储和更新数据，通过rrdtoo1绘制结果图形,最后进行数据展现，通过web方式将监控结果呈现出来，常用于在数据中心监控网络设备,比如交换机和路由器。<br> cacti是很老的一款监控工具，其实说它是一款流量监控工具更合适，对流量监控比较精准，但缺点很多，出图不好看，不支持分布式，也没有告警功能，所以当前使用的用户越来越少。缺点:告警不及时。<br><br>Nagios:<br>  Nagios是一款开源的免费监控工具，可以有效地监控Windows、Linux和Unix的主机状态，交换机路由器等网络设置，打印机等。在系统或服务状态异常时发出邮件或短信报警第一时间通知网站运维人员，在状态恢复后发出正常的邮件或短信通知。<br>  nagios主要的特征是监控告警，最强大的就是告警功能，可支持多种告警方式，但缺点是没有强大的数据收集机制，并且数据出图也很简陋，当监控的主机越来越多时，添加主机也非常麻烦，配置文件都是基于文本配置的，不支持web方式管理和配置，这样很容易出错，不易维护。<br>  分层告警机制及自定义监控相对薄弱。监控主机数量有限，承载能力较低<br><br><span class="hljs-built_in">open-falcon</span>:<br><span class="hljs-built_in">open-falcon</span>(猎鹰)是一款用golang和python写的监控系统，由小米公司启动了这个项目相对zabbix在性能、扩展性、和用户的使用效率方面，都有较大优势。<br> 发布时间较短，不支持很多基础的服务监控插件,如Tomcat、 apache等。<br> 功能不完善,更新较缓慢，无专门运维支撑，社区运营有欠缺 <span class="hljs-literal">--</span> 目前很长时间不维护了。<br><br>夜莺:<br> 夜莺（Nightingale）是滴滴基础平台联合滴滴云研发和开源的企业级监控解决方案。旨在满足云原生时代企业级的监控需求。Nightingale 在<span class="hljs-built_in">Open-Falcon</span> 的基础上，结合滴滴的最佳实践，在性能、可维护性、易用性方面做了大量的改进。<br> Nightingale 在产品完成度、系统高可用、以及用户体验方面，达到了企业级的要求，可满足不同规模用户的场景，小到几台机器，大到数十万都可以完美支撑。兼顾云原生和裸金属，支持应用监控和系统监控，插件机制灵活，插件丰富完善，具有高度的灵活性和可扩展性。<br> Nightingale 作为集团统一的监控解决方案，支撑了滴滴内部数十亿监控指标，覆盖了从系统、容器、到应用等各层面的监控需求，周活跃用户数千。五年磨一剑，取之开源，回馈开源夜莺监控的核心开发团队，也是<span class="hljs-built_in">Open-Falcon</span>项目原核心研发人员。当前社区比较活跃,升级较频繁<br><br></code></pre></td></tr></table></figure><h4 id="Zabbix"><a href="#Zabbix" class="headerlink" title="Zabbix"></a>Zabbix</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>判断与循环</title>
    <link href="/2025/06/09/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/"/>
    <url>/2025/06/09/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="判断与循环"><a href="#判断与循环" class="headerlink" title="判断与循环"></a>判断与循环</h1><h2 id="流程控制语句的分类"><a href="#流程控制语句的分类" class="headerlink" title="流程控制语句的分类"></a>流程控制语句的分类</h2><p>①顺序结构②判断和选择结构 (if,Switch)③循环结构(for,while,do,while)</p><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>没有特定的语法结构,都是按先后顺序依次执行,大多数代码都是这样的.</p><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_dbJujtcie7.png"></p><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_zT9wjxqICB.png"></p><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><h3 id="if语句格式"><a href="#if语句格式" class="headerlink" title="if语句格式:"></a>if语句格式:</h3><p>类型①if (关系表达式) {</p><p>&#x20;    语句体;</p><p>}</p><p>执行流程:先计算表达式的值,如果成立就执行语句体,否则不执行.最后继续执行之后的代码</p><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_N33DWHLBgM.png"></p><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_GjHXLaVb8L.png"></p><p>注意事项:</p><p>如果要对一个布尔变量进行判断,不要直接写&#x3D;&#x3D;,直接把变量写在小括号里.</p><p>类型② if (关系表达式) {</p><p>语句体1; &#x20;</p><p>} else {</p><p>语句体2; &#x20;</p><p>}</p><p>执行流程:先计算表达式的值,如果成立就执行语句体1,否则执行语句体2.最后继续执行之后的代码</p><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_vQyawDAe0M.png"></p><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_WRDKl94CZI.png"></p><p>类型③</p><p>if (关系表达式1) {</p><p>语句体1; &#x20;</p><p>} else if (关系表达式2) {</p><p>语句体2; &#x20;</p><p>}&#x20;</p><p>…</p><p>else {</p><p>语句体n+1;</p><p>}</p><p>执行流程:先计算表达式的值,如果成立就执行语句体1,如果不成立就关系表达式2, 接着如果成立就执行语句体2,如果不成立就关系表达式3,一直循环.最后继续执行之后的代码</p><h2 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">switch (表达式) &#123;<br>  case 1:<br>    语句体1;<br>    break;<br>  case 2:<br>    语句体2;<br>    break;<br>  ...<br>  default:<br>    语句体n+1;<br>    break;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行流程:先计算表达式的值,然后和case依次比较,如果有对应的值就会执行相应的语句,如果在执行过程中遇到break就会结束.最后如果都不匹配就会执行default语句然后结束程序.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        Scanner sc = new Scanner(System.in);<br>        System.out.println(&quot;请输入一个整数表示星期&quot;);<br>        int week = sc.nextInt();<br>        switch (week)&#123;<br>            case 1:<br>                System.out.println(&quot;跑步&quot;);<br>                break;<br>            case 2:<br>                System.out.println(&quot;游泳&quot;);<br>                break;<br>            case 3:<br>                System.out.println(&quot;慢走&quot;);<br>                break;<br>            case 4:<br>                System.out.println(&quot;动感单车&quot;);<br>                break;<br>            case 5:<br>                System.out.println(&quot;拳击&quot;);<br>                break;<br>            case 6:<br>                System.out.println(&quot;爬山&quot;);<br>                break;<br>            case 7:<br>                System.out.println(&quot;好好吃一顿&quot;);<br>                break;<br>            default:<br>                System.out.println(&quot;输入错误，没有这个星期&quot;);<br>                break;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_CVU6pNYLD5.png"></p><p>注:1.default可以放在任意位置也可以省略不写.</p><p>不写break会引发case穿透现象</p><h3 id="Switch和if的使用场景"><a href="#Switch和if的使用场景" class="headerlink" title="Switch和if的使用场景"></a>Switch和if的使用场景</h3><p>当我们需要对一个范围进行判断的时候，用if的第三种格式</p><p>当我们把有限个数据列举出来，选择其中一个执行的时候，用switch语句</p><p>比如：</p><p>①小明的考试成绩，如果用switch，那么需要写100个case，太麻烦了，所以用if简单。</p><p>②如果是星期，月份，客服电话中0~9的功能选择就可以用switch</p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="for的循环结构"><a href="#for的循环结构" class="headerlink" title="for的循环结构"></a>for的循环结构</h3><p>在满足循环条件的情况下,反复执行一段代码,当反复执行这一段代码时应在适当时刻将判断条件改为false,将此循环结束,否则循环会一直下去成为死循环.</p><p>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">for (初始化语句;条件判断语句;条件控制语句) &#123;<br>  循环体语句;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>格式解释：</strong></p><p>初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样</p><p>条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去</p><p>条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去</p><p>循环体语句： 用于表示循环反复执行的内容，简单说就是循环    反复执行的事情</p><p>执行流程:先执行初始化语句,执行条件判断语句，看其结果是true还是false,如果是false，循环结束,如果是true，继续执行,执行循环体语句,执行条件控制语句,再执行条件判断语句…..一直循环.</p><p>for循环书写的技巧</p><p>①确定循环的条件</p><p>②确定循环的结束条件</p><p>③确定循环需要重复执行的代码</p><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_s0Mma-CFZT.png"></p><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_Jz-sku8HHw.png"></p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">初始化语句;<br>while(条件判断语句)&#123;<br>  循环体;<br>  条件控制语句;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_WcUPxkQKJL.png"></p><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_CxoGOxBPnb.png"></p><h3 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h3><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">初始化语句;<br>do&#123;<br>    循环体;<br>    条件控制语句;<br>&#125;while(条件判断语句);<br></code></pre></td></tr></table></figure><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_MOv-gx8M7T.png"></p><p><img src="/../image/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/image_IMcEzHiPY3.png"></p><p>三种格式的区别:</p><ul><li>for和while循环，是先判断，再执行。</li><li>do…while是先执行，再判断。</li><li>当知道循环次数或者循环范围的时候，用for循环。</li><li>当不知道循环次数，也不知道循环范围，但是知道循环的结束条件时，用while循环。</li></ul>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>企业级调度器LVS</title>
    <link href="/2025/06/09/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/"/>
    <url>/2025/06/09/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/</url>
    
    <content type="html"><![CDATA[<h1 id="企业级调度器LVS"><a href="#企业级调度器LVS" class="headerlink" title="企业级调度器LVS"></a>企业级调度器LVS</h1><h2 id="集群解决方案"><a href="#集群解决方案" class="headerlink" title="集群解决方案"></a>集群解决方案</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">三轴扩展<br>x轴扩展:<br>也称水平扩展(Scale Out),通过复制或者克隆的方式，实现基于当前环境加倍的效果，能够把几乎任何系统或者业务环境扩展大无限的水平，是企业发展过程中通用的一种策略，尤其是项目后期。<br>简单来说就是，一个不够多个来凑 或者 <span class="hljs-string">&quot;增加机器&quot;</span>。<br>y轴扩展：<br>也称垂直扩展(Scale Up),通过配置升级或者资源增强的方式，实现基于当前环境加倍的效果，这种方式的扩展受资金承受能力和技术发展程度的限制，企业发展前期常见的方法，中后期限制较多。<br>简单来说就是，小个打不过换个高的来 或者 <span class="hljs-string">&quot;升级机器&quot;</span>。<br>z轴扩展:<br>也称拆分扩展，通过业务梳理和资源整合的方式，将业务环境中类似的或者共用的功能拆分并整合在一起，形成特有的业务属性，然后基于业务属性的情况，结合X轴和Y轴的方法满足业务需求，而且实现资源高效利用。<br>简单来说就是，化整为零各个击破 或者 <span class="hljs-string">&quot;独立部署&quot;</span>。<br></code></pre></td></tr></table></figure><h4 id="集群类型"><a href="#集群类型" class="headerlink" title="集群类型"></a>集群类型</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">三种分类：<br>高扩展(LB)：单个主机负载不足的时候，采取增加主机的方式来满足负载需求的解决方案。<br>高可用(HA)：集群中的某主机失效时候，避免业务中断，我们将其任务转交给其他主机的解决方案。<br>高性能(HPA)：通过某些技术，实现同样资源来承受更多用户请求负载的解决方案。<br><br></code></pre></td></tr></table></figure><h5 id="单点故障"><a href="#单点故障" class="headerlink" title="单点故障"></a>单点故障</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">对于任何一个集群来说，满足业务功能需求是一个方面，但是我们要知道，所有的解决方案都是为了实现一个目的：业务项目的稳定。当我们唯一的服务器崩了怎么办，一旦用户访问的入口被关闭了，再多的投入也是浪费。那么像这种情况，我们一般称之为<span class="hljs-string">&quot;单点故障&quot;</span>(Single Point Of Failure)。<br><br><br><br></code></pre></td></tr></table></figure><h5 id="高可用集群-High-Availability-Cluster-，也称”主机冗余”集群"><a href="#高可用集群-High-Availability-Cluster-，也称”主机冗余”集群" class="headerlink" title="高可用集群(High Availability Cluster)，也称”主机冗余”集群"></a>高可用集群(High Availability Cluster)，也称”主机冗余”集群</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">它是指将 核心业务使用多台(一般是<span class="hljs-number">2</span>台)主机共同工作，支撑并保障核心业务的正常运行，尤其是业务的对外不间断的对外提供服务。核心特点就是<span class="hljs-string">&quot;冗余&quot;</span>.<br> 它存在的目的就是为了解决单点故障(Single Point of Failure)问题的。<br></code></pre></td></tr></table></figure><p><strong>站点可用性指标</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">对于网站可用性来说，它主要有这么一个指标来评判：<br>A = MTBF/(MTBF+MTTR)<br> MTBF(Mean Time Between Failure),即平均故障间隔时间，表示产品多长时间出现一次问题。 <br> MTTR(Mean Time To Restoration)，即平均恢复时间,表示产品从故障状态到稳定状态的维修花费时间。  <br></code></pre></td></tr></table></figure><h2 id="集群的实现细节"><a href="#集群的实现细节" class="headerlink" title="集群的实现细节"></a>集群的实现细节</h2><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">分布式计算机系统，是指由多台分散的计算机，经互连网络的联接而形成的系统，系统的处理和控制功能分布在各个计算机上<br><br>分布式应用：<br>  服务按照功能拆分，使用微服务器构搭建的系统<br>分布式存储：<br>  将数据分散存储到多个存储服务器上，并将这些分散的存储资源构成一个虚拟的存储设备，包括分布式文件系统、分布式块存储和分布式对象存储外，还包括分布式数据库和分布式缓存等，常用的分布式存储技术包括 HDFS，Ceph等<br>分布式计算：<br>  一种科学的计算方法，能把需要进行大量计算的工程数据分割成小块，由多台计算机分别计算，然后再把所有的结果进行合并，得出统一的结论，常用的分布式框架包括 Hadoop，Spark 等<br><br><br></code></pre></td></tr></table></figure><h4 id="集群和分布式的区别"><a href="#集群和分布式的区别" class="headerlink" title="集群和分布式的区别"></a>集群和分布式的区别</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">集群和分布式 <span class="hljs-literal">--</span> 集群是同一任务的多副本，而分布式是拆分任务。<br>集群：<br>  应该是指多台服务器组合在一起，共同完成某个任务，比如网站访问量大，单台服务器扛不住，用集群来分担负载。<br>  集群的优点是提高可用性和扩展性，但资源利用率可能不高，因为每台机器都要处理完整的任务。<br>  生活示例：连锁奶茶店，每家店都能做相同的产品，顾客可去任意一家购买（负载均衡），一家店关门不影响其他店（高可用）。<br><br>分布式：<br>  更侧重于把一个任务拆分成多个部分，在不同机器上处理，然后合并结果。<br>  可以更高效地利用资源，处理更大的任务，但复杂度高，需要处理节点间的通信、数据一致性等问题。<br>  生活示例：哪吒<span class="hljs-number">2</span>的制作采用了高度协作的工业化模式，将不同功能模块拆解后分包给上百家专业公司，涵盖动画制作、特效合成、数字资产、美术设计、分镜设计等多个环节，所有分包内容需经导演饺子审核，最终由光线传媒终审。<br></code></pre></td></tr></table></figure><h4 id="集群和分布式的特点"><a href="#集群和分布式的特点" class="headerlink" title="集群和分布式的特点"></a>集群和分布式的特点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">集群的主要特点：<br>  多台机器做同样的事情，通过负载均衡来分配请求，提高可用性和性能。比如Web服务器集群，每台服务器都运行相同的应用，用户请求被分发到不同的服务器上。这样如果一台挂了，其他的还能继续服务，提高了可用性。<br>分布式系统的主要特点：<br>  不同的节点处理不同的任务，比如数据库分片，每个节点存储部分数据，或者像MapReduce那样处理大数据，拆分任务到各个节点处理。<br></code></pre></td></tr></table></figure><h5 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h5><table><thead><tr><th>维度</th><th>集群</th><th>分布式</th></tr></thead><tbody><tr><td>任务类型</td><td>相同任务多副本运行</td><td>任务被拆解，不同节点协作完成</td></tr><tr><td>节点角色</td><td>同构（所有节点功能相同）</td><td>异构（节点可能承担不同职责）</td></tr><tr><td>核心目标</td><td>高可用、负载均衡</td><td>高效处理大规模任务</td></tr><tr><td>典型技术</td><td>Kubernetes、Redis Cluster</td><td>Hadoop、微服务、区块链</td></tr></tbody></table><h4 id="集群和分布式的实现目的"><a href="#集群和分布式的实现目的" class="headerlink" title="集群和分布式的实现目的"></a>集群和分布式的实现目的</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">分布式<br>  主要目的是解决大规模问题，通过将任务分解到多个节点上并行处理，提高系统的处理能力和可扩展性，能够处理单个计算机无法处理的大型任务，同时也提高了系统的可靠性和容错能力，因为即使某个节点出现故障，其他节点仍然可以继续工作。<br><br>集群<br>  主要目的是提供高可用性、高性能和可扩展性。通过多个节点的冗余和负载均衡，确保系统在面对高并发请求或硬件故障时能够持续稳定地运行，提高系统的性能和处理能力，以满足不断增长的业务需求。<br></code></pre></td></tr></table></figure><h4 id="架构复杂度"><a href="#架构复杂度" class="headerlink" title="架构复杂度"></a>架构复杂度</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">分布式<br>  架构相对复杂，因为需要考虑任务的分解、子任务的协调、数据的一致性、网络通信等多个方面的问题。设计和实现一个分布式系统需要对分布式算法、网络编程、数据一致性算法等有深入的理解和掌握。<br><br>集群<br>  架构相对简单一些，主要关注节点的管理、负载均衡和故障转移等方面。通常可以通过一些成熟的集群管理软件来实现集群的搭建和管理，相对来说实现难度较低。<br></code></pre></td></tr></table></figure><h4 id="集群的实现方案"><a href="#集群的实现方案" class="headerlink" title="集群的实现方案"></a>集群的实现方案</h4><h5 id="按实现方式分类"><a href="#按实现方式分类" class="headerlink" title="按实现方式分类"></a><strong>按实现方式分类</strong></h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">从硬件和软件两个角度<br>硬件方案<br>F5负载均衡设备，价格昂贵，实现功能极其多，大中型公司的核心业务、金融公司、银行采用比较多。Citrix Netscaler、A10等<br><br>软件方案<br>LVS 可以实现二~四层的负载均衡效果<br>Nginx 可以实现四~七等的负载均衡效果<br>Haproxy 可以实现四~七层的负载均衡效果<br>阿里云  可以实现四~七层的负载均衡效果<br>                阿里云ALB（七层负载均衡），阿里云NLB（四层负载均衡），阿里云 CLB（传统型负载均衡）<br>                https://help.aliyun.com/zh/slb/<br>AWS 可以实现四~七层的负载均衡效果<br>                ALB（七层负载均衡），AWS NLB（四层负载均衡），AWS CLB（传统型负载均衡）<br>                https://aws.amazon.com/cn/elasticloadbalancing/<br></code></pre></td></tr></table></figure><h5 id="工作的协议层次分类"><a href="#工作的协议层次分类" class="headerlink" title="工作的协议层次分类"></a><strong>工作的协议层次分类</strong></h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">工作在传输层（四层）的负载均衡：<br>传输层负载均衡基于四层通用协议（TCP/UDP）进行调度<br> LVS<br> nginx（基于stream划模块）<br> haproxy（基于tcp模式）<br> 阿里云 NLB和CLB<br> AWS NLB和CLB<br> <br>工作在应用层（七层）的负载均衡：<br>应用层负载均衡通常基于应用层特定协议进行调度，又被称为 proxy server<br> 基于 http 协议的负载均衡：nginx，httpd，haproxy（mode http）, ......<br> 基于 fastcgi 协议的负载均衡：nginx，httpd，......<br> 基于 mysql 协议的负载均衡：mysql<span class="hljs-literal">-proxy</span>，mycat，......<br></code></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h4 id="五表五链"><a href="#五表五链" class="headerlink" title="五表五链"></a>五表五链</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell">iptables防火墙规则很多，不好管理，它用五个表来划分管理范围，以便对数据包进行分组管理，具体如下：<br><br>security: 对数据包的mac信息进行过滤<br><span class="hljs-keyword">filter</span>：对主机接收的数据包实现过滤功能，它是iptables的默认规则。<br>nat: 对主机接收的数据包实现转换功能，端口映射，地址映射等,使用场景比较多表。<br>mangle: 用于对特定数据包的修改，报文拆开，修改，封装表<br>raw: 特殊场景下实现的自定义规则<br><br>  security表的主要作用是依据 SELinux（Security<span class="hljs-literal">-Enhanced</span> Linux）或其他基于 Linux 内核的强制访问控制（MAC）机制，对数据包进行过滤和标记。它可以根据安全上下文来决定是否允许数据包通过，从而提供比传统自主访问控制（DAC）更细粒度、更严格的访问控制，常用于增强系统安全性，防止恶意软件或非法用户对系统资源的非法访问。<br> 注意：此处的MAC和网卡的 MAC 地址是两个完全不同的概念，千万不要混淆。<br> <br>对于iptabls来说，<span class="hljs-number">5</span>个链：PREROUTING,INPUT,FORWARD,OUTPUT,POSTROUTING。<br>PREROUTING:数据包进入路由表之前 INPUT:通过路由表后目的地为本机<br>FORWARD:通过路由表后，目的地不为本机 OUTPUT:由本机产生，向外转发<br>POSTROUTIONG:发送到网卡接口之前<br></code></pre></td></tr></table></figure><p><img src="/../image/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/image-20250319095854790.png" alt="image-20250319095854790"></p><h4 id="SNAT-和-DNAT"><a href="#SNAT-和-DNAT" class="headerlink" title="SNAT 和 DNAT"></a><strong>SNAT</strong> <strong>和</strong> <strong>DNAT</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">```<br><br>网络数据包，我们主要是根据**请求报文**中的数据地址转换划分为 SNAT 和 DNAT，而不是响应数据包。<br><br>![<span class="hljs-type">image</span>-<span class="hljs-number">20250319100630846</span>](../image/企业级调度器LVS/image<span class="hljs-literal">-20250319100630846</span>.png)<br><br>```powershell<br>数据包在网络上上主机间传输的时候，它是这样子的结构形式来传输的。我们这里暂时只关心IP头部，对于一个互联网上的数据包来说，他的ip头部里面包含了，数据包的来源地址以及数据包的目标地址。<br></code></pre></td></tr></table></figure><p><img src="/../image/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/image-20250319101114064.png" alt="image-20250319101114064"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SNAT:源地址转换，应用场景：内网访问外网<br>源                  目标<br>SRC_IP:SRC_PORT <span class="hljs-literal">--</span>&gt; DEST_IP:DEST:PORT<br>外部公网IP：Port <span class="hljs-literal">--</span>&gt; DEST_IP:DEST:PORT <br><span class="hljs-comment"># 出去的数据包：经过NAT设备时候，原地址转换成公网IP地址，外部公网IP地址之间是存在路由的，可以自</span><br>动检索到。<br>源                    目标<br>DEST_IP:DEST:PORT <span class="hljs-literal">--</span>&gt; 外部公网IP：Port<br>DEST_IP:DEST:PORT <span class="hljs-literal">--</span>&gt; SRC_IP:SRC_PORT<br><br>DNAT:目标地址转换，应用场景：外网访问内网<br>源                  目标<br>SRC_IP:SRC_PORT <span class="hljs-literal">--</span>&gt; DEST_IP:DEST:PORT（公有地址）<br>SRC_IP:SRC_PORT <span class="hljs-literal">--</span>&gt; 私有DEST_IP:DEST:PORT（私有地址）<br><span class="hljs-comment"># 进来的数据包：经过NAT设备的时候，公网IP地址转换成私网IP地址，私网地址在同一个网段，线路可达。</span><br>私有DEST_IP:DEST:PORT（私有地址） <span class="hljs-literal">--</span>&gt; SRC_IP:SRC_PORT<br>DEST_IP:DEST:PORT（公有地址） <span class="hljs-literal">--</span>&gt; SRC_IP:SRC_PORT<br></code></pre></td></tr></table></figure><h2 id="LVS基础"><a href="#LVS基础" class="headerlink" title="LVS基础"></a>LVS基础</h2><h4 id="LVS-Linux-Virtual-Server"><a href="#LVS-Linux-Virtual-Server" class="headerlink" title="LVS(Linux Virtual Server)"></a>LVS(Linux Virtual Server)</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">  LVS 基于IP负载均衡|内容请求分发等技术，整合了一些特有的理念和思想后的一套解决方案。普通的linux主机可以基于lvs提供的负载均衡技术，实现一个高扩展的linux的服务器集群。<br></code></pre></td></tr></table></figure><h4 id="一般来说，LVS集群有三部分组成"><a href="#一般来说，LVS集群有三部分组成" class="headerlink" title="一般来说，LVS集群有三部分组成"></a>一般来说，LVS集群有三部分组成</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">负载调度器(load balancer)，负责将客户的请求调度到后端主机上。<br>服务器池(server pool)，真正响应用户请求的后端主机。<br>共享存储(shared storage)，存储配置、元数据等相关信息<br><br>共享存储并不属于负载调度器和服务器池中的任何一部分主机，它是独立于这两者之外的一个组件，但 与它们存在紧密的联系。<br>在 LVS 集群中，共享存储通常是一个单独的存储设备或存储系统，可以是网络附加存储（NAS）、存储区域网络（SAN）等。其作用是为负载调度器和服务器池中的所有主机提供共享的配置文件、元数据以及可能需要共享的数据等，以确保整个集群能够协调一致地工作。例如，服务器池中的后端主机可能需要从共享存储中读取相同的配置信息来正确处理用户请求，负载调度器也可能会参考共享存储中的某些元数据来进行请求调度决策。<br><br></code></pre></td></tr></table></figure><h5 id="LVS集群提供了四种主要的资源调度功能："><a href="#LVS集群提供了四种主要的资源调度功能：" class="headerlink" title="LVS集群提供了四种主要的资源调度功能："></a>LVS集群提供了四种主要的资源调度功能：</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">NAT 修改请求数据包的目标ip地址，实现请求转发功能 <br>Tunneling 给请求数据包外部增加新的ip首部，实现请求转发功能<br>DirectRouting 修改请求数据包的mac地址，实现请求转发功能<br>FULLNAT 结合SYNPROXY技术，修改数据包的源ip地址和目标ip地址，实现请求转发功能<br></code></pre></td></tr></table></figure><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">LVS 是根据监听到的前端请求报文中的目标 IP 和目标协议及端口号，将该请求转发到后台某台 RS 服务器上，由 RS 服务器完成对前端请求的响应，具体的监听规则及调度策略由使用者自行配置。<br>    LVS 是内核中的功能，工作在 PRE_ROUTING链 和 INPUT链 中间的位置上，截取发往 INPUT 链的请求与配置好的 LVS 监听及调度规则进行对比，如果命中，则会触发 LVS 调度，从而转发该请求<br></code></pre></td></tr></table></figure><p><img src="/../image/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/image-20250319105248228.png" alt="image-20250319105248228"></p><h4 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a><strong>常见术语</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs powershell">物理术语 - 用于描述主机的常见术语<br>DS：Director Server。<br>    指的是LVS集群中的负责调度(Dispatcher)或者负载均衡(Load Balancer)的主机，即部署LVS的主机。<br>    也称VS(Virtual Server)。<br>RS：Real Server。<br>    指的是这正相应用户主机的后端服务器主机。<br>    也称BS(Backend Server)。<br><br>逻辑术语 - 用户描述逻辑关系的常见术语<br>VIP：Virtual Server IP<br>    LVS主机上用于向外部用户提供服务的ip地址，作为用户请求的目标的IP地址。<br>    它是一个在物理主机上没有物理网卡的ip地址，一般用于LVS主机的外网ip。<br>DIP：Director Server IP<br>    LVS主机上和后端提供真正服务的主机通信的IP地址。<br>    它是一个独立的物理网卡上的地址，一般用于LVS主机的内网ip。<br>RIP：Real Server IP<br> 在LVS调度主机后端，真正响应用户请求的主机IP地址。<br> <br>CIP：Client IP<br>    发起请求的用户客户端IP地址。<br>    一般都是外网ip地址。<br></code></pre></td></tr></table></figure><h5 id="这四者之间的访问关系如下：CIP-VIP-DIP-RIP"><a href="#这四者之间的访问关系如下：CIP-VIP-DIP-RIP" class="headerlink" title="这四者之间的访问关系如下：CIP &lt;–&gt; VIP &#x3D;&#x3D; DIP &lt;–&gt; RIP"></a>这四者之间的访问关系如下：CIP &lt;–&gt; VIP &#x3D;&#x3D; DIP &lt;–&gt; RIP</h5><p><img src="/../image/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/image-20250319105609725.png"></p><h5 id="我们在课程中实践的时候，往往在LVS上配置两个网卡，一个对外，一个对内"><a href="#我们在课程中实践的时候，往往在LVS上配置两个网卡，一个对外，一个对内" class="headerlink" title="我们在课程中实践的时候，往往在LVS上配置两个网卡，一个对外，一个对内"></a>我们在课程中实践的时候，往往在LVS上配置两个网卡，一个对外，一个对内</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">为了达到不同网段的ip地址能够达到正常的通信，我们需要开启linux服务的ip转发功能<br>    方法一：在 /etc/sysctl.conf中开启功能<br>    net.ipv4.ip_forward = <span class="hljs-number">1</span><br>    方法二：直接修改ip_forward文件<br>    <span class="hljs-built_in">echo</span> <span class="hljs-number">1</span> &gt; /proc/sys/net/ipv4/ip_forward<br>注意：<br>    <span class="hljs-number">0</span> 代表禁用，<span class="hljs-number">1</span>代表开启。<br></code></pre></td></tr></table></figure><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><h5 id="用户访问流程"><a href="#用户访问流程" class="headerlink" title="用户访问流程"></a>用户访问流程</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">结合我们对LVS的集群结构与常见术语，我们可以简单的梳理一下，在LVS集群环境中，用户请求的处理流程。<br><span class="hljs-number">1</span> 用户在客户端发起访问服务的请求<br><span class="hljs-number">2</span> 经过层层的dns解析原理，获取服务的提供ip地址<span class="hljs-literal">--VIP</span><br><span class="hljs-number">3</span> 客户端向VIP所在的LVS主机(VS)发起服务请求<br><span class="hljs-number">4</span> LVS主机(VS)接收到用户请求，根据自身的配置，将用户请求转交到后端的某主机(RS)<br><span class="hljs-number">5</span> 用户请求经LVS的DIP网卡，进入到公司内网环境<br><span class="hljs-number">6</span> 根据数据包的结构，找到真正提供服务的后端主机(RS)<br><span class="hljs-number">7</span> 公司内部的后端主机，处理用户请求后，采用某种方式返回给客户端<br></code></pre></td></tr></table></figure><p><img src="/../Blog/blog/source/image/image-20250319110814720.png" alt="image-20250319110814720"></p><h4 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a><strong>软件环境</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">LVS软件 由<span class="hljs-number">2</span>部分程序组成：ipvs 和 ipvsadm。<br>ipvs(ip virtual server)<br>  LVS提供了一个支持多种IP负载均衡技术的IP虚拟服务器软件IPVS，这段代码工作在lvs主机的内核空间(netfilter的INPUT),它用于截获用户请求数据包，根据内部的调度策略实现数据包转交的功能。<br>    我们只需要在内核中开启此模块的应用即可<br><br>ipvsadm<br>ipvsadm是工作在用户空间的命令行工具，负责为ipvs的资源调度编写转交规则：<br>    <span class="hljs-number">1</span> 定义lvs集群的名称<br>    <span class="hljs-number">2</span> 定义该集群中处于后端提供真实服务的主机列表(Real Server)<br><br></code></pre></td></tr></table></figure><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Ubuntu环境检测内核模块<br>查看内核模块关于ipvs的信息<br>[<span class="hljs-type">root</span>@<span class="hljs-type">bogon</span> <span class="hljs-type">boot</span>]<span class="hljs-variable">$</span> grep <span class="hljs-literal">-i</span> <span class="hljs-literal">-C</span> <span class="hljs-number">2</span> ipvs /boot/config<span class="hljs-literal">-5</span>.<span class="hljs-number">15.0</span><span class="hljs-literal">-133-generic</span><br>查看模块信息<br>[<span class="hljs-type">root</span>@<span class="hljs-type">bogon</span> <span class="hljs-type">boot</span>]<span class="hljs-variable">$</span> modinfo ip_vs<br><br>Rocky环境检测内核模块<br>查看内核模块关于ipvs的信息<br>[<span class="hljs-type">root</span>@<span class="hljs-type">bogon</span> <span class="hljs-type">boot</span>]<span class="hljs-variable">$</span> grep <span class="hljs-literal">-i</span> <span class="hljs-literal">-C</span> <span class="hljs-number">2</span> ipvs /boot/config<span class="hljs-literal">-5</span>.<span class="hljs-number">14.0</span><span class="hljs-literal">-427</span>.<span class="hljs-number">13.1</span>.el9_4.x86_64<br>查看模块信息<br>[<span class="hljs-type">root</span>@<span class="hljs-type">bogon</span> <span class="hljs-type">boot</span>]<span class="hljs-variable">$</span> modinfo ip_vs<br><br></code></pre></td></tr></table></figure><h4 id="软件部署"><a href="#软件部署" class="headerlink" title="软件部署"></a>软件部署</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Ubuntu系统<br>[<span class="hljs-type">root</span>@<span class="hljs-type">bogon</span> <span class="hljs-type">boot</span>]<span class="hljs-variable">$</span> apt install ipvsadm<br>Rocky系统<br>[<span class="hljs-type">root</span>@<span class="hljs-type">bogon</span> ~]<span class="hljs-variable">$</span> yum install ipvsadm <span class="hljs-literal">-y</span> <br></code></pre></td></tr></table></figure><h4 id="集群状态查看"><a href="#集群状态查看" class="headerlink" title="集群状态查看"></a>集群状态查看</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">命令格式：ipvsadm <span class="hljs-literal">-Ln</span><br>格式详解：<br>    <span class="hljs-literal">-L</span> 显示当前的服务或者目标主机信息<br>    <span class="hljs-literal">-n</span> 地址和端口的数字输出<br>    <span class="hljs-literal">--stats</span>                             <span class="hljs-comment"># 输出统计信息</span><br>    <span class="hljs-literal">--rate</span>                             <span class="hljs-comment"># 输出比例信息</span><br>    <br>查看详细信息<br>[<span class="hljs-type">root</span>@<span class="hljs-type">bogon</span> ~]<span class="hljs-variable">$</span> ipvsadm <span class="hljs-literal">-Ln</span> <span class="hljs-literal">--rate</span><br>IP Virtual Server version <span class="hljs-number">1.2</span>.<span class="hljs-number">1</span> (size=<span class="hljs-number">4096</span>)<br>Prot LocalAddress:Port                 CPS    InPPS   OutPPS    InBPS   OutBPS<br>  -&gt; RemoteAddress:Port<br>结果显示：<br>    这里显示的信息比刚才的内容多多了，而且都是一些性能评判的指标数据：<br>    CPS-连接数、InPPS-输入连接数、OutPPS-输出连接数、InBPS-输入数据量、OutBPS-输出数据量<br>    <br></code></pre></td></tr></table></figure><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">LVS 官方支持三种工作模式，分别是 NAT 模式，DR 模式，TUN 模式，不同的模式有各自不同的特点，使用者可以根据业务场景选择不同的的工作模式来实现其负载均衡集群<br><br><br></code></pre></td></tr></table></figure><h4 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a><strong>NAT</strong>模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">NAT：Network address translation （网络地址转换）<br>  当私网主机和公网主机通信的时候，数据包经过NAT网关时，他会将数据包IP报文首部的中的源IP或目的IP进行转换。<br>  NAT 模式本质上就是多目标的DNAT（如果记不起来，请自行参考 iptables 课程中的 NAT 网络部份），LVS 将请求报文中的目标地址和目标端口修改为后端的 RS 服务器的 RIP 和 PORT 进行转发<br> <br></code></pre></td></tr></table></figure><p><img src="/../image/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/image-20250319143523369.png"></p><h6 id="我们在实践的时候，往往需要再-LVS主机上，定制两个网卡，一个对外，一个对内。"><a href="#我们在实践的时候，往往需要再-LVS主机上，定制两个网卡，一个对外，一个对内。" class="headerlink" title="我们在实践的时候，往往需要再 LVS主机上，定制两个网卡，一个对外，一个对内。"></a>我们在实践的时候，往往需要再 LVS主机上，定制两个网卡，一个对外，一个对内。</h6><h6 id="LVS-和-RS-之间可以是路由器，也可以是交换机。"><a href="#LVS-和-RS-之间可以是路由器，也可以是交换机。" class="headerlink" title="LVS 和 RS 之间可以是路由器，也可以是交换机。"></a>LVS 和 RS 之间可以是路由器，也可以是交换机。</h6><h6 id="数据报文中的源和目标，1-2是请求包，3-4是响应包"><a href="#数据报文中的源和目标，1-2是请求包，3-4是响应包" class="headerlink" title="数据报文中的源和目标，1-2是请求包，3-4是响应包"></a>数据报文中的源和目标，1-2是请求包，3-4是响应包</h6><table><thead><tr><th>报文顺序</th><th>源</th><th>目标</th></tr></thead><tbody><tr><td>1</td><td>client: 49.89.179.13:12345</td><td>LVS-VIP: 219.142.145.239:80</td></tr><tr><td>2</td><td>client: 49.89.179.13:12345</td><td>RS-RIP: 192.168.10.110:80</td></tr><tr><td>3</td><td>RS-RIP: 192.168.10.110:80</td><td>client: 49.89.179.13:12345</td></tr><tr><td>4</td><td>LVS-VIP: 219.142.145.239:80</td><td>client: 49.89.179.13:12345</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">基本工作流程<br><span class="hljs-number">1</span> 用户向具有公网ip地址的LVS主机地址(VIP)发起请求，(Src=CIP，Dst=VIP)<br><span class="hljs-number">2</span> LVS主机接收到数据包后，修改数据包的目标地址为后端RS1主机并转发出去，(Src=CIP，Dst=RIP1)<br><span class="hljs-number">3</span> 后端RS1主机处理完请求后，返回数据包给LVS主机，(Src=RIP1，Dst=CIP)<br><span class="hljs-number">4</span> LVS主机接收到数据包后，修改数据包的源地址为LVS的公网地址(VIP)并转发出去，(Src=VIP，Dst=CIP)<br>LVS本质上使用的类似于iptables里面的DNAT策略<br> - LVS工作于内核上，而不是iptables的五表五链上<br></code></pre></td></tr></table></figure><h5 id="lvs和-iptables"><a href="#lvs和-iptables" class="headerlink" title="lvs和****iptables"></a><strong>lvs</strong>和****iptables</h5><p><img src="/../image/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/image-20250319143852351.png"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">lvs的NAT模式在iptables里面的流向<br>lvs工作于 PREROUTING链和INPUT链中间的位置，起到了一个关卡的功能，一旦发现符合lvs规则的请求，直接转发给后端的RS主机。也就是说，更改了正常的iptables数据流向。<br><br>iptables里面的DNAT的数据流向<br>数据流向到本地主机之后，流经PREROUTING链，然后发现DNAT规则，然后经过FORWARD链将数据包转发到后端的主机。<br></code></pre></td></tr></table></figure><h5 id="为什么LVS流入的时候不经过forward链还需要开启端口转发"><a href="#为什么LVS流入的时候不经过forward链还需要开启端口转发" class="headerlink" title="为什么LVS流入的时候不经过forward链还需要开启端口转发"></a><strong>为什么</strong>LVS流入的时候不经过forward链还需要开启端口转发</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">关于ip_forward数据转发的功能<br>原则上来说，没有经过forward链的数据包是无需启用 ip_forward内核参数的。<br><br>根据我们对于 lvs和iptables的流入数据包的流向分析，发现 lvs的流入数据包没有经过forward链。所以原则上来说，是不需要打开ip_forward功能的。但是实际情况下，还是需要打开的。<br><br>lvs转发到后端真实主机之后，真实主机响应的数据包到达lvs之后的数据流向：<br>   数据流向到本地主机之后，<br>     流经PREROUTING链，然后发现DNAT规则，<br>       - 因为PREROUTING链是lvs主机上所有数据流的总入口<br>     经过FORWARD链将数据包转发<br>     流经POSTROUTING链，然后将数据包的源地址实现转换<br>     然后将数据包发送到互联网上<br>   所以后端真实主机的响应数据包必须原路返回<br>     所以，出网的网关地址必须是指定的<br></code></pre></td></tr></table></figure><h5 id="NAT-模式特点"><a href="#NAT-模式特点" class="headerlink" title="NAT 模式特点"></a>NAT 模式特点</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">整个网络环境需要涉及到两个网段：公网网段、私网网段<br>请求报文和响应报文都必须经由 LVS 转发，LVS 易成为系统瓶颈<br> - 数据包进入到私网的时候，转换的是目标ip地址，因为提供服务的是RIP主机<br> - 数据包进入到外网的时候，转换的是源ip地址，因为数据包来的时候，找的就是VIP<br> <br>RIP 和 DIP 应在同一个 IP 网络，且应使用私网地址；<br> - 由于数据包在流转的时候，尤其是RS响应的数据包要走到lvs主机，所以必须配置网关地址DIP。<br> - 支持端口映射，可修改请求报文的目标 PORT<br> <br>其他内容<br> - VS 必须是 Linux 系统，RS 可以是任意 OS 系统<br> - LVS 主机需要开启 ip_forward 转发<br></code></pre></td></tr></table></figure><h4 id="DR模式"><a href="#DR模式" class="headerlink" title="DR模式"></a><strong>DR</strong>模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">DR：Direct Routing（直接路由）<br>  DR 模式是 LVS 的默认模式，应用广泛，通过为请求报文重新封装一个 MAC 首部进行转发，源 MAC 是 DIP 所在的接口的 MAC，目标MAC 是某挑选出的 RS 的 RIP 所在接口的 MAC 地址；源 IP/PORT，以及目标 IP/PORT 均保持不变，但源 MAC 和目标 MAC 会发生改变，DR 模式下，数据链路层之上的内容不会发生变化<br></code></pre></td></tr></table></figure><p><img src="/../image/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/image-20250319145855201.png"></p><h6 id="LVS-和-RS-之间只能是交换机。不许允许是路由器。"><a href="#LVS-和-RS-之间只能是交换机。不许允许是路由器。" class="headerlink" title="LVS 和 RS 之间只能是交换机。不许允许是路由器。"></a>LVS 和 RS 之间只能是交换机。不许允许是路由器。</h6><h6 id="数据报文中的源和目标，1-2-请求包，3-响应包"><a href="#数据报文中的源和目标，1-2-请求包，3-响应包" class="headerlink" title="数据报文中的源和目标，1-2 请求包，3 响应包"></a>数据报文中的源和目标，1-2 请求包，3 响应包</h6><table><thead><tr><th>报文顺序</th><th>源</th><th>目标</th></tr></thead><tbody><tr><td>1</td><td>client: 49.89.179.13:12345 (client mac)</td><td>LVS-VIP: 219.142.145.239:80（中间有路由的话，是路由器对外 mac 地址）</td></tr><tr><td>2</td><td>client: 49.89.179.13:12345 (路由器对内 mac 地址)</td><td>LVS-VIP: 219.142.145.239:80 (LVS VIP mac)</td></tr><tr><td>3</td><td>LVS: 49.89.179.13:12345 (LVS DIP mac)</td><td>RS-VIP: 219.142.145.239:80 (RS RIP mac)</td></tr><tr><td>4</td><td>RS-VIP: 219.142.145.239:80 (RS RIP mac)</td><td>client: 49.89.179.13:12345 (路由器对内 mac 地址)</td></tr><tr><td>5</td><td>RS-VIP: 219.142.145.239:80 (路由器对外 mac 地址)</td><td>client: 49.89.179.13:12345 (client mac)</td></tr></tbody></table><h5 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1</span> 用户向具有公网ip地址的LVS主机地址(VIP)发起请求，(Src=CIP，Dst=VIP)<br><span class="hljs-number">2</span> LVS主机接收到数据包后，修改数据包的目标MAC地址为后端RS主机并转发出去，(Src=CIP，Dst=VIP)<br><span class="hljs-number">3</span> 后端RS主机处理完请求后，返回数据包给客户端主机，(Src=VIP，Dst=CIP)<br><br>整个过程只需要更改数据包外层的mac地址即可。<br></code></pre></td></tr></table></figure><h5 id="那么多的VIP，如何找到LVS主机"><a href="#那么多的VIP，如何找到LVS主机" class="headerlink" title="那么多的VIP，如何找到LVS主机"></a><strong>那么多的VIP，如何找到</strong>LVS主机</h5><p>为什么不允许将同一个IP配置在多个主机的网卡上？</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">在同一个局域网中，不允许将同一个 IP 地址配置在多个主机的网卡上，主要是为了避免 IP 地址冲突，确保网络通信的准确性和稳定性。<br><br>网络通信混乱：<br>   IP 地址是网络中设备的唯一标识，当有多个主机使用相同的 IP 地址时，网络中的路由器和交换机等设备无法准确区分数据应该发送到哪个具体的主机，会导致数据传输错误或混乱。例如，当一个数据包发送到这个重复的 IP 地址时，网络设备可能会随机将数据包发送到其中一个主机，或者在多个主机之间来回转发，造成数据丢失或延迟，影响网络通信的正常进行。<br>地址解析冲突：<br>   在局域网中，设备通过地址解析协议（ARP）来将 IP 地址映射到 MAC 地址，以便在数据链路层进行数据传输。如果多个主机使用同一个 IP 地址，会导致 ARP 表中的映射关系混乱。当其他设备请求解析该 IP 地址对应的 MAC 地址时，可能会收到多个不同的 MAC 地址响应，使得 ARP 缓存中的信息不准确，进一步影响数据的正确传输。<br>   <br></code></pre></td></tr></table></figure><h5 id="LVS的DR模式大量VIP是怎么回事"><a href="#LVS的DR模式大量VIP是怎么回事" class="headerlink" title="LVS的DR模式大量VIP是怎么回事"></a><strong>LVS</strong>的DR模式大量VIP是怎么回事</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">在lvs环境中，大量的VIP作用是不一样的<br>LVS主机上的VIP是用于接受用户请求<br>   - 所以该VIP必须在互联网上公开<br>RS主机上的VIP目的是永远响应用户请求<br>   - 所以该VIP是无需再互联网上公开，避免让客户端知道你是伪造的。<br></code></pre></td></tr></table></figure><h5 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ARP 请求：<br> 当本地主机需要与同一局域网内的远程主机通信时，它首先会检查自己的 ARP 缓存表，看是否已经有目标 IP 地址对应的 MAC 地址。如果没有，就会发送一个 ARP 请求广播包，这个广播包中包含了目标 IP 地址和自己的 MAC 地址等信息。局域网内的所有设备都会收到这个广播包，但只有目标 IP 地址对应的主机才会响应。<br>ARP 响应：<br> 目标主机收到 ARP 请求后，会将自己的 MAC 地址放入 ARP 响应包中，然后发送给请求方。请求方收到响应后，会将目标 IP 地址和对应的 MAC 地址存入自己的 ARP 缓存表中，以便后续通信使用。<br>数据传输：<br> 通过 ARP 协议获取到目标主机的 MAC 地址后，本地主机就可以将数据包封装成数据帧，在数据帧的首部添加源 MAC 地址和目标 MAC 地址等信息，然后将数据帧发送到局域网中。数据帧会根据 MAC 地址在局域网内传输，最终到达目标主机。<br></code></pre></td></tr></table></figure><h5 id="在跨网络通信中，ARP-协议同样起着重要的作用。"><a href="#在跨网络通信中，ARP-协议同样起着重要的作用。" class="headerlink" title="在跨网络通信中，ARP 协议同样起着重要的作用。"></a>在跨网络通信中，ARP 协议同样起着重要的作用。</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">arp无法穿越路由器，只能通过一段一段路由的方式传递到目标主机。<br>当数据包到达目标主机所在的局域网的网关（路由器）时，网关需要知道目标主机的 MAC 地址才能将数据包转发到目标主机。此时，网关会在局域网内发送 ARP 请求来获取目标主机的 MAC 地址。同样，目标主机响应 ARP 请求，网关收到响应后将目标主机的 MAC 地址信息添加到自己的 ARP 缓存中，然后将数据包转发到目标主机。<br></code></pre></td></tr></table></figure><h4 id="如何让真正的vip响应请求"><a href="#如何让真正的vip响应请求" class="headerlink" title="如何让真正的vip响应请求"></a><strong>如何让真正的</strong>vip响应请求</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">为了保证真正的目标IP地址主机能够接收到数据，需要采取两种方式来解决这种问题<br><br><span class="hljs-number">1</span> 收到客户端信息的时候，被动应答。<br> /proc/sys/net/ipv4/conf/all/arp_ignore，忽略ARP广播，不应答<br><span class="hljs-number">2</span> 主动向外部主机发布信息，我是谁。<br> /proc/sys/net/ipv4/conf/all/arp_announce，使用本机地址向外进行ARP请求，对外宣传我是谁<br></code></pre></td></tr></table></figure><h5 id="如何向真正的vip发送请求"><a href="#如何向真正的vip发送请求" class="headerlink" title="如何向真正的vip发送请求"></a><strong>如何向真正的</strong>vip发送请求</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">如何确保前端路由器将目标 IP 为 VIP 的请求报文只发往 LVS 服务器<br>在前端网关的 ARP 表中做静态绑定 - 不推荐<br>    - 将 VIP 和 LVS 服务器上的 VIP 所在的网卡的 MAC 地址写死<br>在 RS 服务器上用 arptables 工具设置  arp 防火墙<br>    arptables <span class="hljs-literal">-A</span> <span class="hljs-keyword">IN</span> <span class="hljs-literal">-d</span> <span class="hljs-variable">$VIP</span> <span class="hljs-literal">-j</span> DROP<br>    arptables <span class="hljs-literal">-A</span> OUT <span class="hljs-literal">-s</span> <span class="hljs-variable">$VIP</span> <span class="hljs-literal">-j</span> mangle <span class="hljs-literal">--mangle-ip-s</span> <span class="hljs-variable">$RIP</span><br> <br>确保 RS 服务器上的 VIP 不对外发送ARP 广播，也不会响应 ARP 广播<br>    - 在 RS 服务器上修改内核参数关闭 ARP 广播和 ARP 应答<br>    /proc/sys/net/ipv4/conf/all/arp_ignore<br>    /proc/sys/net/ipv4/conf/all/arp_announce<br>    - lvs的控制节点主机不参与内核参数的修改<br></code></pre></td></tr></table></figure><p><img src="/../Blog/blog/source/image/image-20250319153503041.png" alt="image-20250319153503041"></p><h5 id="DR-模式特点"><a href="#DR-模式特点" class="headerlink" title="DR 模式特点"></a>DR 模式特点</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell">LVS 服务器 和 RS 服务器 上都配置有 VIP 地址<br> - 确保前端路由器将目标 IP 为 VIP 的请求报文只发往 LVS 服务器；<br> - 后端 RS 服务器上的 VIP 只用作封装响应报文。<br> 不可响应 ARP 广播，也不可主动对外发送 ARP 广播<br> <br>RS 的 RIP 可以使用私网地址，也可以是公网地址；<br> - RIP 与 DIP在同一 IP 网络；<br> - RIP 的网关不能指向 DIP，以确保响应报文不会经由 LVS 服务器<br> - RS 服务器和 LVS 服务器要在同一个物理网络（不能跨路由，因为路由会隔离 ARP 广播）<br> <br>LVS 服务器只处理请求报文，不处理响应报文。<br> - 相对于 NAT 模式其负载性能会大幅提升，响应由 RS 服务器自行完成<br> - 不支持端口映射（端口不能修改，数据链路层之上的内容不会发生变化）<br> - 无需开启 ip_forward<br>RS 服务器可以使用大多数 OS 系统（支持相关网络设置即可）<br></code></pre></td></tr></table></figure><h4 id="TUN模式"><a href="#TUN模式" class="headerlink" title="TUN模式"></a><strong>TUN</strong>模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">TUN：IP tunneling（IP隧道）<br> TUN 模式不修改请求报文的IP首部（源 IP 为 CIP，目标 IP 为 VIP），而是在原 IP 报文之外再封装一个IP首部（源 IP 为 DIP，目标 IP 为 RIP），再将报文发往后端 RS，RS 直接响应客户端（源IP 是 VIP，目标 IP 是 CIP），TUN  模式与 DR 模式的区别是 TUN 模式下 LVS 服务器和后端 RS 可以不在同一个物理网络，可以跨公网<br></code></pre></td></tr></table></figure><p><img src="/../Blog/blog/source/image/image-20250319153725063.png" alt="image-20250319153725063"></p><h6 id="LVS-和-RS-之间允许是路由器。"><a href="#LVS-和-RS-之间允许是路由器。" class="headerlink" title="LVS 和 RS 之间允许是路由器。"></a>LVS 和 RS 之间允许是路由器。</h6><p>数据报文中的源和目标：</p><table><thead><tr><th>序号</th><th>源</th><th>目标</th></tr></thead><tbody><tr><td>1</td><td>client: 49.89.179.13:12345(client mac)</td><td>LVS-VIP: 219.142.145.239:80 (LVS VIP mac)</td></tr><tr><td>2</td><td>LVS-DIP: 74.176.10.123 (49.89.179.13:12345)(LVS-DIP mac)</td><td>RS-RIP: 152.68.174.110(219.142.145.239:80)(RS-RIP mac)</td></tr><tr><td>3</td><td>RS-VIP: 219.142.145.239:80 (RS - RIP mac)</td><td>client: 49.89.179.13:12345 (网关 MAC)</td></tr></tbody></table><h5 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1</span> 用户向具有公网ip地址的LVS主机地址(VIP)发起请求，(Src=CIP，Dst=VIP)<br><span class="hljs-number">2</span> LVS主机接收到数据包后，将原数据包封装到ip隧道数据包中，转发到后端RS主机，(Src=DIP，Dst=RIP)<br><span class="hljs-number">3</span> 后端RS主机处理完请求后，返回数据包给客户端主机，(Src=VIP，Dst=CIP)<br></code></pre></td></tr></table></figure><h5 id="数据包拆解"><a href="#数据包拆解" class="headerlink" title="数据包拆解"></a><strong>数据包拆解</strong></h5><h6 id="正常的数据包结构"><a href="#正常的数据包结构" class="headerlink" title="正常的数据包结构"></a>正常的数据包结构</h6><p><img src="/../image/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/image-20250319154759524.png"></p><h6 id="TUN模式下的数据包"><a href="#TUN模式下的数据包" class="headerlink" title="TUN模式下的数据包"></a>TUN模式下的数据包</h6><p><img src="/../image/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/image-20250319154823519.png"></p><h4 id="整体流程效果"><a href="#整体流程效果" class="headerlink" title="整体流程效果"></a>整体流程效果</h4><p><img src="/../image/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/image-20250319154951278.png" alt="image-20250319154951278"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">数据包到达LVS主机之后<br>   对数据包进行二次封装处理<br>   通过 POSTROUTING 将数据包转发给 后端的真实主机<br>数据包到达RS主机之后<br>   拆解数据包，然后响应数据<br>   直接将数据返回给客户端主机<br><br>相较于 DR模型来说，它修改的是 更深层的ip报文，所以性能有些差。但是好处是可以跨网络。<br></code></pre></td></tr></table></figure><h5 id="TUN-模式特点"><a href="#TUN-模式特点" class="headerlink" title="TUN 模式特点"></a>TUN 模式特点</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">- RIP 和 DIP 可以不处于同一物理网络中，RS 的网关一般不能指向 DIP，且 RIP 可以和公网通信；<br>- 集群节点可以跨互联网实现，DIP，VIP，RIP 都可以是公网地址；<br>- RS 服务器上的 tun 接口需要配置 VIP 地址，以便接收 LVS 服务器转发的数据包，以及作为响应报文的源 IP；<br>- LVS 服务器转发给 RS 服务器时需要使用隧道，隧道外层的数据报文中的源 IP  是 DIP，目标 IP 是<br>RIP；<br>- RS 服务器响应给客户端的报文中源 IP 是 VIP，目标 IP 是 CIP；<br>- LVS 服务器只处理请求报文，不处理响应报文，相对于 NAT 模式其负载性能会大幅提升，响应由 RS 服务器自行完成；<br>- 不支持端口映射；<br>- 无需开启 ip_forward；<br>- RS 服务器的操作系统必须支持隧道功能；<br></code></pre></td></tr></table></figure><h4 id="FULLNAT模式"><a href="#FULLNAT模式" class="headerlink" title="FULLNAT模式"></a><strong>FULLNAT</strong>模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">FULL NAT：Full Network address translation （完全网络地址转换）<br><br>FULL NAT 模式不是 LVS 官方内置的工作模式，是由阿里巴巴公司开发的第三方模式，仅在 <span class="hljs-number">2.6</span>.<span class="hljs-number">32</span>版本的内核中存在过，目前主流的 LINUX 发行版并不支持该模式，相对于 NAT 模式而言，FULL NAT 在转发时，将请求报文中的源 IP 地址 源端口和目标 IP 地址目标端口都进行了替换，然后再向后端转发<br><br>FULL NAT 模式主要用于公有云环境中，在阿里云上，不建议将虚拟机设为流量穿透服务，虚拟机网关必须使用其自带的网关，在此情况下，无法修改后端 RS 服务器的网关，则无法使用 NAT 模式，所以需要使用 FULL NAT 模式来解决此类问题<br></code></pre></td></tr></table></figure><p><img src="/../image/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/image-20250319155251888.png"></p><h6 id="数据报文中的源和目标"><a href="#数据报文中的源和目标" class="headerlink" title="数据报文中的源和目标"></a>数据报文中的源和目标</h6><table><thead><tr><th>报文顺序</th><th>源</th><th>目标</th></tr></thead><tbody><tr><td>1</td><td>client: 49.89.179.13:12345</td><td>LVS-VIP: 219.142.145.239:80</td></tr><tr><td>2</td><td>LVS-DIP: 192.168.10.123:12345</td><td>RS-RIP: 192.168.10.110:80</td></tr><tr><td>3</td><td>RS-RIP: 192.168.10.110:80</td><td>LVS-DIP: 192.168.10.123:12345</td></tr></tbody></table><h6 id="整体效果图"><a href="#整体效果图" class="headerlink" title="整体效果图"></a><strong>整体效果图</strong></h6><h5 id="FULL-NAT-模式特点"><a href="#FULL-NAT-模式特点" class="headerlink" title="FULL NAT 模式特点"></a>FULL NAT 模式特点</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">- RIP 和 DIP 不要求在同一网络，但要能通信；RS 网关不必指向 DIP<br>- 请求报文和响应报文都必须经由 LVS 转发，LVS 易成为系统瓶颈<br>- 支持端口映射，可修改请求报文的目标 PORT<br>- VS 必须是 Linux 系统，RS 可以是任意 OS 系统<br>- LVS 主机需要开启 ip_forward 转发<br>注意：此类型kernel默认不支持<br></code></pre></td></tr></table></figure><h4 id="工作模式小结"><a href="#工作模式小结" class="headerlink" title="工作模式小结"></a><strong>工作模式小结</strong></h4><table><thead><tr><th></th><th>NAT</th><th>TUN</th><th>DR</th></tr></thead><tbody><tr><td>RS 服务器系统</td><td>无任何额外要求</td><td>要求支持隧道功能</td><td>要求禁用 ARP 广播和 ARP 应答</td></tr><tr><td>RS 服务器网络</td><td>私有网络</td><td>私有网络 &#x2F; 公有网络</td><td>私有网络</td></tr><tr><td>RS 服务器数量</td><td>较少，一般不超过 20 台</td><td>可以超过 100 台</td><td>可以超过 100 台</td></tr><tr><td>RS 服务器网关</td><td>指向 LVS 服务器，原路返回</td><td>指向自己的路由器，不需要原路返回</td><td>指向自己的路由器，不需要原路返回</td></tr><tr><td>优点</td><td>支持端口转换</td><td>支持公网</td><td>性能最好</td></tr><tr><td>缺点</td><td>性能存在瓶颈</td><td>要求支持隧道，不支持端口转换</td><td>不支持跨网段和端口转换</td></tr></tbody></table><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">```<br><br><span class="hljs-comment">##### **调度分类**</span><br><br>```powershell<br>根据我们的梳理，lvs的调度算法，站在<span class="hljs-string">&quot;是否考虑到后端主机负载&quot;</span>的角度可以划分为以下三类<br>静态方法：仅仅从调度策略本身实现的功能角度进行工作<br> RR、WRR、DH、SH<br>动态方法：在满足调度策略本身实现功的前提下，还要考虑后端主机的动态负载效果<br> LC、WLC、LBLC、LBLCR、SED、NQ<br>高版本内核中新增的调度算法: 在 <span class="hljs-number">4.15</span> 版本的内核中新增的方法<br> FO、OVF、MH、TNDR等<br></code></pre></td></tr></table></figure><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">静态算法仅根据算法本身来进行调度，不关注后端 RS 服务器负载情况<br>RR：Round Robin，轮询算法，<br> LVS 服务器将前端请求轮流转发到后端每一台 RS 服务器上，后端每台 RS 服务器处理的请求量都是相同的<br>WRR：Weight RR，加权轮询算法，<br> LVS 服务器将前端请求根据后端 RS 服务器的权重进行转发，对于后端 RS 服务器中性能好的机器可以设置较高的权重，物尽其用<br>SH：Source Hash，源 IP 地址 hash，<br> 将来自于同一个 IP 地址的客户端请求调度到后端同一台 RS 服务器上，从而实现会话保持<br>DH：Destinatio Hash，目标 IP 地址 hash，<br> 客户端的请求第一次被调度到某到 RS 服务器后，其后续的请求都将会被发往同一台 RS 服务器，一般用于正向代理缓存场景<br></code></pre></td></tr></table></figure><h5 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">动态算法要根据当前系统中后端 RS 服务器的负载情况进行调度，给负载较低的后端主机多转发，给负载较高的后端主机少转发。<br><br>活动连接：Activeconns ，在 LVS 中，有数据传输的连接被称为活动连接<br>非活动连接：InActiveconns，在 LVS 中，没有数据传输的连接被称为非活动连接<br><br></code></pre></td></tr></table></figure><h4 id="ipvsadm命令"><a href="#ipvsadm命令" class="headerlink" title="ipvsadm命令"></a><strong>ipvsadm</strong>命令</h4><h6 id="关于集群"><a href="#关于集群" class="headerlink" title="关于集群"></a>关于集群</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs powershell">增加集群<br>命令格式：ipvsadm <span class="hljs-literal">-A</span> <span class="hljs-literal">-t</span>|u|f service_address:port [-<span class="hljs-type">s</span> <span class="hljs-type">scheduler</span>] [-<span class="hljs-type">p</span> [<span class="hljs-type">timeout</span>]]<br>格式详解：<br>    <span class="hljs-literal">-A</span> 增加lvs集群<br>    <span class="hljs-literal">-t</span> 指定lvs主机地址信息<br>        <span class="hljs-literal">-t</span> 指定lvs集群服务主机的tcp端口<br>        <span class="hljs-literal">-u</span> 指定lvs集群服务主机的udp端口<br>        <span class="hljs-operator">-f</span> 指定lvs集群服务主机采用的防火墙自定义规则的标记，默认是数字<br>        这三个选项最好选择一个，想要多选的话，再创建一条规则即可。<br>    <span class="hljs-literal">-s</span> 指定lvs集群的调度策略，默认是wlc<br><br>编辑集群<br>命令格式：ipvsadm <span class="hljs-literal">-E</span> <span class="hljs-literal">-t</span> service_address:port [-<span class="hljs-type">s</span> <span class="hljs-type">scheduler</span>]<br>格式详解：<br> <span class="hljs-literal">-E</span> 编辑lvs集群的信息<br> 注意：<br> 更改集群信息的时候，只能更改已存在的lvs集群的细节属性，不能直接将lvs的地址更改<br><br>删除集群<br>命令格式：ipvsadm <span class="hljs-literal">-D</span> <span class="hljs-literal">-t</span> service_address:port<br>格式详解：<br>    <span class="hljs-literal">-D</span> 删除指定lvs集群的信息<br>    <span class="hljs-literal">-C</span> 删除所有lvs集群的信息<br>    注意：<br>  删除集群信息的时候，必须指定已存在的lvs集群地址，协议也必须正确<br></code></pre></td></tr></table></figure><h6 id="关于主机"><a href="#关于主机" class="headerlink" title="关于主机"></a>关于主机</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs powershell">查看主机<br>使用命令：ipvsadm <span class="hljs-literal">-Ln</span><br>对于lvs集群中的主机来说，可以通过ipvsadm命令来查看，它可以通过配置文件专门来显示连接主机的规则信息<br> /proc/net/ip_vs 和 /proc/net/ip_vs_conn<br>注意：<br> ip_vs_conn 只显示连接成功的信息，我们会在后序模式实践的过程中，给大家展示效果。<br> <br>增加主机<br>命令格式：ipvsadm <span class="hljs-literal">-a</span> <span class="hljs-literal">-t</span> service_address:port <span class="hljs-literal">-r</span> server<span class="hljs-literal">-address</span>:port <span class="hljs-literal">-g</span>|m|i <br>[<span class="hljs-type">options</span>]<br>格式详解：<br>    <span class="hljs-literal">-a</span> 给lvs集群增加一个真实主机RS<br>    <span class="hljs-literal">-r</span> 指定真实主机的地址信息，格式是 IP:[<span class="hljs-type">Port</span>],Port可以省略<br>    <span class="hljs-literal">-g</span>|m|i 设定后端主机的转发模式<br>        <span class="hljs-literal">-g</span> 采用默认的direct routing模式<br>        <span class="hljs-literal">-m</span> 采用masquerading的nat模式<br>        <span class="hljs-literal">-i</span> 采用ipip的tunneling模式<br>   这三者只能选择其一<br>    <span class="hljs-literal">-w</span> 指定真实主机的权重信息<br>    <br>编辑主机<br>命令格式：ipvsadm <span class="hljs-literal">-e</span> <span class="hljs-literal">-t</span> service_address:port <span class="hljs-literal">-r</span> server<span class="hljs-literal">-address</span>:port [<span class="hljs-type">options</span>]<br>格式详解：<br>    <span class="hljs-literal">-e</span> 修改真实主机的属性信息<br>    <span class="hljs-literal">-m</span> 设定真实主机的转发模型信息为nat模型<br>    注意：<br>      修改真实主机信息的时候，必须指定已存在的lvs集群地址，协议也必须正确<br>      <span class="hljs-literal">-m</span> 和 <span class="hljs-literal">-i</span> 不能同时使用<br><br>删除主机<br>命令格式：ipvsadm <span class="hljs-literal">-d</span> <span class="hljs-literal">-t</span> service_address:port <span class="hljs-literal">-r</span> server<span class="hljs-literal">-address</span>:port<br>格式详解：<br>    <span class="hljs-literal">-d</span> 删除真实主机的属性信息<br>    注意：<br>        lvs服务主机和rs真实主机的地址必须指定正确<br>        单个删除RS主机有些繁琐，我们可以直接采用删除lvs主机的效果清空所有目标主机<br></code></pre></td></tr></table></figure><h6 id="关于规则"><a href="#关于规则" class="headerlink" title="关于规则"></a>关于规则</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">对于ipvsadm来说，我们可以通过ipvsadm<span class="hljs-literal">-save</span>的命令来查看和保存lvs的相关规则。<br>命令格式：ipvsadm<span class="hljs-literal">-save</span> [-<span class="hljs-type">n</span>]<br>格式详解：<br>    <span class="hljs-literal">-n</span> 以精确的数字格式打印出lvs规则，如果不加<span class="hljs-literal">-n</span>的话，他会基于域名解析，将相应的ip转换成主机名展示<br>    使用 ipvsadm <span class="hljs-literal">-Sn</span> 可以实现同样的效果<br>    <br>保存规则<br>通过 ipvsadm<span class="hljs-literal">-save</span> + &gt; 的方式实现 规则的保存<br>使用两种风格保存规则<br>ipvsadm<span class="hljs-literal">-save</span> <span class="hljs-literal">-n</span> &gt; n<span class="hljs-literal">-ipvsadm</span><br>ipvsadm<span class="hljs-literal">-save</span> &gt; non<span class="hljs-literal">-ipvsadm</span><br><br>清空规则<br>命令格式：ipvsadm <span class="hljs-literal">-C</span><br>格式详解：<br> <span class="hljs-literal">-C</span> 清空lvs服务集群规则<br></code></pre></td></tr></table></figure><h5 id="默认定制的规则会重启主机后丢失"><a href="#默认定制的规则会重启主机后丢失" class="headerlink" title="默认定制的规则会重启主机后丢失"></a><strong>默认定制的规则会重启主机后丢失</strong></h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">对于ipvsadm设置的规则来说，它是我们操作lvs规则的常见方法，而且是以命令行的方式来运行的，但是这种命令行编写的规则，好处就是灵活生效快，但是缺点就是重启主机后规则自动清空。<br><br>我们可以通过规则保存服务来实现，规则的自动保存<br>[<span class="hljs-type">root</span>@<span class="hljs-type">bogon</span> ~]<span class="hljs-variable">$</span> service ipvsadm save<br><br>保存规则<br>ipvsadm<span class="hljs-literal">-save</span> <span class="hljs-literal">-n</span> &gt; /etc/sysconfig/ipvsadm<br>设置为开启自启<br>systemctl enable ipvsadm.service<br></code></pre></td></tr></table></figure><h4 id="防火墙标识"><a href="#防火墙标识" class="headerlink" title="防火墙标识"></a>防火墙标识</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">FWM：FireWall Mark<br>LVS（Linux Virtual Server）的防火墙标记 FWM（Firewall Mark）是一种用于在 LVS 负载均衡环境中对报文进行分类和管理的技术。<br><br>功能作用<br>多应用合并调度：<br>  可借助防火墙标记来分类报文，然后基于标记定义集群服务，能将多个不同的应用使用同一个集群服务进行调度。比如在搭建 Web 服务器负载均衡时，可把 HTTP 的 <span class="hljs-number">80</span> 端口和 HTTPS 的 <span class="hljs-number">443</span> 端口服务指向同一个集群，便于统一管理和调度。<br> <br>解决轮询错乱问题：<br>  以 HTTP 和 HTTPS 为例，若不使用 FWM，默认控制是分开轮询的，可能出现第一次访问 <span class="hljs-number">80</span> 端口被轮询到某台服务器，下次访问 <span class="hljs-number">443</span> 端口却被轮询到另一台服务器的情况，而使用 FWM 能确保相关服务的请求被分配到同一台真实服务器。<br>  <br>实现原理<br>  在 Director 主机上，利用 iptables 工具在 mangle 表的 PREROUTING 链上对符合条件的报文打标记。<br>  数据包进入系统时，先经过 PREROUTING 链，在这里根据定义的规则检查目标地址、协议、端口等信息，若符合条件则为数据包打上特定的标记，之后 IPVS（IP Virtual Server）根据这些标记来定义和管理集群服务，实现对不同端口服务的统一调度。<br></code></pre></td></tr></table></figure><p><strong>1.3.2.4.3.3</strong> <strong>部署<strong><strong>httpd</strong></strong>服务</strong></p><p><strong>1.3.3.2.2.3</strong> <strong>定制<strong><strong>lvs-route</strong></strong>主机****ip</strong></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>企业级 NoSQL 数据库 Redis</title>
    <link href="/2025/06/09/%E4%BC%81%E4%B8%9A%E7%BA%A7%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Redis/"/>
    <url>/2025/06/09/%E4%BC%81%E4%B8%9A%E7%BA%A7%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="企业级-NoSQL-数据库-Redis"><a href="#企业级-NoSQL-数据库-Redis" class="headerlink" title="企业级 NoSQL 数据库 Redis"></a>企业级 NoSQL 数据库 Redis</h1><h2 id="NoSQL-数据库"><a href="#NoSQL-数据库" class="headerlink" title="NoSQL 数据库"></a>NoSQL 数据库</h2><h4 id="什么是-NoSQL"><a href="#什么是-NoSQL" class="headerlink" title="什么是 NoSQL"></a>什么是 NoSQL</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">数据库主要分为两大类：关系型数据库与 NoSQL 数据库。<br><br>关系型数据库，是建立在关系模型基础上的数据库，其借助于集合代数等数学概念和方法来处理数据库中的数据。主流的 MySQL、Oracle、MS SQL Server 和 DB2 都属于这类传统数据库。<br><br>NoSQL 数据库，全称为 Not Only SQL，意思就是适用关系型数据库的时候就使用关系型数据库，不适用的时候可以考虑使用更加合适的数据存储。NoSQL 是对不同于传统的关系型数据库的数据库管理系统的统称。<br></code></pre></td></tr></table></figure><h4 id="RDBMS和NOSQL对比"><a href="#RDBMS和NOSQL对比" class="headerlink" title="RDBMS和NOSQL对比"></a>RDBMS和NOSQL对比</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">RDBMS<br>高度组织化结构化数据<br>结构化查询语言（SQL）<br>数据和关系都存储在单独的表中。<br>数据操纵语言，数据定义语言<br>严格的一致性<br>基础事务<br>NoSQL<br>代表着不仅仅是SQL, 没有声明性查询语言<br>没有预定义的模式<br>最终一致性，而非ACID属性<br>非结构化和不可预知的数据<br>CAP定理<br>高性能，高可用性和可伸缩性<br></code></pre></td></tr></table></figure><h4 id="NoSQL的优点-缺点"><a href="#NoSQL的优点-缺点" class="headerlink" title="NoSQL的优点&#x2F;缺点"></a>NoSQL的优点&#x2F;缺点</h4><table><thead><tr><th>对比维度</th><th>关系型数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td>特点</td><td>- 数据关系模型基于关系模型，结构化存储，完整性约束 - 基于二维表及其之间的联系，需要连接、并、交、差、除等数据操作 - 采用结构化的查询语言（SQL）做数据读写 - 操作需要数据的一致性，需要事务甚至是强一致性</td><td>- 非结构化的存储 - 基于多维关系模型 - 具有特有的使用场景</td></tr><tr><td>优点</td><td>- 保持数据的一致性（事务处理） - 可以进行 join 等复杂查询 - 通用化，技术成熟</td><td>- 高并发，大数据下读写能力较强 - 基本支持分布式，易于扩展，可伸缩 - 简单，弱结构化存储</td></tr><tr><td>缺点</td><td>- 数据读写必须经过 sql 解析，大量数据、高并发下读写性能不足 - 对数据做读写，或修改数据结构时需要加锁，影响并发操作 - 无法适应非结构化存储 - 扩展困难 - 昂贵、复杂</td><td>- join 等复杂操作能力较弱 - 事务支持较弱 - 通用性差 - 无完整约束复杂业务场景支持较差</td></tr></tbody></table><h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs powershell">对于一个分布式计算系统，不可能同时满足以下三点:<br>C：Consistency<br>即一致性， 所有节点在同一时间具有相同的数据视图<br><br>A：Availability<br>即可用性，所有的节点都保持高可用性,要求服务在接收到客户端请求后，都能够给出响应<br><br>P：Partiton tolerance<br>分区是指系统中的节点由于网络故障无法相互通信，导致系统被分成多个孤立的子系统<br><br>遵循CAP原理，一个数据分布式系统不可能同时满足C和A和P这<span class="hljs-number">3</span>个条件。<br><br>在服务器之间的网络出现异常的情况下，一致性和可用性是不可能同时满足的，必须要放弃一个，来保证另一个。这也正是CAP定理所说的，在分布式系统中，P总是存在的。在P发生的前提下，C(一致性)和A（可用性）不能同时满足。这种情况在做架构设计的时候就要考虑到，要评估对业务的影响，进行权衡决定放弃哪一个。在通常的业务场景下，系统不可用是不能接受的，所以要优先保证可用性，暂时放弃一致性。<br><br>根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 <span class="hljs-built_in">CP</span> 原则和满足 AP 原则三大类：<br>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统将不是一个标准的分布式系统<br>比如:单一数据中心数据库,所有节点都位于同一个数据中心，并且节点之间的通信是高可靠的<br><span class="hljs-built_in">CP</span> - 满足一致性，分区容忍性的系统，通常性能不是特别高。 放弃可用性，追求强一致性和分区容错性<br>例如: Zookeeper,ETCD,Consul,MySQL的PXC等集群就是追求的强一致，再比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。<br>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。<br>放弃一致性，追求分区容忍性和可用性。这是很多分布式系统设计时的选择。<br>例如：MySQL主从复制，默认是异步机制就可以实现AP，但是用户接受所查询的到数据在一定时间内不是最新的.<br></code></pre></td></tr></table></figure><h4 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Redis (Remote Dictionary Server 远程字典服务)是一个遵循BSD MIT开源协议的高性能的NoSQL<br></code></pre></td></tr></table></figure><h4 id="Redis-特性"><a href="#Redis-特性" class="headerlink" title="Redis 特性"></a>Redis 特性</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">速度快: <span class="hljs-number">10</span>W QPS,基于内存,C语言实现<br>单线程：引号的”单线程“<br>     单线程为何如此快?<br>       纯内存<br>       非阻塞<br>       避免线程切换和竞态消耗<br>       基于Epoll实现IO多路复用<br>持久化：RDB，AOF<br>支持多种数据类型<br>支持多种编程语言<br>功能丰富: 支持Lua脚本,发布订阅,事务,pipeline等功能<br>简单: 代码短小精悍(单机核心代码只有<span class="hljs-number">23000</span>行左右),单线程开发容易,不依赖外部库,使用简单<br>主从复制<br>支持高可用和分布式<br></code></pre></td></tr></table></figure><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">一次只运行一条命令<br>避免执行长(慢)命令:keys *, flushall, flushdb, slow lua script, mutil/exec, operate bigvalue(collection)<br>其实不是单线程: 早期版本是单进程单线程,<span class="hljs-number">3.0</span> 版本后实际还有其它的线程, 实现特定功能,如: fysncfile descriptor,close file descriptor<br></code></pre></td></tr></table></figure><h4 id="Redis-对比-Memcached"><a href="#Redis-对比-Memcached" class="headerlink" title="Redis 对比 Memcached"></a>Redis 对比 Memcached</h4><table><thead><tr><th>比较类别</th><th>Redis</th><th>Memcached</th></tr></thead><tbody><tr><td>支持的数据结构</td><td>哈希、列表、集合、有序集合</td><td>纯 key-value</td></tr><tr><td>持久化支持</td><td>有</td><td>无</td></tr><tr><td>高可用支持</td><td>redis 支持集群功能，可以实现主动复制，读写分离。官方提供了 Sentinel 集群管理工具，能够实现主从服务监控，故障自动转移，这一切，对于客户端都是透明的，无需程序改动，也无需人工介入</td><td>需要二次开发</td></tr><tr><td>存储 value 容量</td><td>最大 512M</td><td>最大 1M</td></tr><tr><td>内存分配</td><td>临时申请空间，可能导致碎片</td><td>预分配内存池的方式管理内存，能够省去内存分配时间</td></tr><tr><td>虚拟内存使用</td><td>有自己的 VM 机制，理论上能够存储比物理内存更多的数据，当数据超量时，会引发 swap，把冷数据刷到磁盘上</td><td>所有的数据存储在物理内存里</td></tr><tr><td>网络模型</td><td>非阻塞 IO 复用模型，提供一些非 KV 存储之外的排序，聚合功能，在执行这些功能时，复杂的 CPU 计算，会阻塞整个 IO 调度</td><td>非阻塞 IO 复用模型</td></tr><tr><td>水平扩展的支持</td><td>redis cluster 可以横向扩展</td><td>暂无</td></tr><tr><td>多线程</td><td>Redis6.0 之前是只支持单线程</td><td>Memcached 支持多线程，CPU 利用方面 Memcache 优于 Redis</td></tr><tr><td>过期策略</td><td>有专门线程，清除缓存数据</td><td>懒淘汰机制：每次往缓存放入数据的时候，都会存一个时间，在读取的时候要和设置的时间做 TTL 比较来判断是否过期</td></tr><tr><td>单机 QPS</td><td>约 10W</td><td>约 60W</td></tr><tr><td>源代码可读性</td><td>代码清爽简洁</td><td>可能是考虑了太多的扩展性，多系统的兼容性，代码不清爽</td></tr><tr><td>适用场景</td><td>复杂数据结构、有持久化、高可用需求、value 存储内容较大</td><td>纯 KV，数据量非常大，并发量非常大的业务</td></tr></tbody></table><h4 id="Redis-常见应用场景"><a href="#Redis-常见应用场景" class="headerlink" title="Redis 常见应用场景"></a>Redis 常见应用场景</h4><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250331195955711.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">缓存：缓存RDBMS中数据,比如网站的查询结果、商品信息、微博、新闻、消息<br>Session 共享：实现Web集群中的多服务器间的 session 共享<br>计数器：商品访问排行榜、浏览数、粉丝数、关注、点赞、评论等和次数相关的数值统计场景<br>社交：朋友圈、共同好友、可能认识他们等<br>地理位置: 基于地理信息系统GIS（Geographic Information System)实现摇一摇、附近的人、外卖等功能<br>消息队列：ELK等日志系统缓存、业务的订阅/发布系统<br></code></pre></td></tr></table></figure><h3 id="缓存的实现流程"><a href="#缓存的实现流程" class="headerlink" title="缓存的实现流程"></a>缓存的实现流程</h3><h5 id="数据更新操作流程："><a href="#数据更新操作流程：" class="headerlink" title="数据更新操作流程："></a>数据更新操作流程：</h5><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250331200116061.png)</p><h5 id="数据读操作流程："><a href="#数据读操作流程：" class="headerlink" title="数据读操作流程："></a>数据读操作流程：</h5><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250331200133734.png)</p><h4 id="缓存穿透-缓存击穿和缓存雪崩"><a href="#缓存穿透-缓存击穿和缓存雪崩" class="headerlink" title="缓存穿透,缓存击穿和缓存雪崩"></a>缓存穿透,缓存击穿和缓存雪崩</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs powershell">缓存穿透 Cache Penetration<br>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，比如： 发起为id为 “<span class="hljs-literal">-1</span>” 的数据或id为特别大不存在的数据。<br>这时的用户很可能是攻击者，攻击会导致数据库压力过大。<br>解决方法：<br>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=<span class="hljs-number">0</span>的直接拦截<br>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key<span class="hljs-literal">-value</span>对写为key<span class="hljs-literal">-null</span>，缓存有效时间可以设置短点，如<span class="hljs-number">30</span>秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击<br><br>缓存击穿 Cache breakdown<br>缓存击穿是指缓存中没有但数据库中有的数据，比如：热点数据的缓存时间到期后，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力<br>解决方法：<br>设置热点数据永远不过期。<br><br>缓存雪崩 Thunder Hurd Problem<br>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。<br>解决方法：<br>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生<br>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中<br>设置热点数据永远不过期<br></code></pre></td></tr></table></figure><h4 id="缓存-crash"><a href="#缓存-crash" class="headerlink" title="缓存 crash"></a>缓存 crash</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Redis 缓存服务宕机，造成 缓存服务失效<br>解决方法：Redis高可用集群<br></code></pre></td></tr></table></figure><h4 id="Pipeline-流水线"><a href="#Pipeline-流水线" class="headerlink" title="Pipeline 流水线"></a>Pipeline 流水线</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Redis 客户端执行一条命令分<span class="hljs-number">6</span>个过程：<br>发送命令－-〉网络传输－-〉 命令排队－-〉命令执行－-〉网络传输－-〉 返回结果<br>这个过程称为Round trip time(简称RTT, 往返时间)，mget,mset指令可以一次性的批量对多个数据的执<br>行操作,所以有效节约了RTT<br>但大部分命令（如hgetall）不支持批量操作，需要消耗N次RTT ，利用 Pipeline 技术可以解决这一问题<br><br></code></pre></td></tr></table></figure><h5 id="未使用pipeline执行N条命令如下图"><a href="#未使用pipeline执行N条命令如下图" class="headerlink" title="未使用pipeline执行N条命令如下图"></a>未使用pipeline执行N条命令如下图</h5><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250331201524132.png)</p><h5 id="使用了pipeline执行N条命令如下图"><a href="#使用了pipeline执行N条命令如下图" class="headerlink" title="使用了pipeline执行N条命令如下图"></a>使用了pipeline执行N条命令如下图</h5><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250331201544163.png)</p><h5 id="两者性能对比"><a href="#两者性能对比" class="headerlink" title="两者性能对比"></a>两者性能对比</h5><table><thead><tr><th>网络</th><th>延迟</th><th>非 Pipeline</th><th>Pipeline</th></tr></thead><tbody><tr><td>本机</td><td>0.17ms</td><td>573ms</td><td>134ms</td></tr><tr><td>内网服务器</td><td>0.41ms</td><td>1610ms</td><td>240ms</td></tr><tr><td>异地机房</td><td>7ms</td><td>80000ms</td><td>1104ms</td></tr></tbody></table><h4 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">安装方法<br>包安装<br>源码编译<br>容器运行<br></code></pre></td></tr></table></figure><h4 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Redis 是基于内存型的NoSQL, 和MySQL是不同的,使用内存进行数据保存<br>如果想实现数据的持久化,Redis也也可支持将内存数据保存到硬盘文件中<br>Redis支持两种数据持久化保存方法<br>RDB:Redis DataBase<br>AOF:AppendOnlyFile<br></code></pre></td></tr></table></figure><h5 id="RDB-工作原理"><a href="#RDB-工作原理" class="headerlink" title="RDB 工作原理"></a>RDB 工作原理</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">是基于某个时间点的快照，注意RDB只保留当前最新版本的一个快照相当于MySQL中的完全备份<br>RDB 持久化功能所生成的 RDB 文件是一个经过压缩的二进制文件，通过该文件可以还原生成该 RDB 文件时数据库的状态。因为 RDB 文件是保存在磁盘中的，所以即便 Redis 服务进程甚至服务器宕机，只要磁盘中 RDB 文件存在，就能将数据恢复<br>RDB 支持save和bgsave两种命令实现数据文件的持久化<br>注意： save 指令使用主进程进行备份，而不生成新的子进程，但是也会生成临时文件temp-&lt;主进程PID&gt;.rdb文件<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250402192923373.png)</p><h6 id="save-执行过程会使用主进程进行快照，并生成临时文件temp-rdb文件"><a href="#save-执行过程会使用主进程进行快照，并生成临时文件temp-rdb文件" class="headerlink" title="save 执行过程会使用主进程进行快照，并生成临时文件temp-&lt;主进程PID&gt;.rdb文件"></a>save 执行过程会使用主进程进行快照，并生成临时文件temp-&lt;主进程PID&gt;.rdb文件</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-number">1</span>]   Done                    redis<span class="hljs-literal">-cli</span> <span class="hljs-literal">-a</span> <span class="hljs-number">123456</span> save<br>total <span class="hljs-number">1492</span><br>drwxr<span class="hljs-literal">-xr-x</span> <span class="hljs-number">2</span> redis redis    <span class="hljs-number">4096</span> Apr  <span class="hljs-number">2</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span> ./<br>drwxr<span class="hljs-literal">-xr-x</span> <span class="hljs-number">7</span> redis redis    <span class="hljs-number">4096</span> Apr  <span class="hljs-number">2</span> <span class="hljs-number">11</span>:<span class="hljs-number">38</span> ../<br><span class="hljs-literal">-rw-r--r--</span> <span class="hljs-number">1</span> redis redis <span class="hljs-number">1477877</span> Apr  <span class="hljs-number">2</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span> dump.rdb<br><span class="hljs-literal">-rw-r--r--</span> <span class="hljs-number">1</span> redis redis   <span class="hljs-number">40960</span> Apr  <span class="hljs-number">2</span> <span class="hljs-number">11</span>:<span class="hljs-number">41</span> temp<span class="hljs-literal">-7391</span>.rdb<br><br></code></pre></td></tr></table></figure><h6 id="RDB-bgsave-实现快照"><a href="#RDB-bgsave-实现快照" class="headerlink" title="RDB bgsave 实现快照"></a>RDB bgsave 实现快照</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">首先从redis 主进程先fork生成一个新的子进程,此子进程负责将Redis内存数据保存为一个临时文件tmp-<br>&lt;子进程pid&gt;.rdb<br>当数据保存完成后,再将此临时文件改名为RDB文件,如果有前一次保存的RDB文件则会被替换，最后关闭<br>此子进程<br>由于Redis只保留最后一个版本的RDB文件,如果想实现保存多个版本的数据,需要人为实现<br></code></pre></td></tr></table></figure><h4 id="实现-RDB-方法"><a href="#实现-RDB-方法" class="headerlink" title="实现 RDB 方法"></a>实现 RDB 方法</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">save: 同步,不推荐使用，使用主进程完成快照，因此会阻塞其它命令执行<br>bgsave: 异步后台执行,不影响其它命令的执行，会开启独立的子进程，因此不会阻赛其它命令执行<br>配置文件实现自动保存: 在配置文件中制定规则,自动执行bgsave<br></code></pre></td></tr></table></figure><h4 id="RDB-模式的优缺点"><a href="#RDB-模式的优缺点" class="headerlink" title="RDB 模式的优缺点"></a>RDB 模式的优缺点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">优点:<br>RDB快照只保存某个时间点的数据，恢复的时候直接加载到内存即可，不用做其他处理，这种文件适合用于做灾备处理.可以通过自定义时间点执行redis指令bgsave或者save保存快照，实现多个版本的备份<br>比如: 可以在最近的<span class="hljs-number">24</span>小时内，每小时备份一次RDB文件，并且在每个月的每一天，也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到指定的不同的版本。<br>RDB在大数据集时恢复的速度比AOF方式要快<br><br>缺点:<br>不能实时保存数据，可能会丢失自上一次执行RDB备份到当前的内存数据<br>如果需要尽量避免在服务器故障时丢失数据，那么RDB并不适合。虽然Redis允许设置不同的保存点（save point）来控制保存RDB文件的频率，但是，因为RDB文件需要保存整个数据集的状态，所以它可能并不是一个非常快速的操作。因此一般会超过<span class="hljs-number">5</span>分钟以上才保存一次RDB文件。在这种情况下，一旦发生故障停机，就可能会丢失较长时间的数据。<br>在数据集比较庞大时，fork()子进程可能会非常耗时，造成服务器在一定时间内停止处理客户端请求,如果数据集非常巨大，并且CPU时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒或更久。另外子进程完成生成RDB文件的时间也会花更长时间.<br></code></pre></td></tr></table></figure><h4 id="AOF-工作原理"><a href="#AOF-工作原理" class="headerlink" title="AOF 工作原理"></a>AOF 工作原理</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">AOF 即 AppendOnlyFile，AOF 和 RDB 都采有COW机制<br>AOF 可以指定不同的保存策略,默认为每秒钟执行一次 fsync,按照操作的顺序地将变更命令追加至指定的AOF日志文件尾部<br>在第一次启用AOF功能时，会做一次完全备份，后续将执行增量性备份，相当于完全数据备份+增量变化<br>如果同时启用RDB和AOF,进行恢复时,默认AOF文件优先级高于RDB文件,即会使用AOF文件进行恢复<br>在第一次开启AOF功能时,会自动备份所有数据到AOF文件中,后续只会记录数据的更新指令<br>注意: AOF 模式默认是关闭的,第一次开启AOF后,并重启服务生效后,会因为AOF的优先级高于RDB,而AOF默认没有数据文件存在,从而导致所有数据丢失<br></code></pre></td></tr></table></figure><h4 id="AOF-模式优缺点"><a href="#AOF-模式优缺点" class="headerlink" title="AOF 模式优缺点"></a>AOF 模式优缺点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">优点:<br>数据安全性相对较高，根据所使用的fsync策略(fsync是同步内存中redis所有已经修改的文件到存储设备)，默认是appendfsync everysec，即每秒执行一次 fsync,在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据( fsync会在后台线程执行，所以主线程可以继续努力地处理命令请求)<br><br>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中不需要seek, 即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，可以通过 redis<span class="hljs-literal">-check-aof</span> 工具来解决数据一致性的问题<br><br>Redis可以在 AOF文件体积变得过大时，自动地在后台对AOF进行重写,重写后的新AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis在创建新 AOF文件的过程中，append模式不断的将修改数据追加到现有的 AOF文件里面，即使重写过程中发生停机，现有的 AOF文件也不会丢失。而一旦新AOF文件创建完毕，Redis就会从旧AOF文件切换到新AOF文件，并开始对新AOF文件进行追加操作。<br><br>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，也可以通过该文件完成数据的重建<br><br>AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此 AOF文件的内容非常容易被人读懂，对文件进行分析(parse)也很轻松。导出（export)AOF文件也非常简单:举个例子，如果不小心执行了FLUSHALL.命令，但只要AOF文件未被重写，那么只要停止服务器，移除 AOF文件末尾的FLUSHAL命令，并重启Redis ,就可以将数据集恢复到FLUSHALL执行之前的状态。<br><br>缺点:<br>即使有些操作是重复的也会全部记录，AOF 的文件大小一般要大于 RDB 格式的文件<br>AOF 在恢复大数据集时的速度比 RDB 的恢复速度要慢<br>如果 fsync 策略是appendfsync no, AOF保存到磁盘的速度甚至会可能会慢于RDB<br>bug 出现的可能性更多<br></code></pre></td></tr></table></figure><h4 id="RDB和AOF-的选择"><a href="#RDB和AOF-的选择" class="headerlink" title="RDB和AOF 的选择"></a>RDB和AOF 的选择</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">如果主要充当缓存功能,或者可以承受较长时间,比如数分钟数据的丢失, 通常生产环境一般只需启用RDB即可,此也是默认值<br>如果一点数据都不能丢失,可以选择同时开启RDB和AOF<br>一般不建议只开启AOF<br></code></pre></td></tr></table></figure><h4 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">```<br><br>!!!!![](../image/企业级 NoSQL 数据库 Redis/image<span class="hljs-literal">-20250403102953994</span>.png)<br><br><span class="hljs-comment">#### 字符串 string</span><br><br>```powershell<br><br><br></code></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>含义</th><th>复杂度</th></tr></thead><tbody><tr><td>set key value</td><td>设置 key-value</td><td>o(1)</td></tr><tr><td>get key</td><td>获取 key-value</td><td>o(1)</td></tr><tr><td>del key</td><td>删除 key-value</td><td>o(1)</td></tr><tr><td>setnx setxx</td><td>根据 key 是否存在设置 key-value</td><td>o(1)</td></tr><tr><td>Incr decr</td><td>计数</td><td>o(1)</td></tr><tr><td>mget mset</td><td>批量操作 key-value</td><td>o(n)</td></tr></tbody></table><h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Redis列表实际就是简单的字符串数组，按照插入顺序进行排序.<br>支持双向读写,可以添加一个元素到列表的头部（左边）或者尾部（右边），一个列表最多可以包含<br><span class="hljs-number">2</span>^<span class="hljs-number">32</span><span class="hljs-literal">-1</span>=<span class="hljs-number">4294967295</span>个元素<br>每个列表元素用下标来标识,下标 <span class="hljs-number">0</span> 表示列表的第一个元素，以 <span class="hljs-number">1</span> 表示列表的第二个元素，以此类推。<br>也可以使用负数下标，以 <span class="hljs-literal">-1</span> 表示列表的最后一个元素， <span class="hljs-literal">-2</span> 表示列表的倒数第二个元素，元素值可以重复，常用于存入日志等场景，此数据类型比较常用<br>列表特点<br>有序<br>value可重复<br>左右都可以操作<br></code></pre></td></tr></table></figure><h4 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">Set</span> 是一个无序的字符串合集<br>同一个集合中的每个元素是唯一无重复的<br>支持在两个不同的集合中对数据进行逻辑处理，常用于取交集,并集,统计等场景,例如: 实现共同的朋友<br>集合特点<br>无序<br>无重复<br>集合间操作<br></code></pre></td></tr></table></figure><p>集合间操作</p><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250403144145286.png)</p><h4 id="有序集合-sorted-set"><a href="#有序集合-sorted-set" class="headerlink" title="有序集合 sorted set"></a>有序集合 sorted set</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Redis有序集合和Redis集合类似，是不包含相同字符串的合集。<br>它们的差别是，每个有序集合的成员都关联着一个双精度浮点型的评分<br>这个评分用于把有序集合中的成员按最低分到最高分排序。<br>有序集合的成员不能重复,但评分可以重复,一个有序集合中最多的成员数为 <span class="hljs-number">2</span>^<span class="hljs-number">32</span> - <span class="hljs-number">1</span>=<span class="hljs-number">4294967295</span>个，经常用于排行榜的场景<br><br>有序集合特点<br>有序<br>无重复元素<br>每个元素是由score和value组成<br>score 可以重复<br>value 不可以重复<br></code></pre></td></tr></table></figure><h4 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 hash"></a>哈希 hash</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">hash 即字典, 用于保存字符串字段field和字符串值value之间的映射，即key/value做为数据部分<br>hash特别适合用于存储对象场景.<br>一个hash最多可以包含<span class="hljs-number">2</span>^<span class="hljs-number">32</span><span class="hljs-literal">-1</span> 个key/value键值对<br>哈希特点<br>无序<br>K/V 对<br>适用于存放相关的数据<br></code></pre></td></tr></table></figure><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">消息队列: 把要传输的数据放在队列中,从而实现应用之间的数据交换<br>常用功能: 可以实现多个应用系统之间的解耦,异步,削峰/限流等<br>常用的消息队列应用: Kafka,RabbitMQ,Redis<br><br>消息队列分为两种<br>生产者/消费者模式: Producer/Consumer<br>发布者/订阅者模式: Publisher/Subscriber<br></code></pre></td></tr></table></figure><h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">生产者消费者模式下，多个消费者同时监听一个频道(redis用队列实现)，但是生产者产生的一个消息只能被最先抢到消息的一个消费者消费一次,队列中的消息由可以多个生产者写入，也可以有不同的消费者取出进行消费处理.此模式应用广泛<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250403150503960.png)</p><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250403150507961.png)</p><h4 id="发布者订阅模式"><a href="#发布者订阅模式" class="headerlink" title="发布者订阅模式"></a>发布者订阅模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">在发布者订阅者Publisher/Subscriber模式下，发布者Publisher将消息发布到指定的频道channel，事先监听此channel的一个或多个订阅者Subscriber都会收到相同的消息。即一个消息可以由多个订阅者获取到. 对于社交应用中的群聊、群发、群公告等场景适用于此模式<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250403150805071.png)</p><h4 id="Redis-集群与高可用"><a href="#Redis-集群与高可用" class="headerlink" title="Redis 集群与高可用"></a>Redis 集群与高可用</h4><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250403160351355.png)</p><h4 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h4><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250403160414640.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">主从复制架构<br>Redis和MySQL的主从模式类似，也支持主从模式（master/slave），可以实现Redis数据的跨主机的远程备份<br>常见客户端连接主从的架构:<br>程序APP先连接到高可用性 LB 集群提供的虚拟IP，再由LB调度将用户的请求至后端Redis 服务器来真正提供服务<br><br>主从复制的特点:<br>一个master可以有多个slave<br>一个slave只能有一个master<br>数据流向是从master到slave单向的<br>master 可读可写<br>slave 只读<br></code></pre></td></tr></table></figure><h4 id="主从复制实现"><a href="#主从复制实现" class="headerlink" title="主从复制实现"></a>主从复制实现</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">当master出现故障后,可以自动提升一个slave节点变成新的Mster,因此Redis Slave 需要设置和master相同的连接密码<br>此外当一个Slave提升为新的master时需要通过持久化实现数据的恢复<br>当配置Redis复制功能时，强烈建议打开主服务器的持久化功能。否则主节点Redis服务应该要避免自动启动。<br></code></pre></td></tr></table></figure><h4 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">使用哨兵 Sentinel 只能解决Redis高可用问题，实现Redis的自动故障转移,但仍然无法解决Redis Master单节点的性能瓶颈问题<br>为了解决单机性能的瓶颈，提高Redis 服务整体性能，可以使用分布式集群的解决方案<br><br></code></pre></td></tr></table></figure><h4 id="Redis-Cluster-架构"><a href="#Redis-Cluster-架构" class="headerlink" title="Redis Cluster 架构"></a>Redis Cluster 架构</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Redis cluster 需要至少 <span class="hljs-number">3</span>个master节点才能实现,slave节点数量不限<br>Master节点必须要超过半数以上可用,否则集群将不可用,即数据访问和选举将无法实现<br>因此Master节点的数据一般为奇数<br>当然一般每个master都至少对应的有一个slave节点<br>如果有三个主节点采用哈希槽 hash slot 的方式来分配<span class="hljs-number">16384</span>个槽位 slot<br>此三个节点分别承担的slot 区间可以是如以下方式分配<br>节点M1 <span class="hljs-number">0</span>－<span class="hljs-number">5460</span><br>节点M2 <span class="hljs-number">5461</span>－<span class="hljs-number">10922</span><br>节点M3 <span class="hljs-number">10923</span>－<span class="hljs-number">16383</span><br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250408092030864.png)</p><h4 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">如果是单机存储的话，直接将数据存放在单机redis就行了。但是如果是集群存储，就需要考虑到数据分区了。<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250408092223317.png)</p><h5 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">redis cluster设置有<span class="hljs-number">0</span>~<span class="hljs-number">16383</span>的槽，每个槽映射一个数据子集，通过hash函数，将数据存放在不同的槽位中，每个集群的节点保存一部分的槽。<br>每个key存储时，先经过算法函数CRC16(key)得到一个整数，然后整数与<span class="hljs-number">16384</span>取余，得到槽的数值，然后找到对应的节点，将数据存放入对应的槽中。<br></code></pre></td></tr></table></figure><h4 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">当有新的节点准备好加入集群时，这个新的节点还是孤立节点，加入有两种方式。一个是通过集群节点<br>执行命令来和孤立节点握手，另一个则是使用脚本来添加节点。<br><span class="hljs-number">1</span>. cluster_node_ip:port: cluster meet ip port new_node_ip:port<br><span class="hljs-number">2</span>. redis<span class="hljs-literal">-trib</span>.rb <span class="hljs-built_in">add-node</span> new_node_ip:port cluster_node_ip:port<br>通常这个新的节点有两种身份，要么作为主节点，要么作为从节点：<br>主节点：分摊槽和数据<br>从节点：作故障转移备份<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250408092613912.png)</p><h4 id="槽的迁移"><a href="#槽的迁移" class="headerlink" title="槽的迁移"></a>槽的迁移</h4><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250408092629280.png)</p><h4 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h4><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250408092647812.png)</p><h4 id="下线节点的流程"><a href="#下线节点的流程" class="headerlink" title="下线节点的流程"></a>下线节点的流程</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1</span>. 判断该节点是否持有槽，如果未持有槽就跳转到下一步，持有槽则先迁移槽到其他节点<br><span class="hljs-number">2</span>. 通知其他节点（cluster forget）忘记该下线节点<br><span class="hljs-number">3</span>. 关闭下线节点的服务<br><br>需要注意的是如果先下线主节点，再下线从节点，会进行故障转移，所以要先下线从节点。<br></code></pre></td></tr></table></figure><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">集群同样具备了自动转移故障的功能，和哨兵有些类似，在进行客观下线之后，就开始准备让故障节点的从节点“上任”了。<br>首先是进行资格检查，只有具备资格的从节点才能参加选举：<br>故障节点的所有从节点检查和故障主节点之间的断线时间<br>超过cluster<span class="hljs-literal">-node-timeout</span> * cluster<span class="hljs-literal">-slave-validati-factor</span>(默认<span class="hljs-number">10</span>)则取消选举资格<br>然后是准备选举顺序，不同偏移量的节点，参与选举的顺位不同。offset最大的slave节点，选举顺位最<br>高，最优先选举。而offset较低的slave节点，要延迟选举。<br></code></pre></td></tr></table></figure><h4 id="Redis-Cluster-部署架构说明"><a href="#Redis-Cluster-部署架构说明" class="headerlink" title="Redis Cluster 部署架构说明"></a>Redis Cluster 部署架构说明</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">注意: 建立Redis Cluster 的节点需要清空数据，另外网络中不要有Redis哨兵的主从，否则也可能会干扰集群的创建及扩缩容<br></code></pre></td></tr></table></figure><h6 id="生产环境：6台服务器，分别是三组master-slave，适用于生产环境"><a href="#生产环境：6台服务器，分别是三组master-slave，适用于生产环境" class="headerlink" title="生产环境：6台服务器，分别是三组master&#x2F;slave，适用于生产环境"></a>生产环境：6台服务器，分别是三组master&#x2F;slave，适用于生产环境</h6><h4 id="集群扩容-1"><a href="#集群扩容-1" class="headerlink" title="集群扩容"></a>集群扩容</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">当前客户量激增，现有的Redis cluster架构已经无法满足越来越高的并发访问请求，为解决此问题,新购置两台服务器，要求将其动态添加到现有集群，但不能影响业务的正常访问。<br>新版支持集群中有旧数据的情况进行扩容<br>注意: 生产环境一般建议master节点为奇数个,比如:<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,以防止脑裂现象<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250408111540336.png)</p><p>!!!!![](..&#x2F;image&#x2F;企业级 NoSQL 数据库 Redis&#x2F;image-20250408111555862.png)</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密和安全及时间同步服务</title>
    <link href="/2025/06/09/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8%E5%8F%8A%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1/"/>
    <url>/2025/06/09/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8%E5%8F%8A%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="加密和安全及时间同步服务"><a href="#加密和安全及时间同步服务" class="headerlink" title="加密和安全及时间同步服务"></a>加密和安全及时间同步服务</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs ada">数字加密组合:<br> 每种加密算法都有优缺点,所以使用的时候需要综合使用.<br> 非对称加密算法组合使用：数字签名+非对称加密传输<br><br>实现数据加密:(实现数据加密，无法验证数据完整性和来源)<br>  实现数据加密，无法验证数据完整性和来源  <br>    A 向 B 传输数据，A和B 分别获取彼此的公钥信息。，协商对称加密秘钥信息Key<br>      A发送数据： 使用 B的公钥(BPk)加密 秘钥key，然后用对称加密key对数据data加密<br>      Key(data)+BPk(key)  XXXXXX<span class="hljs-comment">--------------------------&gt; B</span><br> <br>      B 收到信息后，用B自己的 私钥进行解密，<br>        - 获取对称加密算法key，然后使用key对加密数据进行解密。<br>        - 最终获取A发送过来的真正数据 data。<br>  劣势:因为bpk是公开的<br>      对称的key是BPK加密的整体都也可以被伪造<br>      对于数据来源没有任何验证<br><br>实现数字签名:(不加密数据，可以保证数据来源的可靠性、数据的完整性和一致性)<br>  A 向 B 传输数据，A和B 分别获取彼此的公钥信息。<br>    A发送数据： 使用摘要算法计算data内容的hash值，使用 A的私钥(ASk)加密 hash值<br>    data+ASk(hash[data]) <span class="hljs-comment">--------------------------&gt; B</span><br> <br>    B 收到信息后，<br>      - 用A的 公钥进行解密，获取data内容的原始hash值<br>      - B使用摘要算法对内容date进行hash值计算，然后对比两个hash值是否一致<br>      - 两个hash值一样的话，说明数据没有被修改，而且可以保证数据来源。         <br><br>综合加密:(即实现数据加密，又可以保证数据来源的可靠性、数据的完整性和一致性) <br>  A发送数据<br>    - 使用摘要算法对数据data进行摘要算法,然后使用A的私钥对hash值进行数字签名<br>    - 使用B公钥对 数字签名+数据内容 进行加密。<br> <br>  B接收数据<br>    - 使用B的公钥对数据解密，获取 数字签名+数据内容<br>    - B通过A的公钥进行解密，获取原始hash值<br>    - B对数据内容进行摘要算法，获取hash值<br>    - B 对两个hash值进行比较判断。<br>    <br> 综合签名:(对称key&#123;ASk[hash(data)]+data&#125;+Pb(对称key))   <br>   A发送数据<br>     - 使用摘要算法对数据data进行摘要算法,然后使用A的私钥对hash值进行数字签名<br>     - 使用对称秘钥对 数字签名+数据内容 进行加密<br>     - 使用B公钥对 对称加密算法 进行加密。<br> <br>   B接收数据<br>     - 使用B的私钥对数据解密，获取 对称秘钥key<br>     - B 使用解析的 对称秘钥key 进行解密，获取 数字签名+数据内容<br>     - B 使用A的公钥解密，获取 原始hash值<br>     - B 对数据内容进行摘要算法，获取hash值<br>     - B 对两个hash值进行比较判断。     <br>    <br>CA和证书:    <br>  Linux的CA（Certificate Authority）认证是一种用于确保网络通信安全的技术。CA认证，即证书颁发机构认证，是一种通过数字证书来验证通信双方身份的技术。在Linux系统中，CA认证通常依赖于OpenSSL库来实现加密和签名功能。数字证书由CA机构颁发，用于证明证书持有者的身份，并加密网络通信。    <br>  主要作用：<br>    身份验证：通过验证证书持有者的身份，确保通信双方的身份真实可靠。<br>    数据加密：通过加密网络通信，保护数据传输的安全性和完整性。<br>    数据签名：通过数字签名，确保数据的完整性和不可篡改性。<br>    <br>  涉及的证书：<br>    证书授权机构的证书、服务器证书、用户证书       <br>CA认证流程:<br>  安装OpenSSL库：OpenSSL库是Linux CA认证的核心组件，用于实现加密和签名功能。<br>  生成私钥和公钥：使用OpenSSL命令生成私钥和公钥。私钥用于签名，公钥用于验证签名。<br>  生成CA证书：使用私钥对包含公钥和用户身份信息的证书签名请求（CSR）进行签名，生成CA证书。<br>  安装CA证书：将生成的CA证书复制到适当的目录，供系统或其他应用程序使用。<br>  <br>SSL/TLS  <br>  主要功能:<br>    数据加密：SSL/TLS协议能够对传输的数据进行加密，从而防止数据在传输过程中被窃听或篡改。<br>    身份验证：通过证书认证机制，SSL/TLS协议可以确保通信双方的身份真实可靠。<br>    数据完整性：传送的消息包括消息完整性检查（如使用MAC），以确保数据在传输过程中未被篡改    <br>  应用场景:(SSL/TLS协议广泛应用于各种需要保障网络通信安全的场景)<br>     Web浏览器与服务器之间的通信：通过HTTPS协议，确保用户浏览网页时的数据安全。<br>     电子邮件客户端与服务器之间的通信：通过SMTPS、IMAPS等协议，确保邮件传输过程中的数据安全。<br>     移动应用与服务器之间的通信：通过HTTPS或其他安全协议，确保移动应用与服务器之间的数据传输安全。    <br>  <br>openssl(Openssl功能主要包括对称加密（DES、<span class="hljs-number">3</span>DES、AES等），非对称加密（RSA），散列（MD5、SHA1等）以及证书的相关操作（创建、申请、颁发、吊销等）。)<br>  软件组成:<br>  libcrypto：<br>    具有通用功能的加密库，包含了众多加密算法，如AES、DES、RSA等，用于加密和解密数据，以及生成<br>和管理密钥。<br>  libssl：<br>    实现SSL/TLS协议的客户端与服务器端功能，为网络通信提供加密隧道，确保数据在传输过程中的安全性。<br>  openssl：<br>    一个多功能的命令行工具，允许用户执行从密钥生成到进行复杂的SSL/TLS测试等一系列操作。它提供了丰富的命令和选项，方便用户进行加密、解密、签名、验证等操作   <br><br><br><br><br>      <br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8%E5%8F%8A%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1/image_-c_yAZc7ji.png"></p><p>!!!!<img src="/../image/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8%E5%8F%8A%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1/image_ZT_u5KlUA5.png"></p><p>!!!!<img src="/../image/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8%E5%8F%8A%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1/image_u14Auhdnuj.png"></p><p>!!!!<img src="/../image/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8%E5%8F%8A%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1/image_hSGIRtA3HZ.png"></p><p>!!!!<img src="/../image/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8%E5%8F%8A%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1/image_EoD3y-sBxJ.png"></p><p>!!!!<img src="/../image/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8%E5%8F%8A%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1/image_1ygevUk5Ik.png"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>方法</title>
    <link href="/2025/06/09/%E6%96%B9%E6%B3%95/"/>
    <url>/2025/06/09/%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h3 id="方法的概念"><a href="#方法的概念" class="headerlink" title="方法的概念:"></a>方法的概念:</h3><p>方法（method）是程序中最小的执行单元</p><p>①方法必须先创建才可以使用，该过程成为方法定义</p><p>②方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用</p><h2 id="方法的定义和调用"><a href="#方法的定义和调用" class="headerlink" title="方法的定义和调用"></a>方法的定义和调用</h2><h4 id="无参数方法定义和调用"><a href="#无参数方法定义和调用" class="headerlink" title="无参数方法定义和调用"></a>无参数方法定义和调用</h4><p>代码格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public static void 方法名 (   ) &#123;<br>     方法体;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">方法名();<br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        playGame();<br>    &#125;<br>   public static void playGame()&#123;<br>       System.out.println(&quot;开始&quot;);<br>       System.out.println(&quot;选择&quot;);<br>       System.out.println(&quot;退出&quot;);<br>   &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%96%B9%E6%B3%95/image_e5JuKb5g5I.png"></p><p>注意:方法必须先定义，后调用，否则程序将报错</p><h4 id="无参数方法"><a href="#无参数方法" class="headerlink" title="无参数方法:"></a>无参数方法:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public static void main(String[] args) &#123;<br>       getMax();<br>   &#125;<br>  public static void getMax()&#123;<br>       int a=10;<br>       int b=20;<br>       if (a&gt;b)&#123;<br>           System.out.println(a);<br>       &#125;else&#123;<br>           System.out.println(b);<br>       &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%96%B9%E6%B3%95/image_PekplihvMK.png"></p><h3 id="带参数方法定义和调用"><a href="#带参数方法定义和调用" class="headerlink" title="带参数方法定义和调用"></a>带参数方法定义和调用</h3><p>代码格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public static void 方法名 (参数1) &#123;<br>  方法体;<br>&#125;<br><br>public static void 方法名 (参数1, 参数2, 参数3...) &#123;<br>  方法体;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">方法名(参数)；<br><br>方法名(参数1,参数2);<br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public static void main(String[] args) &#123;<br>       getSum(10,20);<br>   &#125;<br>  public static void getSum(int num1,int num2)&#123;<br>     int result=num1+num2;<br>      System.out.println(result);<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%96%B9%E6%B3%95/image_cHWeAGLhou.png"></p><p>注意:①方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错&#x20;</p><p>②方法定义时，多个参数之间使用逗号( ，)分隔</p><p>③方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错</p><h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3><ol><li>形参：全称形式参数.指方法定义中的参数</li><li>实参：全称实际参数.方法调用中的参数&#x20;</li></ol><p>&#x20;     &#x20;</p><h4 id="带参数方法"><a href="#带参数方法" class="headerlink" title="带参数方法"></a>带参数方法</h4><p>示例:设计一个方法用于打印两个数中的较大数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public static void main(String[] args) &#123;<br>       getMax(10,20);<br>   &#125;<br>  public static void getMax(int a,int b)&#123;<br>       if (a&gt;b)&#123;<br>           System.out.println(a);<br>       &#125;else&#123;<br>           System.out.println(b);<br>       &#125;<br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%96%B9%E6%B3%95/image_H5kgLP6DRz.png"></p><h3 id="带返回值方法定义和调用"><a href="#带返回值方法定义和调用" class="headerlink" title="带返回值方法定义和调用"></a>带返回值方法定义和调用</h3><p>代码格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public static 数据类型 方法名 ( 参数 ) &#123; <br>  return 数据 ;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">方法名 ( 参数 ) ;<br>数据类型 变量名 = 方法名 ( 参数 ) ;<br></code></pre></td></tr></table></figure><p>示例:求商行全年营业额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public static void main(String[] args) &#123;<br>        int sum1 = getSum(10, 20, 30);<br>        int sum2 = getSum(20, 30, 40);<br>        int sum3 = getSum(50, 60, 70);<br>        int sum4 = getSum(60, 50, 40);<br>        int sum = sum1 + sum2 + sum3 + sum4;<br>        System.out.println(sum);<br>    &#125;<br>    public static int getSum(int month1,int month2,int month3)&#123;<br>        int sum = month1 + month2 + month3;<br>        return sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%96%B9%E6%B3%95/image_TqDtL7MvmA.png"></p><h3 id="方法的注意事项"><a href="#方法的注意事项" class="headerlink" title="方法的注意事项:"></a>方法的注意事项:</h3><p>方法不能嵌套定义</p><p>void表示无返回值，可以省略return，也可以单独的书写return，后面不加数据,return语句后面不能跟数据或代码</p><h4 id="方法的通用格式"><a href="#方法的通用格式" class="headerlink" title="方法的通用格式:"></a>方法的通用格式:</h4><p>代码格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public static 返回值类型 方法名(参数) &#123;<br>   方法体; <br>   return 数据 ;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码解释:</p><p>public static 修饰符</p><p>返回值类型 方法操作完毕之后返回的数据的数据类型</p><p>方法名 调用方法时候使用的标识</p><p>参数 由数据类型和变量名组成，多个参数之间用逗号隔开</p><p>方法体 完成功能的代码块</p><p>return 如果方法操作完毕，有数据返回，用于把数据返回给调用者</p><p>注意:方法操作完毕之后是否有数据返回，如果没有，写void；如果有，写对应的数据类型</p><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p><ol><li>多个方法在同一个类中</li><li>多个方法具有相同的方法名</li><li>多个方法的参数不相同，类型不同或者数量不同</li></ol><p>注意:</p><ol><li>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</li><li>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载</li></ol><p>代码格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class MethodDemo &#123;<br>  public static void fn(int a) &#123;<br>      //方法体<br>    &#125;<br>    public static int fn(double a) &#123;<br>      //方法体<br>    &#125;<br>&#125;<br><br>public class MethodDemo &#123;<br>  public static float fn(int a) &#123;<br>      //方法体<br>    &#125;<br>    public static int fn(int a , int b) &#123;<br>      //方法体<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法的基本内存原理"><a href="#方法的基本内存原理" class="headerlink" title="方法的基本内存原理"></a>方法的基本内存原理</h3><p>方法传递的基本数据类型的内存原理(用自己的)</p><p><img src="/../image/%E6%96%B9%E6%B3%95/image_WRwtMfXkfv.png"></p><p>方法传递引用数据类型的内存原理(拿别人得去用)</p><p><img src="/../image/%E6%96%B9%E6%B3%95/image_Gp5c1VYsw_.png"></p><p><img src="/../image/%E6%96%B9%E6%B3%95/image_9LXWkmAIUl.png"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>磁盘存储和文件管理</title>
    <link href="/2025/06/09/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2025/06/09/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="磁盘存储和文件管理"><a href="#磁盘存储和文件管理" class="headerlink" title="磁盘存储和文件管理"></a>磁盘存储和文件管理</h1><h2 id="1-磁盘存储"><a href="#1-磁盘存储" class="headerlink" title="1. 磁盘存储"></a>1. 磁盘存储</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada">磁盘存储：<br> <span class="hljs-number">1</span>. 磁盘数据存储：<br>      <span class="hljs-comment">-- 包括分区和格式化</span><br> <span class="hljs-number">2</span>. 磁盘数据的使用：<br>      - 挂载<br><br>存储类型：<br>  - 块存储<br>  - 文件系统存储<br>  - 对象存储<br></code></pre></td></tr></table></figure><h2 id="2-MBR-ZBR"><a href="#2-MBR-ZBR" class="headerlink" title="2. MBR &amp; ZBR"></a>2. MBR &amp; ZBR</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">MBR（Master Boot <span class="hljs-keyword">Record</span>）：<br>  - 作用：硬盘的第一个扇区（<span class="hljs-number">0</span>道<span class="hljs-number">0</span>头<span class="hljs-number">1</span>扇区），包含主引导程序和分区表。<br>  - 关键性：是计算机启动的关键，包含引导代码，能够加载操作系统，并告知硬盘分区信息。<br><br>ZBR（Zoned Bit Recording）：<br>  - 定义：一种物理优化硬盘存储空间的方法。<br>  - 特点：不再采用每个磁道扇区数固定的方式，而是依据磁道半径不同，将更多扇区分布在外部磁道，<br>    以获得更大存储空间；外部磁道数据传输速度快于内部磁道，因为单位时间扫过的扇区数更多。<br></code></pre></td></tr></table></figure><h2 id="3-磁盘的两种寻址方式"><a href="#3-磁盘的两种寻址方式" class="headerlink" title="3. 磁盘的两种寻址方式"></a>3. 磁盘的两种寻址方式</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ada">CHS（Cylinder-Head-Sector，柱面-磁头-扇区）：<br>  - 又称<span class="hljs-number">3</span>D模式，通过柱面号、磁头号和扇区号唯一确定一个扇区的位置。<br>  - 特性：<br>      - 采用<span class="hljs-number">24</span>位寻址：前<span class="hljs-number">10</span>位表示cylinder，中间<span class="hljs-number">8</span>位表示head，后<span class="hljs-number">6</span>位表示sector；<br>      - 最大寻址空间约<span class="hljs-number">8</span>GB（计算公式：<span class="hljs-number">2</span>^<span class="hljs-number">24</span> * <span class="hljs-number">512</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> ≈ <span class="hljs-number">8</span>G）；<br>      - 是硬盘最早采用的寻址模式之一。<br><br>LBA（Logical Block Addressing，逻辑块寻址）：<br>  - 定义：使用连续、线性的逻辑块号来定位数据，每个逻辑块通常为<span class="hljs-number">512</span>字节（可因系统或文件系统不同而变化）。<br>  - 特性：<br>      - 直接指定逻辑块号进行数据定位，并可转换成CHS格式完成具体寻址；<br>      - ATA-<span class="hljs-number">1</span>规范定义了<span class="hljs-number">28</span>位寻址模式（上限约<span class="hljs-number">128</span> GiB）；ATA-<span class="hljs-number">6</span>采用<span class="hljs-number">48</span>位寻址模式（上限可达<span class="hljs-number">128</span> Petabytes）；<br>      - 现代硬盘中，LBA已成为主流寻址方式，不受传统CHS限制。<br></code></pre></td></tr></table></figure><hr><h2 id="4-磁盘相关命令"><a href="#4-磁盘相关命令" class="headerlink" title="4. 磁盘相关命令"></a>4. 磁盘相关命令</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ada">【文件系统查看工具 - df】：<br>  命令格式：df [OPTION]... [FILE]...<br>  常用选项：<br>    - -l|<span class="hljs-comment">--local          # 只显示本机文件系统</span><br>    - -h|<span class="hljs-comment">--human-readable # 以方便阅读的格式显示</span><br>    - -T|<span class="hljs-comment">--print-type     # 显示文件系统类型</span><br><br>【目录信息统计工具 - du】：<br>  命令格式：du [OPTION]... [FILE]...<br>             du [OPTION]... <span class="hljs-comment">--files0-from=F</span><br>  常用选项：<br>    - -s|<span class="hljs-comment">--summarize      # 只显示外层目录</span><br>    - -h|<span class="hljs-comment">--human-readable # 以方便阅读的格式显示</span><br><br>【文件定制工具 - dd】：<br>  命令格式：dd [OPERAND]... 或 dd OPTION<br>  常用示例：<br>    dd <span class="hljs-keyword">if</span>=/PATH/FROM/SRC <span class="hljs-keyword">of</span>=/PATH/TO/DEST bs=N count=N<br>  读取文件示例：<br>    - 对于大于<span class="hljs-number">2</span>K的二进制文件fileA，从第<span class="hljs-number">64</span>字节开始读取<span class="hljs-number">128</span> Bytes；<br>    - 对于fileB，将读取到的<span class="hljs-number">128</span> Bytes写入从第<span class="hljs-number">32</span>字节开始的位置（替换<span class="hljs-number">128</span> Bytes）：<br>      dd <span class="hljs-keyword">if</span>=fileA <span class="hljs-keyword">of</span>=fileB bs=<span class="hljs-number">1</span> count=<span class="hljs-number">128</span> skip=<span class="hljs-number">63</span> seek=<span class="hljs-number">31</span> conv=notrunc<br></code></pre></td></tr></table></figure><hr><h2 id="5-存储管理"><a href="#5-存储管理" class="headerlink" title="5. 存储管理"></a>5. 存储管理</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">当获取一块物理磁盘时，在服务器中使用磁盘空间的基本步骤：<br> <span class="hljs-number">1</span>. 设备分区<br> <span class="hljs-number">2</span>. 创建文件系统<br> <span class="hljs-number">3</span>. 挂载新的文件系统<br><br>常见分区类型：<br>  - 主分区（引导分区）：最大容量&lt;=<span class="hljs-number">4</span>T，最多创建<span class="hljs-number">4</span>个；<br>  - 扩展分区：用于创建多个逻辑分区（数量不受限制），通常用于非引导分区。<br></code></pre></td></tr></table></figure><hr><h2 id="6-分区实现的方法"><a href="#6-分区实现的方法" class="headerlink" title="6. 分区实现的方法"></a>6. 分区实现的方法</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ada">MBR &amp; GPT：<br>  - MBR：<br>      - 最多支持<span class="hljs-number">4</span>个主分区，或<span class="hljs-number">3</span>个主分区加<span class="hljs-number">1</span>个扩展分区（扩展分区下可创建多个逻辑分区）。<br>      - 使用<span class="hljs-number">32</span>位LBA，最大可寻址空间约<span class="hljs-number">2</span>TB（<span class="hljs-number">2</span>^<span class="hljs-number">32</span>扇区，每扇区<span class="hljs-number">512</span>字节）。<br>      - 分区结构：<br>          - <span class="hljs-number">446</span> bytes: boot loader（启动代码）<br>          - <span class="hljs-number">64</span> bytes: 分区表（每<span class="hljs-number">16</span> bytes描述一个分区）<br>          - <span class="hljs-number">2</span> bytes: 标识位<span class="hljs-number">55</span>AA<br>      - 说明：MBR分区表大小固定，仅能描述最多<span class="hljs-number">4</span>个分区。<br>  <br>  - GPT：<br>      - 支持最多<span class="hljs-number">128</span>个分区（在Windows中）；<br>      - 使用<span class="hljs-number">64</span>位LBA，理论上最大容量可达<span class="hljs-number">9.4</span>ZB（<span class="hljs-number">1</span>ZB=<span class="hljs-number">1024</span>^<span class="hljs-number">7</span>字节），远超MBR限制。<br><br>其他信息：<br>  - 查看磁盘标志位命令：hexdump -n <span class="hljs-number">512</span> -Cv /dev/nvme0n1 | tail -<span class="hljs-number">5</span><br>  - BIOS（文字界面）与EFI（图形界面，功能多）的区别；<br>  - 常见组合：BIOS+MBR 与 UEFI+GPT。<br></code></pre></td></tr></table></figure><hr><h2 id="7-分区表破坏实验"><a href="#7-分区表破坏实验" class="headerlink" title="7. 分区表破坏实验"></a>7. 分区表破坏实验</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 备份MBR分区表：<br>   - 创建目录：<span class="hljs-built_in">mkdir</span> /data<br>   - 命令：<span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/nvme0n1 of=/data/dpt.img bs=1 count=64 skip=446<br>   - 查看备份文件（应为64 bytes）：ll /data/dpt.img<br>   - 检查硬盘前512字节：hexdump -vC -n 512 /dev/sda | <span class="hljs-built_in">tail</span> -n6<br><br>2. 破坏MBR分区表：<br>   - 命令：<span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/dev/sda bs=1 count=64 seek=446<br>   - 注意：前446字节为系统启动区域，清零后系统无法启动。<br>   - 再次检查前512字节确认（应显示MBR信息已清零）。<br><br>3. 重启主机，系统启动失败。<br></code></pre></td></tr></table></figure><hr><h2 id="8-Linux系统修复方式"><a href="#8-Linux系统修复方式" class="headerlink" title="8. Linux系统修复方式"></a>8. Linux系统修复方式</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span>. 救援模式：<br>   - 光盘救援模式：<br>       (<span class="hljs-number">1</span>) 重启Rocky主机，进入救援模式：<br>            - 方法<span class="hljs-number">1</span>：启动后按Esc键，进入临时启动调整页面，选择CD-ROM后按Enter（临时性调整）。<br>            - 方法<span class="hljs-number">2</span>：通过安全固件永久调整启动顺序，但后续需恢复原设置。<br>       (<span class="hljs-number">2</span>) 将启动方式调整为光盘启动（Shift + 将CD-ROM调整到第一位，然后F10保存）。<br>       (<span class="hljs-number">3</span>) 启动后选择Troubleshooting选项。<br>       (<span class="hljs-number">4</span>) 选择 <span class="hljs-string">&quot;Rescue a Rocky Linux system&quot;</span>。<br>       (<span class="hljs-number">5</span>) 选择 <span class="hljs-string">&quot;Skip to shell&quot;</span>。<br>       (<span class="hljs-number">6</span>) 分区表修复：从远端主机使用scp获取备份分区表（例如：scp root@<span class="hljs-number">10.0</span>.<span class="hljs-number">0.157</span>:~/dpt.img ./）。<br>       (<span class="hljs-number">7</span>) 恢复MBR分区表：dd <span class="hljs-keyword">if</span>=dpt.img <span class="hljs-keyword">of</span>=/dev/nvme0n1 bs=<span class="hljs-number">1</span> count=<span class="hljs-number">64</span> seek=<span class="hljs-number">446</span><br>       (<span class="hljs-number">8</span>) 关机；<br>       (<span class="hljs-number">9</span>) 恢复原BIOS启动顺序。<br><br><span class="hljs-number">2</span>. 根据平台环境进行其他修复操作。<br><span class="hljs-number">3</span>. 修复后重启系统。<br></code></pre></td></tr></table></figure><hr><h2 id="9-fdisk和lsblk"><a href="#9-fdisk和lsblk" class="headerlink" title="9. fdisk和lsblk"></a>9. fdisk和lsblk</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">【fdisk】：<br>  - 用途：操作和管理分区（默认采用MBR分区方式）。<br>  - 命令格式：fdisk [options] &lt;disk&gt;<br>    常用选项：<br>      - -l 或 --list：显示分区列表<br>  - 示例：fdisk /dev/sda<br>      - p：输出分区列表<br>      - n：创建新分区<br>      - d：删除分区<br>      - w：保存并退出<br>      - q：不保存退出<br>  - 非交互式操作示例：<br>      <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&#x27;n\np\n\n\n+10G\nw&#x27;</span> | fdisk /dev/sda<br>      <span class="hljs-built_in">echo</span> -e <span class="hljs-string">&#x27;d\n\nd\n\nd\n\nw&#x27;</span> | fdisk /dev/sda<br><br>【gdisk】：<br>  - 用途：GPT分区管理工具（建议在未用fdisk操作过的盘上使用）。<br>  - 安装：yum install gdisk<br>  - 常用命令：<br>      - n：新建分区<br>      - c：修改分区名<br>      - o：创建新的分区表<br>      - w：保存退出<br>      - d：删除分区<br>      - q：退出<br><br>【lsblk】：<br>  - 用途：查看设备信息。<br>  - 命令格式：lsblk [options] [&lt;device&gt; ...]<br>    常用选项：<br>      - -f 或 --fs：显示文件系统信息<br></code></pre></td></tr></table></figure><hr><h2 id="10-文件系统管理"><a href="#10-文件系统管理" class="headerlink" title="10. 文件系统管理"></a>10. 文件系统管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">【mkfs】：<br>  - 格式化文件系统。<br>  - 命令格式：mkfs [options] [-t &lt;<span class="hljs-built_in">type</span>&gt;] [fs-options] &lt;device&gt; [&lt;size&gt;]<br>  - 示例：<br>      mkfs -t ext4  (等价于 mkfs.ext4)<br>      mkfs -t xfs   (等价于 mkfs.xfs)<br><br>【mke2fs】：<br>  - 专用于ext系列文件系统的管理工具。<br>  - 命令格式：mke2fs [OPTION]... DEVICE<br>    - 使用 -t 指定文件系统类型（ext2、ext3、ext4）。<br><br>【blkid】：<br>  - 查看块设备属性信息。<br>  - 命令格式：blkid [OPTION]... [DEVICE]<br>      - -U UUID：根据UUID查找设备<br>      - -L LABEL：根据LABEL查找设备<br><br>【磁盘标签管理】：<br>  - 添加标签：e2label /dev/sdb1 rock1-host1-ssd1<br>  - 删除标签：e2label /dev/sdb1 <span class="hljs-string">&quot;&quot;</span><br><br>【查找文件系统】：<br>  - findfs：适用于ext系列，例如：findfs UUID=<span class="hljs-string">&quot; &quot;</span><br></code></pre></td></tr></table></figure><hr><h2 id="11-挂载基础"><a href="#11-挂载基础" class="headerlink" title="11. 挂载基础"></a>11. 挂载基础</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">【挂载文件系统】：<br>  - 命令格式：mount 源文件系统（设备） 目标挂载点（必须是预先存在的空目录）<br><br>【卸载文件系统】：<br>  - 命令格式：umount [-f] [-l] [-n] 挂载点或设备<br><br>【挂载规则】：<br>  - 同一挂载点同时只能挂载一个设备。<br>  - 若同一挂载点挂载多个设备，只显示最后一个设备的数据，其它被隐藏。<br>  - 同一设备可同时挂载到多个挂载点，但只有最后一个生效。<br><br>【获取挂载信息】：<br>  - 查看文件系统信息：lsblk -f &lt;设备名&gt;<br>  - 查看所有挂载文件系统：<span class="hljs-built_in">df</span> 或 <span class="hljs-built_in">df</span> -Th<br>  - 查看详细挂载情况：mount | grep ...<br><br>【特殊场景】：<br>  - 查看正在访问文件系统的进程：lsof 挂载点 或 fuser -v 挂载点<br>  - 强制终止访问进程：fuser -km 挂载点<br><br>【持久挂载】：<br>  1. 编辑 /etc/fstab 文件，添加挂载信息，格式：<br>         &lt;设备&gt; &lt;挂载点&gt; &lt;文件系统类型&gt; &lt;挂载选项&gt; &lt;dump&gt; &lt;fsck&gt;<br>     - 设备可用UUID或设备名指定，挂载点必须存在。<br>  2. 保存后验证配置：mount -a 或 mount -o remount<br>  3. 重启系统后配置生效。<br></code></pre></td></tr></table></figure><hr><h2 id="12-交换分区"><a href="#12-交换分区" class="headerlink" title="12. 交换分区"></a>12. 交换分区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">【场景与基础知识】：<br>  - 交换分区（Swap Partition）：用于虚拟内存管理，当物理内存不足时，<br>    操作系统将暂不使用的数据从RAM移动到交换分区以释放内存。<br>  - 应用场景：主要用于内存较低（2-16GB）的系统，但现代系统对swap使用已逐渐减少。<br><br>【创建Swap】：<br>  1. 创建一个swap文件（使用 mkswap 命令，并在挂载时指定为swap）；<br>  2. 或使用 fdisk 创建标识为 swap 的分区。<br><br>【管理Swap】：<br>  - 开启swap：swapon -a<br>  - 关闭swap：swapoff -a<br>      - 删除 /etc/fstab 中的 swap 行（例如使用 sed 命令）或注释掉。<br><br>【交换分区策略】：<br>  - 参数 /proc/sys/vm/swappiness 决定内核对swap的使用倾向：<br>      - 值越高，内核越倾向于使用swap；值越低，则更保留物理内存。<br>      - 当内存使用率达到 100 - swappiness 时，系统开始考虑使用swap。<br>      - 可设为0以最大限度减少swap使用，但不完全禁止。<br>  - 查看策略：<span class="hljs-built_in">cat</span> /proc/sys/vm/swappiness<br>  - 禁用示例：编辑 /etc/sysctl.conf（设置 vm.swappiness = 0）后执行 sysctl -p<br><br>【查看Swap空间】：<br>  - 使用 free -m 查看内存和swap的使用情况<br><br>【Buffer与Cache】：<br>  - Buffer：写缓存<br>  - Cache：读缓存<br></code></pre></td></tr></table></figure><hr><h2 id="13-RAID（磁盘整列）"><a href="#13-RAID（磁盘整列）" class="headerlink" title="13. RAID（磁盘整列）"></a>13. RAID（磁盘整列）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">【RAID卡】：<br>  - RAID Controller（磁盘阵列控制器），也称为RAID卡，是专为存储阵列设计的硬件接口卡。<br>  - 作用：通过物理层或逻辑层实现数据冗余，提高数据的可靠性和性能。<br>  - 应用场景：适用于数据库服务器、在线交易处理系统、备份与恢复等高可靠性、高性能环境。<br><br>【RAID基础】：<br>  - 工作原理：在多个磁盘上分布数据，实现数据冗余和并行读写，从而提升传输速度和存储性能。<br>  - 简单来说，RAID将多个硬盘组合为一个逻辑硬盘，实现容错与加速。<br></code></pre></td></tr></table></figure><hr><h2 id="14-RAID类型与LVM"><a href="#14-RAID类型与LVM" class="headerlink" title="14. RAID类型与LVM"></a>14. RAID类型与LVM</h2><h3 id="14-1-LVM（Logical-Volume-Manager）"><a href="#14-1-LVM（Logical-Volume-Manager）" class="headerlink" title="14.1 LVM（Logical Volume Manager）"></a>14.1 LVM（Logical Volume Manager）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">- 定义：LVM是Linux系统下用于管理磁盘分区的一种机制，在硬盘分区和文件系统之间增加逻辑层，<br>  为文件系统屏蔽物理分区布局，提供一个抽象的卷组。<br>- 应用：Rocky Linux和Ubuntu等系统默认采用LVM管理，逻辑卷通常以 /dev/dm-# 形式显示。<br><br>【注意】：<br>  - dm（device mapper）将一个或多个块设备组织为逻辑设备，<br>    逻辑卷以软链接形式展示，如 /dev/mapper/VG_NAME-LV_NAME 或 /dev/VG_NAME/LV_NAME。<br><br>【使用流程】：<br>  <span class="hljs-number">1.</span> 准备磁盘<br>  <span class="hljs-number">2.</span> 创建物理卷（pvcreate）<br>  <span class="hljs-number">3.</span> 创建卷组（vgcreate）<br>  <span class="hljs-number">4.</span> 创建逻辑卷（lvcreate）<br>  <span class="hljs-number">5.</span> 格式化并挂载<br><br>【扩缩容】：<br>  - 增加物理磁盘后，可创建新PV加入VG并扩展LV；<br>  - 缩减LV操作风险较高，建议备份数据后进行。<br></code></pre></td></tr></table></figure><h3 id="14-2-命令操作"><a href="#14-2-命令操作" class="headerlink" title="14.2 命令操作"></a>14.2 命令操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">【物理卷操作】：<br>  - 查看：pvs（简要）、pvdisplay（详细）<br>  - 创建：pvcreate /dev/DEVICE<br>  - 删除：pvremove<br><br>【卷组操作】：<br>  - 查看：vgs（简要）、vgdisplay（详细）<br>  - 创建：vgcreate [-s Size] vgname pv1 [pv2...]<br>  - 删除：vgremove<br><br>【逻辑卷操作】：<br>  - 查看：lvs（简要）、lvdisplay（详细）、lvscan<br>  - 创建：lvcreate &#123;-L N[mMgGtT] | -l N&#125; -n NAME VolumeGroup<br>  - 删除：lvremove<br><br>【硬件RAID vs 软件LVM】：<br>  - RAID：从物理磁盘角度实现冗余；<br>  - LVM：从应用角度实现灵活存储管理。<br></code></pre></td></tr></table></figure><hr><h2 id="15-物理存储介质解读"><a href="#15-物理存储介质解读" class="headerlink" title="15. 物理存储介质解读"></a>15. 物理存储介质解读</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 定义：存储设备（如硬盘）构成存储系统的最低层单元。<br><br>【术语解析】：<br><span class="hljs-bullet">  -</span> PV（Physical Volume）：LVM管理的最底层，可为整块硬盘或硬盘分区，加入LVM前需进行特殊处理。<br><span class="hljs-bullet">  -</span> VG（Volume Group）：建立在一个或多个PV之上，形成一个管理单元，类似传统物理硬盘。<br><span class="hljs-bullet">  -</span> LV（Logical Volume）：建立在VG之上，类似传统分区，可在其上建立文件系统并挂载使用。<br><br>【细节说明】：<br><span class="hljs-bullet">  -</span> PE（Physical Extent）：PV中可分配的最小存储单元，默认为4MB，建立卷组时确定且不可更改，所有PV的PE大小必须一致。<br><span class="hljs-bullet">  -</span> LE（Logical Extent）：LV中最小分配单元，与卷组中的PE一一对应。<br><br>【关联关系】：<br><span class="hljs-bullet">  -</span> 每个PV被划分为多个PE，供LVM分配使用；<br><span class="hljs-bullet">  -</span> 每个LV被划分为多个LE，与VG中PE对应；<br><span class="hljs-bullet">  -</span> VG由多个PV构成，LV建立在VG上，未分配空间可用于扩展LV。<br><br>整体来看，PE、LE、PV、VG与LV构成了LVM的分层管理架构，实现了存储资源的灵活高效管理。<br></code></pre></td></tr></table></figure><hr><h2 id="16-LV-扩缩容"><a href="#16-LV-扩缩容" class="headerlink" title="16. LV 扩缩容"></a>16. LV 扩缩容</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">【扩展逻辑卷】：<br>  - 前提：确保卷组中有足够未分配空间。<br>  - 扩展方式1：<br>      1. 扩展LV：lvextend -L [+]N[mMgGtT] /dev/VG_NAME/LV_NAME<br>      2. 扩展文件系统：<br>            - ext系列：resize2fs /dev/VG_NAME/LV_NAME<br>            - xfs：xfs_growfs MOUNTPOINT<br>  - 扩展方式2（一键扩展）：<br>      lvresize -r -l +100%FREE /dev/VG_NAME/LV_NAME<br><br>【缩减逻辑卷】（风险较高，建议备份后操作）：<br>  1. 取消挂载：umount /dev/VG_NAME/LV_NAME<br>  2. 文件系统检查：e2fsck -f /dev/VG_NAME/LV_NAME<br>  3. 缩减文件系统：resize2fs /dev/VG_NAME/LV_NAME N[mMgGtT]<br>  4. 缩减LV：lvreduce -L [-]N[mMgGtT] /dev/VG_NAME/LV_NAME<br>  5. 重新挂载：mount /dev/VG_NAME/LV_NAME mountpoint<br>  - 注：步骤3+4可合并为 lvreduce -L N[mMgGtT] -r /dev/VG_NAME/LV_NAME<br></code></pre></td></tr></table></figure><hr><h2 id="17-如何转移或移除物理磁盘"><a href="#17-如何转移或移除物理磁盘" class="headerlink" title="17. 如何转移或移除物理磁盘"></a>17. 如何转移或移除物理磁盘</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">步骤：<br><span class="hljs-bullet"> 1.</span> 检查目标磁盘状态，确认是否有数据需要转移。<br><span class="hljs-bullet"> 2.</span> 将目标磁盘从卷组（VG）中移除（使用 vgreduce 命令）。<br><span class="hljs-bullet"> 3.</span> 迁移数据：例如使用 pvmove /dev/sdb1 将数据迁移到其他物理卷。<br><span class="hljs-bullet"> 4.</span> 根据需要，移除或重新配置目标磁盘。<br></code></pre></td></tr></table></figure><hr><h2 id="18-LVM快照"><a href="#18-LVM快照" class="headerlink" title="18. LVM快照"></a>18. LVM快照</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">逻辑卷快照：<br>  - 是LVM中的一项功能，允许用户对逻辑卷进行备份或创建特定时间点的副本。<br>  - 工作机制：基于写时复制（Copy-On-Write, COW），在创建时对原逻辑卷数据进行精确拷贝，但不实时复制所有数据。<br></code></pre></td></tr></table></figure><hr><h1 id="总结与注意事项"><a href="#总结与注意事项" class="headerlink" title="总结与注意事项"></a>总结与注意事项</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 磁盘存储与分区管理：<br>  - 了解不同存储类型及寻址方式（CHS与LBA）对系统配置和性能优化至关重要。<br>  - 选择MBR或GPT应基于磁盘容量和系统支持情况。<br><br>- 分区操作与修复：<br>  - 定期备份分区表，避免因操作失误导致数据丢失。<br>  - 使用救援模式及工具（fdisk、gdisk、lsblk）在系统故障时进行快速修复。<br><br>- 文件系统与挂载：<br>  - 格式化、标签管理和挂载选项直接影响数据访问效率与系统性能。<br>  - 持久挂载配置应正确设置 /etc/fstab，确保系统重启后自动挂载。<br><br>- 交换分区、RAID与LVM：<br>  - 虽然现代系统对swap的依赖减少，但其配置（如swappiness）仍需关注。<br>  - RAID提供数据冗余与性能加速，LVM实现灵活存储管理，两者合理配置可大幅提升系统可靠性与效率。<br><br>- 操作风险提示：<br>  - 在进行分区、格式化、LV扩缩容等操作前，务必做好完整数据备份。<br></code></pre></td></tr></table></figure><p>RAID（磁盘整列）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">RAID卡:[程序]<br>    RAID Controller（磁盘阵列控制器），通常被称为磁盘阵列卡或RAID卡。RAID卡是一种专为存储阵<br>        列而设计的硬件接口卡，它通过物理层或逻辑层实现数据冗余，提高了数据的可靠性和性能。<br>    适用于需要高可靠性和高性能的存储环境，如数据库服务器、在线交易处理系统、备份和恢复等场景。特<br>         别适合需要高可用性和数据保护的环境，如关键任务系统。<br> RAID基础：<br>     RAID的工作原理是在多个磁盘上分配数据，并以标准化方式促进输入/输出操作的重叠。通过将数据分布<br>     在多个磁盘上，RAID技术可以实现数据冗余，提高容错能力，并在多个磁盘上并行读写数据，从而提升数据传<br>     输速度和存储性能。简单来说，RAID把多个硬盘组合成为一个逻辑硬盘。<br> <br>   <br>   <br><br><br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image_-3PZ7YOTVD.png"></p><p>!!!!<img src="/../image/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image_l8vyMLtCAP.png"></p><p>!!!!<img src="/../image/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image_NtaHy_Y62a.png"></p><p>!!!!<img src="/../image/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image_D7lAmYgQMQ.png"></p><p>!!!!<img src="/../image/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%92%8C%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/image_Nx4U0U1Ths.png"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络协议和通信</title>
    <link href="/2025/06/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/"/>
    <url>/2025/06/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="网络协议和通信"><a href="#网络协议和通信" class="headerlink" title="网络协议和通信"></a>网络协议和通信</h1><p>网络基础</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs markdown">计算机网络是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统、网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。<br><br>计算机网络组成：硬件|软件<br><br>计算机网络类型：<br><span class="hljs-code">    局域网：</span><br><span class="hljs-code">      在小区域内使用的，由多台计算机组成的网络，覆盖范围通常局限在10千米范围之内，属于一个单位或部门组建的小范围网。</span><br><span class="hljs-code">    城域网：</span><br><span class="hljs-code">      作用范围在广域网与局域网之间的网络，其网络覆盖范围通常可以延伸到整个城市，借助通信光纤将多个局域网联通公用城市网络形成大型网络，使得不仅局域网内的资源可以共享，局域网之间的资源也可以共享。</span><br><span class="hljs-code">    广域网：</span><br><span class="hljs-code">      一种远程网，涉及长距离的通信，覆盖范围可以是一个国家或多个国家，甚至整个世界。由于广域网地理上的距离可以超过几千千米，所以信息衰减非常严重，这种网络一般要租用专线，通过接口信息处理协议和线路连接起来，构成网状结构，解决寻径问题。</span><br><span class="hljs-code"></span><br>网络特性：<br><span class="hljs-code">    一般特性</span><br><span class="hljs-code">        成本|安全性|可靠性|可用性|可扩展性</span><br><span class="hljs-code">    常见特性</span><br><span class="hljs-code">        速度</span><br><span class="hljs-code">          </span><br><span class="hljs-code">网络组成：</span><br><span class="hljs-code">    网络是由节点和链路构成，节点根据位置的不同划分为：</span><br><span class="hljs-code">        边缘节点：包括主机、服务器等，用来构成终端系统。（客户端和服务器）</span><br><span class="hljs-code">        中间节点：包括集线器、交换机等，用来构成通信子网。（网络设备）</span><br><span class="hljs-code"> </span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><p>网络拓扑</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown">网络拓扑是指网络中各个节点之间的连接方式和布局。常见的网络拓扑结构包括星型、总线型、环型等。不同的网络拓扑结构具有不同的特点，如星型拓扑结构具有易于管理和扩展的优点，但成本相对较高；总线型拓扑结构则具有成本低、易于布线的优点，但可靠性和扩展性相对较差。因此，在选择网络拓扑结构时，需要根据具体的应用场景和需求进行权衡。<br>  <br>  星型拓扑结构:<br> 所有设备通过独立的链路连接到一个中央节点（如交换机或集线器）。中央节点负责控制网络中的数据流向，决定哪个设备接收数据。故障隔离性好, 单个设备的故障不会影响其他设备的正常工作。如果中央节点发生故障，整个网络将中断。<br><span class="hljs-bullet">    -</span> 适合家庭网络、小型企业网络以及那些需要易于管理和高可靠性的局域网络（LAN）<br>   <br>   总线型拓扑结构<br> 所有设备连接到一条主干线（总线），每个设备通过共享主干线发送和接收数据。布线简单,只需要一条主干线，布线较为经济。主干线故障会导致整个网络瘫痪。<br><span class="hljs-bullet">     -</span> 常见于早期的以太网，但由于其扩展性差和故障风险高，如今使用较少。<br>   <br>   环型拓扑结构<br> 设备连接成一个闭合的环形，每个设备只与其相邻的两个设备连接。数据沿着环路单向或双向传输，直到到达目标设备。数据传输顺畅, 数据包以预定方向传输，减少了碰撞。如果一个设备或连接发生故障，整个网络可能瘫痪。<br><span class="hljs-bullet">     -</span> 适用于带宽需求较为稳定、设备数量相对固定的网络场景，如部分局域网和光纤分布数据接口（FDDI）网络。<br>   <br>   网状拓扑结构<br> 每个设备都与网络中其他设备相连，可以是部分网状拓扑或全网状拓扑（每个设备都有到其他设备的连接）。多重连接使得即使某些链路或设备故障，网络仍然可以正常运行。成本和复杂度相对较高：由于需要多个连接和更复杂的配置。<br><span class="hljs-bullet">     -</span> 适用于需要高可靠性和冗余的场景，如数据中心、大型企业网络以及军事和安全网络。<br>   <br>   树型拓扑结构-扩展星型拓扑<br> 结合了星型和总线型拓扑的特点。它有一个主干链路，从主干上分出多个星型子网，形成层次结构。网络层次分明，易于扩展和管理，而且一个子网的故障不会影响其他子网。但主干线故障可能导致整个网络瘫痪，尤其是在大型网络中，布线会变得复杂。<br><span class="hljs-bullet">       -</span> 通常用于大型企业网络和校园网络，尤其是那些需要将多个小型网络（子网）连接在一起的场景。<br>   <br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_ONXH00nH7L.png"></p><p>网络分层</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs markdown">基础知识  <br>   网络分层是实现网络通信的基础框架，它通过将复杂的网络通信过程分解为不同的层次来简化设计，每个层次负责不同的功能，以实现网络通信的有效管理和协调，从而实现提高可扩展性和灵活性。常见的网络分层模型有OSI七层模型和TCP/IP四层模型等。<br> <br> 分层模型<br><span class="hljs-code">    osi七层模型（主要是为了理解）： 物理层、数据链路层、网络层、传输层、会话层、表示层和应用层 </span><br><span class="hljs-code">         物理层： </span><br><span class="hljs-code">            负责传输比特流，提供物理连接和传输介质，如电缆、光缆等。</span><br><span class="hljs-code">            包括了针脚、电压、线缆规范、集线器、中继器、主机接口卡等。</span><br><span class="hljs-code">         数据链路层： </span><br><span class="hljs-code">            在相邻的两个节点之间建立、维持和释放数据链路，进行差错控制和流量控制。</span><br><span class="hljs-code">            例如以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</span><br><span class="hljs-code">         网络层： </span><br><span class="hljs-code">            为分组交换网上的不同主机提供通信服务，实现网络互联和路由选择。</span><br><span class="hljs-code">            例如:互联网协议（IP）等。</span><br><span class="hljs-code">         传输层： </span><br><span class="hljs-code">            为应用程序提供端到端的通信服务，确保数据在传输过程中的完整性和可靠性。</span><br><span class="hljs-code">            例如:传输控制协议（TCP）等。</span><br><span class="hljs-code">         会话层： </span><br><span class="hljs-code">            负责建立、管理和终止会话，实现数据同步等功能。</span><br><span class="hljs-code">         表示层： </span><br><span class="hljs-code">            负责数据的表示和转换，确保数据在不同系统之间的兼容性。</span><br><span class="hljs-code">         应用层： </span><br><span class="hljs-code">            为应用软件提供网络服务，如文件传输、电子邮件等。</span><br><span class="hljs-code">            例如: HTTP、HTTPS、FTP、TELNET、SSH、SMTP、POP3、MySQL等</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    TCP/IP五层模型：应用层 传输层 网际层 数据链路层 物理层 </span><br><span class="hljs-code">    </span><br><span class="hljs-code">    TCP/IP四层模型：应用层 传输层 网际层 网络接口层</span><br><span class="hljs-code">       网络接口层（相当于OSI的物理层和数据链路层）：负责物理连接和数据链路层的功能，如帧的封装和解封装等。</span><br><span class="hljs-code">       网络层：与OSI模型的网络层功能相同，负责路由选择和分组转发。</span><br><span class="hljs-code">       传输层：与OSI模型的传输层功能相同，负责端到端的数据传输和流量控制。</span><br><span class="hljs-code">       应用层：与OSI模型的应用层功能相同，为用户提供网络服务，如HTTP、FTP等。</span><br><span class="hljs-code">    </span><br><span class="hljs-code"> </span><br></code></pre></td></tr></table></figure><p><img src="/image/image_yPF7vYw4Sq.png" alt="  " title="  "></p><p>通信过程</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs markdown">数据封装和解封装<br><br> 通信模式<br><span class="hljs-code">    单播：</span><br><span class="hljs-code">      单播模式是指每个数据包发往单个目的主机，目的地址指明单个接收接口。</span><br><span class="hljs-code">      这种模式下的数据传递是点对点的，即发送方将数据直接发送给接收方，中间不经过其他节点。</span><br><span class="hljs-code">      单播模式适用于需要个性化服务的应用场景，如流媒体传输等。</span><br><span class="hljs-code">      然而，在客户数量大、每个客户机流量大的情况下，服务器可能会不堪重负。</span><br><span class="hljs-code"> </span><br><span class="hljs-code">    广播：</span><br><span class="hljs-code">      广播模式是指一个主机向网上的所有其他主机发送帧。</span><br><span class="hljs-code">      在这种模式下，网络中所有用户都能接收到该信息。</span><br><span class="hljs-code">      广播模式适用于需要向所有用户发送相同信息的场景，如有线电视网等。</span><br><span class="hljs-code">      然而，当网络中需求该信息的用户量很小时，网络资源利用率将非常低，带宽浪费严重。</span><br><span class="hljs-code"> </span><br><span class="hljs-code">    组播（多播）：</span><br><span class="hljs-code">       组播模式处于单播和广播之间，帧仅传送给属于多播组的多个主机。</span><br><span class="hljs-code">       组播模式能够根据接收者的需求，将数据发送给特定的组，从而实现了数据的按需传输。</span><br><span class="hljs-code">       相比单播来说，使用组播方式传递信息，用户的增加不会显著增加网络的负载。</span><br><span class="hljs-code">       相比广播来说，组播数据仅被传输到有接收者的地方，不会造成网络资源的浪费。</span><br><span class="hljs-code">       组播模式适用于需要向特定用户群体发送相同信息的场景，如视频会议等。</span><br><span class="hljs-code">   </span><br><span class="hljs-code">   域类型</span><br><span class="hljs-code">       冲突域 &amp; 广播域</span><br><span class="hljs-code">          冲突域:</span><br><span class="hljs-code">             两个网络设备同时发送数据，如果发生了冲突，则两个设备处于同一个冲突域，反之，则各自处于不同的冲突域</span><br><span class="hljs-code">          广播域:</span><br><span class="hljs-code">              一个网络设备发送广播，另一个设备收到了，则两个设备处于同一个广播域，反之，则各自处于不同的广播域</span><br><span class="hljs-code">      </span><br><span class="hljs-code">    通信机制        </span><br><span class="hljs-code">       单工通信|半双工通信|全双工通信</span><br><span class="hljs-code">     </span><br><span class="hljs-code">    验证网卡支持的能力</span><br><span class="hljs-code">       mii-tool命令    </span><br><span class="hljs-code">       </span><br><span class="hljs-code">       ethtool命令（rocky ）    </span><br><span class="hljs-code">              </span><br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_z66izUUXw1.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_IzUZ_lQDc3.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_zuYN6fzVkM.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_zOUs9Cmij0.png"></p><p>组网设备</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">路由器<br>  连接不同网络的设备，它根据路由协议和转发表自动转发数据包，实现不同网络之间的通信。<br>交换机<br>  连接局域网（LAN）中的设备，它根据MAC地址转发数据包，实现局域网内部设备之间的快速通信。<br><br><br></code></pre></td></tr></table></figure><p>网络通信</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">网络适配器<br>   网络适配器（Network Interface Card，NIC），又称网卡或网络接口卡，是主机和网络的接口，具有信号转换、数据传输和网络通信等功能。用于协调主机与网络间数据、指令或信息的发送与接收。通过不断的技术创新和升级，网络适配器正在为人们的网络生活提供更加便捷、高效和安全的体验。<br>交换机<br>路由器<br>光猫<br><br><span class="hljs-code">    </span><br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_lCMDL92wdy.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_oCMzeYnf8G.png"></p><p>以太网</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown">MAC地址<br>   MAC地址（Media Access Control Address媒体访问控制地址）是用于标识网络设备的唯一地址，它在局域网（LAN）中起到了重要的作用。而且它是设备在物理网络通信中的唯一识别标识。<br>   MAC地址是一个由48位二进制数字组成的地址，通常以6个十六进制数字表示，是局域网中每一台计算机固化在网卡ROM中的地址。<br>   例如“00:0c:29:b1:f4:54”。MAC地址由两部分组成，前三个字节称为组织唯一标识符（OUI，Organizationally Unique Identifier），用于标识设备的制造商；后三个字节是由制造商分配的设备唯一标识符（DUI，Device Unique Identifier），用于标识具体的设备。<br><br><br><br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_m4fTkZ2y46.png"></p><p>VLAN</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。<br><br></code></pre></td></tr></table></figure><p>分层网络（具体网络具体实施的角度）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">分层网络架构是一种网络设计和构建的方法，它将网络划分为不同的层次，每个层次都有其特定的功能和责任。分层网络架构通过将网络划分为不同的逻辑层次，如核心层、汇聚层和接入层，来实现网络的高效管理、优化性能和增强安全性。这种架构方法旨在简化网络复杂度，提高网络的可扩展性和可维护性。<br><br></code></pre></td></tr></table></figure><p>TCP&#x2F;IP</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java">     TCP/IP：Transmission Control Protocol/Internet Protocol 传输控制协议/因特网互联协议，由于这两个协议在传输层和网络层用的非常的多，所以将这两者提取出来作为传输层+网络层的通信功能代号。所以说，我们一般说的TCP/IP 其实是一个Protocol Stack，包括TCP、IP、UDP、ICMP、RIP、TELNET、FTP、SMTP、ARP等许多协议。<br>  <br>  传输层协议<br>      传输层协议是计算机网络协议体系中的关键部分，主要负责在网络中的不同主机之间提供端到端的通信服务。传输层协议通过确保数据的可靠传输、控制流量和错误处理等功能，使得应用程序能够在网络上有效地进行数据交换。<br>      其中最具有代表性的协议是 TCP 和 UDP<br>    <br>   TCP &amp; UDP <br>        TCP- Transmission Control Protocol 传输控制协议（双连接 两个独立的连接 ） <br>        特点：<br>            TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。在发送数据之前，TCP会先建立连接，并通过三次握手（Three-way Handshake）确保双方都已准备好进行通信。TCP还会使用确认和重传机制来确保数据的可靠传输。<br>         应用场景：<br> TCP适用于需要高可靠性、顺序性和完整性传输的应用，如网页浏览器、电子邮件客户端和文件传输工具等。<br>        UDP - User Datagram Protocol 用户数据报协议 <br>         特点：<br>             UDP是一种无连接的、不可靠的、基于报文的传输层通信协议。UDP在发送数据之前不会建立连接，因此具有较低的开销和延迟。UDP不保证数据的可靠传输、顺序性或完整性，这些任务通常由应用层协议来处理。<br>         应用场景：<br> UDP适用于对实时性要求较高、对可靠性要求不高的应用，如视频流媒体、实时通信（如VoIP）和某些在线游戏等。<br>   <br>   <br>    TCP协议性质： <br>         面向连接：TCP在传输数据之前，需要通过三次握手（Three-way Handshake）过程建立连接，确保通信双方都能够正常接收和发送数据。连接建立后，双方就可以开始传输数据。<br>         可靠性：TCP协议通过多种机制来保证数据传输的可靠性。例如，它使用序列号来确保数据的顺序性，使用确认应答（ACK）来确保数据已被接收，以及使用超时重传机制来处理数据丢失的问题。<br>         流量控制：TCP协议通过滑动窗口协议（Sliding Window Protocol）来实现流量控制，确保发送方不会发送过多的数据导致接收方无法处理。接收方会根据自身的处理能力，动态调整窗口大小，通知发送方可以发送的数据量。<br>         拥塞控制：TCP协议还具备拥塞控制功能，以防止网络因过多数据传输而陷入拥塞状态。它使用慢启动（Slow Start）、拥塞避免（Congestion Avoidance）、快速重传（Fast Retransmit）和快速恢复（Fast Recovery）等算法来动态调整数据传输速率。<br>         全双工通信：TCP连接允许在同一时间内双向传输数据，即发送方和接收方都可以同时发送和接收数据。<br>         字节流服务：TCP协议将数据视为无结构的字节流，不对数据进行分块或组装，只是简单地将数据从一端传输<br>到另一端。   <br>     <br>     UDP协议<br>        UDP协议（User Datagram Protocol，用户数据报协议）是OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议。<br>        UDP协议是在IP数据包服务上增加了一点功能，即为应用程序提供一种以最少的协议机制向其他程序发送消息的协议。UDP的协议号为<span class="hljs-number">17</span>，RFC <span class="hljs-number">768</span>是其正式规范。UDP协议工作在OSI模型的传输层，处于IP协议的上一层。<br>   <br>   <br>   报文解读<br>      IP报文首部  <br>         IP报文首部，即IP头部（IP Header），是IP数据报（IP Datagram）的开头部分，它包含了数据报在传输过程中所需的关键信息。IP报文首部通常由多个字段组成，这些字段以固定的顺序和长度排列。对于IPv4（Internet Protocol Version <span class="hljs-number">4</span>，互联网协议第四版），IP报文首部的长度通常为<span class="hljs-number">20</span>字节，但也可以包含可变长度的选项字段，使得首部总长度最大可达<span class="hljs-number">60</span>字节。<br>      TCP报文首部<br>           TCP（Transmission Control Protocol，传输控制协议）报文的首部是TCP协议实现其可靠传输功能的关键部分。TCP报文首部由固定部分和可变部分（选项部分）组成。固定部分长度为<span class="hljs-number">20</span>字节，包含了TCP连接和传输控制所必需的基本字段；可变部分则根据需要进行扩展，最长可达<span class="hljs-number">40</span>字节，用于实现除TCP报文段头部指定功能外的扩展功能。<br>    <br>    常用字段：<br>       URG（紧急标志字段）：占<span class="hljs-number">1</span>位，表示本报文段中发送的数据是否包含紧急数据。<br>          - 当URG=<span class="hljs-number">1</span>时，表明紧急指针字段有效，表示报文段中有紧急数据需要尽快发送。 <br>        RST（复位标志字段）：占<span class="hljs-number">1</span>位<br>           - 当RST=<span class="hljs-number">1</span>时，表示TCP连接中出现了严重错误，必须释放连接，然后再重新建立传输连接。RST还可以用来拒绝一个非法的报文段或拒绝打开一个连接。       <br>         SYN（同步标志字段）：占<span class="hljs-number">1</span>位，在建立连接时使用，用来同步序号。<br>            - 在连接建立时用来同步序号。当SYN=<span class="hljs-number">1</span>而ACK=<span class="hljs-number">0</span>时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN=<span class="hljs-number">1</span>和ACK=<span class="hljs-number">1</span>。<br>            - SYN=<span class="hljs-number">1</span>，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中SYN才置为<span class="hljs-number">1</span>，<br>带SYN标志的TCP报文段称为同步报文段。<br>         FIN（终止标志字段）：占<span class="hljs-number">1</span>位，表示通知对方本端要关闭连接了，标记数据是否发送完毕。<br>            - 用来释放TCP连接。当FIN=<span class="hljs-number">1</span>时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连<br>接。      <br>                             <br>  <br>  <br>  TCP端口号的范围是从<span class="hljs-number">0</span>到<span class="hljs-number">65535</span>，其中：<br>      知名端口（Well-Known Ports）：<br>          范围从<span class="hljs-number">0</span>到<span class="hljs-number">1023</span>，这些端口号一般固定分配给一些常见的服务。例如，HTTP服务通常使用<span class="hljs-number">80</span>端口，FTP服务使用<span class="hljs-number">20</span>和<span class="hljs-number">21</span>端口（<span class="hljs-number">20</span>端口用于数据传输，<span class="hljs-number">21</span>端口用于命令控制），SMTP服务使用<span class="hljs-number">25</span>端口等。<br>          系统端口或特权端口(仅管理员可用) ，众所周知，永久的分配给固定的系统应用使用，<br> <br>      动态端口（Dynamic Ports）：<br>          范围从<span class="hljs-number">1024</span>到<span class="hljs-number">65535</span>，这些端口号一般不固定分配给某个服务，而是由操作系统动态分配给需要网络通信的进程。<br> 端口信息查看命令  <br>    常用服务及端口对应关系<br>    cat /etc/services<br>    查看非特权用户可以使用起始端口<br>    cat /proc/sys/net/ipv4/ip_unprivileged_port_start<br>    查看客户端动态端口起始<br>    cat /proc/sys/net/ipv4/ip_local_port_range<br>    <br>    <br>    <br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_7vQ1lpscQC.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_btjh11Kob-.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_wRyduBk9p_.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_OBnpZH6YXp.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_Z8dRygQu1I.png"></p><p>三次握手|四次断开</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs markdown">TCP（传输控制协议）的三次握手和四次挥手分别是TCP连接建立和断开的标准过程。<br>   三次握手：（本质上是4次握手、作用：双方都建立正常连接） <br>  第一次握手：<br><span class="hljs-code">    A首先向B发起连接，这时TCP头部中的SYN标识位值为1，然后选定一个初始序号seq=x（一般是随机的），消息发送后，A进入SYN_SENT状态，SYN=1的报文段不能携带数据，但要消耗一个序号。</span><br><span class="hljs-code">  第二次握手：</span><br><span class="hljs-code">    B收到A的连接请求后，同意建立连接，向A发送确认数据，这时TCP头部中的SYN和ACK标识位值均为1，确认序号为ack=x+1，然后选定自己的初始序号seq=y（一般是随机的），确认消息发送后，B进入SYN_RCVD状态，与连接消息一样，这条消息也不能携带数据，同时消耗一个序号。</span><br><span class="hljs-code">  第三次握手：</span><br><span class="hljs-code">    A收到B的确认消息后，需要给B回复确认数据，这时TCP头部中的ACK标识位值为1，确认序号是ack=y+1，自己的序号在连接请求的序号上加1，也就是seq=x+1，此时A进入ESTABLISHED状态，当B收到A的确认回复后，B也进入ESTABLISHED状态，至此TCP成功建立连接，A和B之间就可以通过这个连接互相发送数据了。</span><br><span class="hljs-code"></span><br> 四次断开： <br>  第一次挥手：<br><span class="hljs-code">    A首先向B发送断开连接消息，这时TCP头部中的FIN标识位值为1，序号是seq=m，m为A前面正常发送数据最后一个字节序号加1得到的，消息发送后A进入FNI_WAIT_1状态，FIN=1的报文段不能携带数据，但要消耗一个序号。</span><br><span class="hljs-code">  第二次挥手：</span><br><span class="hljs-code">    B收到A的断开连接请求需要发出确认消息，这时TCP头部中的ACK标识位值为1，确认号为ack=m+1，而自己的序号为seq=n,n为B前面正常发送数据最后一个字节序号加1得到的，然后B进入CLOSE_WAIT状态，此时就关闭了A到B的连接，A无法再给B发数据，但是B仍然可以给A发数据（此处存疑），同时B端通知上方应用层，处理完成后被动关闭连接。然后A收到B的确认信息后，就进入了FIN_WAIT_2状态。</span><br><span class="hljs-code">  第三次挥手：</span><br><span class="hljs-code">    B端应用层处理完数据后，通知关闭连接，B向A发送关闭连接的消息，这时TCP头部中的FIN和ACK标识位值均为1，确认号ack=m+1，自己的序号为seq=k，（B发出确认消息后有发送了一段数据，此处存疑），消息发送后B进入LAST_ACK状态。 </span><br><span class="hljs-code">  第四次挥手：</span><br><span class="hljs-code">    A收到B的断开连接的消息后，需要发送确认消息，这是这时TCP头部中的ACK标识位值为1，确认号ack=k+1，序号为m+1（因为A向B发送断开连接的消息时消耗了一个消息号），然后A进入TIME_WAIT状态，若等待时间经过2MSL后，没有收到B的重传请求，则表明B收到了自己的确认，A进入CLOSED状态，B收到A的确认消息后则直接进入CLOSED状态。至此TCP成功断开连接。  </span><br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_iiQMtlf7zK.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_tpR1zQD_uD.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_NV0wef18Di.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_id66k-hLQg.png"></p><p>进程间通信</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">IPC<br>  IPC（Inter-Process Communication，进程间通信）指的是至少两个进程或线程间传送数据或信号的一些技术或方法。它是操作系统中多进程（或多线程）之间进行通信的一种机制。现存的主流操作系统大都对IPC提供了强有力的支持<br>  常见方法<br><span class="hljs-code">    系统信号（signal）：用于通知进程某个事件已经发生。</span><br><span class="hljs-code">    管道（pipe）：用于具有亲缘关系进程间的数据传递。</span><br><span class="hljs-code">    套接字（socket）：不仅可用于同一台计算机上的进程间通信，   还可用于不同计算机之间的网络通信。</span><br><span class="hljs-code">    文件锁（file lock）：用于进程间对共享文件的同步访问。</span><br><span class="hljs-code">    消息队列（message queue）：允许一个或多个进程向它写入或从中读取消息。</span><br><span class="hljs-code">    信号灯（semaphore，有的地方也称之为信号量）：用于进程间的同步与互斥。</span><br><span class="hljs-code">  </span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><p>IP</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs markdown">基础知识<br>  IP地址（Internet Protocol Address）是指互联网协议地址，又称网际协议地址。IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。<br><br> ipv4 <br>  IPv4使用32位二进制数字表示IP地址，通常呈现为4个由点分开的十进制整数，每个整数的取值范围为0到255。例如，192.168.1.1就是一个常见的IPv4地址。<br>  IPv4的地址空间有限，只有约42亿个地址是可用的。随着互联网的快速发展，IPv4地址空间在数年内就被耗尽。    <br>  特点：<br><span class="hljs-code">    IPv4地址易于理解和配置，已经广泛应用于各种网络环境中。</span><br><span class="hljs-code">    IPv4的地址格式易于扩展，允许不同的设备使用同一IP地址（通过NAT等技术实现）。</span><br><span class="hljs-code">    IPv4的安全性有限，缺乏内置的安全保护机制。</span><br><span class="hljs-code"></span><br> ipv6 <br>  IPv6使用128位二进制数字表示IP地址，地址格式通常呈现为8个由冒号分开的十六进制整数，每个整数的取值范围为0到FFFF。例如，2001:0db8:85a3:0000:0000:8a2e:0370:7334就是一个IPv6地址。<br>  IPv6的地址空间极大，可用的地址数量可以达到3402的39次方，远远超过了IPv4地址空间的极限。  <br>  特点：<br><span class="hljs-code">    IPv6具有更多的地址空间，可以满足不断增长的互联网设备数量。</span><br><span class="hljs-code">    IPv6支持自动配置功能，设备可以自行生成唯一的IPv6地址（如通过SLAAC等方式）。</span><br><span class="hljs-code">    IPv6包含了IPsec协议，提供了更强的安全性，可以在数据传输的各个层面加密数据，保护用户的隐私和机密性。</span><br><span class="hljs-code">    IPv6使用更简洁的报文头格式，降低了网络延迟，提高了数据传输效率。</span><br><span class="hljs-code"></span><br>ipv4地址<br>  IP地址由两部分组成<br><span class="hljs-bullet">    -</span> 网络 ID：标识网络，每个网段分配一个网络ID，处于高位<br><span class="hljs-bullet">    -</span> 主机 ID：标识单个主机，由组织分配给各设备，处于低位<br><span class="hljs-code">    </span><br><span class="hljs-code">ip解读：</span><br><span class="hljs-code">  根据ip地址的应用范围，主要划分为两类：</span><br><span class="hljs-code">    公共IP地址：互联网上设备拥有的唯一地址</span><br><span class="hljs-code">    私有IP地址：不直接用于互联网，通常在局域网中使用</span><br><span class="hljs-code"></span><br>保留地址：<br>  在一个IP地址中，如果主机ID全为0，或主机ID全为1，则该地址是保留地址 如在B类127.16 网段中，172.16.0.0 和 172.16.255.255 为保留地址  <br><span class="hljs-code">     </span><br><span class="hljs-code">子网掩码：（将IP地址拆分成主机位和网络位）</span><br><span class="hljs-code">  32位的数字，和IP成对使用，用来确认IP地址中的网络ID和主机ID，对应网络ID的位为1，对应主机ID的位为0,范例:255.255.255.0 ，表现为连续的高位为1，连续的低位为0   </span><br><span class="hljs-code"> 相关公式：</span><br><span class="hljs-code">    - 一个网络的最多的主机数 ＝2 ^ 主机ID位数 - 2</span><br><span class="hljs-code">    - 网络（段）数 = 2 ^ 网络ID中可变的位数</span><br><span class="hljs-code">    - 网络ID = IP 与 netmask</span><br><span class="hljs-code"> </span><br><span class="hljs-code">子网划分：</span><br><span class="hljs-code">   将一个大的网络（主机数多）划分成多个小的网络（主机数少），主机ID位数变少，网络ID位数变多，网络ID位向主机ID位借n位，将划分2^n个子网 </span><br><span class="hljs-code">   划分子网数=2^(网络ID向主机ID借的位数) </span><br><span class="hljs-code"></span><br><br><br><span class="hljs-code">        </span><br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_fSyhXPCVVd.png"></p><p>!!!!<img src="/../image/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%92%8C%E9%80%9A%E4%BF%A1/image_q2uDpVVKSu.png"></p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>版本管理系统 Git 和 GitLab</title>
    <link href="/2025/06/09/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%20Git%20%E5%92%8C%20GitLab/"/>
    <url>/2025/06/09/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%20Git%20%E5%92%8C%20GitLab/</url>
    
    <content type="html"><![CDATA[<h1 id="版本管理系统-Git-和-GitLab"><a href="#版本管理系统-Git-和-GitLab" class="headerlink" title="版本管理系统 Git 和 GitLab"></a>版本管理系统 Git 和 GitLab</h1><h3 id="DevOps-简介"><a href="#DevOps-简介" class="headerlink" title="DevOps 简介"></a>DevOps 简介</h3><h4 id="软件开发生命周期"><a href="#软件开发生命周期" class="headerlink" title="软件开发生命周期"></a>软件开发生命周期</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">软件开发生命周期SDLC (Software Development Life Cycle)由计划,分析,设计,实现,测试集成和维护组成<br><br>阶段<span class="hljs-number">1</span>: 计划和需求分析 (Planning and Requirement Analysis)<br>每个软件开发生命周期模型都从分析开始，过程的利益相关者讨论对最终产品的要求。此阶段的目标是系统要求的详细定义。此外，还需要确保所有流程参与者都清楚地了解任务以及每个需求将如何实施。通常，讨论涉及质量保证专家，如果有必要，他们甚至可以在开发阶段干预过程中的添加。<br><br>阶段<span class="hljs-number">2</span>: 设计项目架构 (Project Architecture)<br>在软件开发生命周期的第二阶段，开发人员实际上正在设计架构。所有利益相关者（包括客户）都会讨论此阶段可能出现的所有不同技术问题。此外，还定义了项目中使用的技术，团队负载，限制，时间范围和预算。最合适的项目决策是根据定义的要求做出的。<br><br>阶段<span class="hljs-number">3</span>: 开发和编程 (Development and Coding)<br>在批准要求后，该过程进入下一阶段 - 实际开发。程序员从这里开始编写源代码，同时牢记先前定义的需求。系统管理员调整软件环境，前端程序员开发程序的用户界面以及与服务器交互的逻辑。编程本身一般会用四个阶段:算法开发,源代码编写,编译,测试和调试<br><br>阶段<span class="hljs-number">4</span>: 测试 (Testing)<br>测试阶段包括调试过程。开发过程中遗漏的所有代码缺陷都会在此处检测到，记录下来并传回给开发人员进行修复。重复测试过程，直到删除所有关键问题并且软件工作流程稳定。<br><br>阶段<span class="hljs-number">5</span>: 部署 (Deployment)<br>当程序最终确定并且没有关键问题时 - 是时候为最终用户启动它了。新程序版本发布后，技术支持团队加入。该部门提供用户反馈; 在利用期间咨询和支持用户。此外，此阶段还包括所选组件的更新，以确保软件是最新的，并且不会受到安全漏洞的影响。<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419091050092.png)</p><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">该SDLC模型包括完全逐步执行每个阶段。该过程严格记录并预定义，具有该软件开发生命周期模型的每个阶段所期望的功能。<br>类似工厂中流水线的传送带，加工的产品只能按照一道一道的工序向下不断前进，不能后退。<br><br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419091231420.png)</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>简单易用和理解</td><td>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量</td></tr><tr><td>当前一阶段完成后，只需要去关注后续阶段</td><td>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险</td></tr><tr><td>为项目提供了按阶段划分的检查节点</td><td>不适应用户需求的变化</td></tr></tbody></table><h4 id="V-形模型"><a href="#V-形模型" class="headerlink" title="V 形模型"></a>V 形模型</h4><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419091550881.png)</p><h4 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Agile Model 敏捷开发的核心是迭代开发(lterative Development)与增量(IncrementalDevelopment) <br><br><br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419091508872.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">迭代开发:<br>对于大型软件项目，传统的开发方式是采用一个大周期(比如一年或数年)进行开发，整个过程就是一次<span class="hljs-string">&quot;大开发&quot;</span><br>迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次<span class="hljs-string">&quot;大开发&quot;</span>变成多次<span class="hljs-string">&quot;小开发&quot;</span>，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤<br><br>增量开发:<br>软件的每个版本，都会新增一个可以被用户感知到的完整功能。也就是说，按照新增功能来划分迭代。<br></code></pre></td></tr></table></figure><h4 id="DevOps-介绍"><a href="#DevOps-介绍" class="headerlink" title="DevOps 介绍"></a>DevOps 介绍</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">DevOps 即开发 Development 和 Operations运维的缩写。<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419091807419.png)</p><h4 id="持续集成、持续交付和持续部署-CICD"><a href="#持续集成、持续交付和持续部署-CICD" class="headerlink" title="持续集成、持续交付和持续部署 CICD"></a>持续集成、持续交付和持续部署 CICD</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">持续集成 (CI<span class="hljs-literal">-Continuous</span> Integration)<br>持续集成是指多名开发者在开发不同功能代码的过程当中，可以频繁的将代码行合并到一起并切相互不影响工作。很多情况下每天都要进行几次，主要目的是尽早发现集成错误，使团队更加紧密结合，更好地协作。<br>持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。<br><br>持续交付(<span class="hljs-built_in">CD</span><span class="hljs-literal">-Continuous</span> Delivery)<br>持续交付的目标是拥有一个可随时部署到生产环境的代码库。<br>持续交付完成了构建和测试过程细致的自动化，但是如何发布以及发布什么仍然是需要人工操作，持续部署可以改变这一点。<br><br>持续部署(<span class="hljs-built_in">CD</span><span class="hljs-literal">-Continuous</span> Deployment)<br>持续部署可以自动将应用发布到生产环境<br></code></pre></td></tr></table></figure><h4 id="版本控制系统-VCS"><a href="#版本控制系统-VCS" class="headerlink" title="版本控制系统 VCS"></a>版本控制系统 VCS</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell">版本控制（Version control）是维护工程蓝图的标准做法，能追踪工程蓝图从诞生一直到定案的过程<br>版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一程序文件都得到同步<br>软件工程师常利用版本控制来跟踪、维护原始码、文档以及配置文件等的改动<br><br>软件版本控制的方法<br>最简单的情况下，软件设计师可以自己保留一个程序的许多不同版本，并且为它们做适当的编号<br>这种简单的方法曾被用在很多大型的软件项目中<br>虽然可行，但效率较低<br>必须同时维护很多几乎一样的原始码备份，而且极度依赖软件设计师的自我修养与开发纪律<br>使用版本控制系统（Version Control System，VCS），实现部分或全部版本控制工作的自动化，版本控制系统是一种软件，可以帮助软件团队的开发人员协同工作，并存档他们工作的完整历史记录。<br><br>为什么使用 VCS ?<br>在实际开发过程中，经常会有这种需求或问题<br>代码可能被破坏,比如误删除等,希望还能找回<br>代码出现了严重的Bug,希望回滚至数周前的旧代码<br>需要在已经发布的程序中添加新的功能，如果测试验证后没有问题，才会使用新的代码，而在测试验证期间，不能影响原来的代码<br>同一个软件需要有多个版本并行开发,满足不同的应用需求<br>实际项目开发基本都是多个人合作完成，在多个人同时修改同一个源代码文件时可能会发生冲突，如何跟踪记录这些冲突<br>异地源代码备份，使用 VCS 时，需要创建一个 VCS 的远程实例，以在开发人员之间共享更改，这个远程 VCS 实例可以由值得信赖的第三方（如GitHub）进行异地托管；然后，它就会成为安全的异地备份<br></code></pre></td></tr></table></figure><h4 id="版本控制系统分类"><a href="#版本控制系统分类" class="headerlink" title="版本控制系统分类"></a>版本控制系统分类</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">本地版本(单机版)控制系统<br>第一代版本控制系统被称为本地版本控制系统。通过加锁将并发执行转换成顺序执行。 一次只能有一个人处理文件。<br></code></pre></td></tr></table></figure><h6 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h6><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419100744098.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">想要完成任何提交和回滚都依赖于连接集中的代码服务器才能实现,如果无法连接至代码的服务器,比如下班回家后将无法提交代码<br>此外此集中式服务器还存在单点问题，在集中式实例的不可用期间，开发人员就无法推送、合并或回滚代码<br>此方式可以更好的实现软件仓库的安全访问限制和控制<br></code></pre></td></tr></table></figure><h6 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h6><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419101327917.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">在每个用户都有一个完整的服务器，用于保存软件的完整版本，然后再部署一个中央服务器用户可以先将代码提交到本地，没有网络也可以先提交到本地，然后在有网络的时候再提交到中央服务器，这样就大大方便了开发者<br>相比集中式的版本控制系统，工作的时候需要先从中央服务器获取最新的代码，改完之后需要提交，如果是一个比较大的文件则需要足够快的网络才能快速提交完成<br>而使用分布式的版本控制系统，每个用户都是一个完整的版本库，即使没有中央服务器也可以提交代码或者回滚，最终再把改好的代码提交至中央服务器进行合并即可。<br>此方式不容易实现软件仓库的安全访问限制和控制 <br></code></pre></td></tr></table></figure><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Git 重要特性:<br>在本地就可以完成提交,因此不需要网络,提交完成后,可以有网络环境时,再同步到远程仓库服务器<br></code></pre></td></tr></table></figure><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>适合分布式开发，强调个体</td><td>不符合常规思维</td></tr><tr><td>公共服务器压力和数据量都不会太大</td><td>学习难度大，学习周期相对较长</td></tr><tr><td>速度快、灵活</td><td>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息</td></tr><tr><td>任意两个开发者之间可以很容易地解决冲突</td><td>无力支持大型二进制文件</td></tr><tr><td>支持离线工作</td><td>具有大量历史记录的超大型存储库会降低交互速度</td></tr></tbody></table><p>GitLab 网站和软件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">GitLab 官方网站: https://about.gitlab.com/<br><br>Gitlab 的优势<br>开源免费，搭建简单、维护成本较低、可适用于中小型公司内部项目使用。<br>权限管理功能强大灵活，能实现代码对部分人可见，确保项目的安全性。<br>支持离线提交，基于git实现,可以不在实时依赖网络环境进行代码提交。<br></code></pre></td></tr></table></figure><h4 id="常见的软件部署模式"><a href="#常见的软件部署模式" class="headerlink" title="常见的软件部署模式"></a>常见的软件部署模式</h4><h6 id="蓝绿部署-Blue-green-Deployments"><a href="#蓝绿部署-Blue-green-Deployments" class="headerlink" title="蓝绿部署 Blue-green Deployments"></a>蓝绿部署 Blue-green Deployments</h6><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419101906101.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">蓝绿部署指的是不停止老版本代码(不影响上一个版本访问)，而是在另外一套环境部署新版本然后进行测试，测试通过后将用户流量切到新版本，其特点为业务无中断，升级风险相对较小。但本方式成本较高,一般小公司较少使用<br><br>蓝绿色部署是一种部署策略，利用两种相同的环境，即<span class="hljs-string">&quot;蓝色&quot;</span>（又名预发布）环境和<span class="hljs-string">&quot;绿色&quot;</span>（又名生产）环境，具有不同版本的应用程序或服务。质量保证和用户接受度测试通常在承载新版本或更改的蓝色环境中进行。一旦蓝色环境中测试并接受新的变化，用户流量就会从绿色环境切换为蓝色环境。然后，一旦部署成功，您可以切换到新环境。<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">具体过程：<br><span class="hljs-number">1</span>、当前版本(V1)业务正常访问<br><span class="hljs-number">2</span>、在另外一套环境部署新代码版本(V2)，代码可能是增加了功能或者是修复了某些bug<br><span class="hljs-number">3</span>、测试通过之后将用户请求流量切到新版本环境<br><span class="hljs-number">4</span>、观察一段时间，如有异常直接切换旧版本<br><span class="hljs-number">5</span>、下次升级，将旧版本(V2)升级到新版本(V3)<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">蓝绿部署适用的场景：<br><span class="hljs-number">1</span>、不停止老版本，额外部署一套新版本，等测试确认新版本正常后，才将用户请求切换至新版本，如果有问题，切换回老版本<br><span class="hljs-number">2</span>、蓝绿发布是一种用于升级与更新的发布策略，部署的最小维度是容器，而发布的最小维度是应用。<br><span class="hljs-number">3</span>、蓝绿发布对于增量升级有比较好的支持，但是对于涉及数据表结构变更等等不可逆转的升级，并不完全合适用蓝绿发布来实现，需要结合一些业务的逻辑以及数据迁移与回滚的策略才可以完全满足需求。<br></code></pre></td></tr></table></figure><h6 id="金丝雀-灰度-发布-Canary-Deployment"><a href="#金丝雀-灰度-发布-Canary-Deployment" class="headerlink" title="金丝雀(灰度)发布 Canary Deployment"></a>金丝雀(灰度)发布 Canary Deployment</h6><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419102239034.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">金丝雀发布也叫灰度发布，是指在黑与白之间，能够平滑过渡的一种发布方式，灰度发布是增量发布（例如：<span class="hljs-number">2</span>%、<span class="hljs-number">25</span>%、<span class="hljs-number">75</span>%、<span class="hljs-number">100</span>%）进行更新)的一种类型，灰度发布是在原有版本可用的情况下，同时部署一个新版本应用作为“金丝雀”(小白鼠)，测试新版本的性能和表现，以保障整体系统稳定的情况下，尽早发现、调整问题。因此，灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。<br>此方式在实际生产中使用较为普遍<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">金丝雀/灰度发布步骤组成：<br><span class="hljs-number">1</span>、准备好部署各个阶段的工件，包括：构建组件，测试脚本，配置文件和部署清单文件。<br><span class="hljs-number">2</span>、从负载均衡列表中移除掉“金丝雀”服务器（选择全部服务器中的一部分）。<br><span class="hljs-number">3</span>、升级“金丝雀”应用（排掉原有流量并进行部署）。<br><span class="hljs-number">4</span>、对应用进行自动化测试。<br><span class="hljs-number">5</span>、将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）。<br><span class="hljs-number">6</span>、如果“金丝雀”在线使用测试成功，升级剩余的其他服务器。否则就回滚回旧版本<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">金丝雀/灰度发布部署适用的场景：<br><span class="hljs-number">1</span>、不停止老版本，额外搞一套新版本，不同版本应用共存。<br><span class="hljs-number">2</span>、灰度发布中，常常按照用户设置路由权重，例如<span class="hljs-number">90</span>%的用户维持使用老版本，<span class="hljs-number">10</span>%的用户尝鲜新版本。<br><span class="hljs-number">3</span>、经常与A/B测试一起使用，用于测试选择多种方案。<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">灰度发布可以在发布新版本应用时:<br>自定义控制新版本应用流量比重<br>渐进式完成新版本应用的全量上线<br>最大限度地控制新版本发布带来的业务风险<br>降低故障带来的影响<br>同时支持快速回滚<br></code></pre></td></tr></table></figure><h6 id="滚动发布-更新"><a href="#滚动发布-更新" class="headerlink" title="滚动发布(更新)"></a>滚动发布(更新)</h6><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419102419650.png)</p><p>红色：正在更新的实例，正在升级过程中间状态<br>蓝色：更新完成并加入集群的实例,升级完成的新版本<br>绿色：正在运行的实例，升级前的旧版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">滚动发布即逐步升级服务中的节点<br>滚动发布是指每次只升级一个或多个服务实例，升级完成后加入生产环境，不断执行这个过程，直到集群中的全部旧版本升级新版本。<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">滚动发布过程<br><span class="hljs-number">1</span>. 先升级<span class="hljs-number">1</span>个服务实例，主要做部署验证<br><span class="hljs-number">2</span>. 每次升级<span class="hljs-number">1</span>个服务实例，自动从LB上摘掉，升级成功后自动加入集群<br><span class="hljs-number">3</span>. 事先需要有自动更新策略，分为若干次，每次数量/百分比可配置<br><span class="hljs-number">4</span>. 回滚是发布的逆过程，先从LB摘掉新版本，再升级老版本，这个过程一般时间比较长<br><span class="hljs-number">5</span>. 自动化要求高<br></code></pre></td></tr></table></figure><h6 id="A-B测试-A-B-Testing"><a href="#A-B测试-A-B-Testing" class="headerlink" title="A&#x2F;B测试 A&#x2F;B Testing"></a>A&#x2F;B测试 A&#x2F;B Testing</h6><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419102554252.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">A/B测试即同时对外提供两个APP运行环境，这和蓝绿部署的同时只有一个版本在线是不同的<br>A/B 测试是用来测试应用功能表现的方法，例如可用性、受欢迎程度、可见性等等<br>蓝绿部署和A/B测试是不同的,蓝绿部署的目的是安全稳定地发布新版本应用，并在必要时回滚<br>即蓝绿部署是同一时间只有一套正式环境在线，而A/B测试是两套正式环境同时在线，一般用于多个产品竟争时使用<br></code></pre></td></tr></table></figure><h4 id="版本控制系统-Git"><a href="#版本控制系统-Git" class="headerlink" title="版本控制系统 Git"></a>版本控制系统 Git</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><br></code></pre></td></tr></table></figure><h5 id="Git-相关概念和原理"><a href="#Git-相关概念和原理" class="headerlink" title="Git 相关概念和原理"></a>Git 相关概念和原理</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Git 的数据存储从物理上分为当前项目目录和当前项目目录下的隐藏子目录.git，分别称为工作区和版本库<br>Git 版本库逻辑上又分为暂存区和本地仓库<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419113319864.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs powershell">工作区 Workspace：<br>工作区是你当前正在编辑和修改文件的地方。它是你的项目目录 ，通常是对应于&lt;项目目录&gt;在这里你可以添加、修改或删除文件。工作区中的文件可以是已被Git跟踪的文件，也可以是未被跟踪的文件。<br>工作区中的文件的变更不受Git的跟踪和管理，无法实现版本回滚等功能<br>需要将工作的的变更，通过 git add 命令加入暂存区后，才可纳入Git 的版本管理控制的范畴<br><br>暂存区 Staging Area/Index/Cached：<br>也称为索引区,缓存区，用于存储在工作区中对代码进行修改后的文件所保存的地方，只有放入此区的文件才能被git进行管理,使用 git add添加,对应为&lt;项目目录&gt;/.git/index文件<br>暂存区主要用于临时保存文件少量变更，类似于邮件中的草稿箱<br>当变更累积到一定阶段，希望生成里程碑式的结果时，会使用commit，将暂存区的变更一次性的批量提交到本地仓库<br><br>本地仓库 Local Repository：<br>用于存储在工作区和暂存区中改过并提交的文件地方，使用 git commit 提交,对应于/&lt;项目目录&gt;/.git/<br>每一次commit 会生成一个唯一的ID，通常用于表示一个阶段性的新的版本<br>checkout命令执行了同commit命令相反的操作，它将版本中存储的commit所代表着的某个版本恢复至工作区中<br>checkout命令完成后，工作区中的文件内容与其检出的提交那一刻的状态相同<br>若工作区中存储此前未被提交的新文件，这些文件的未被提交的新的更改会被存储仓库的旧内容覆盖<br>当然，用户也可以暂存这些新文件，并将带有新文件的工作区提交到版本库中，这将是新的暂存和提交循环<br><br>远程仓库 Remote Repository ：<br>多个开发人员共同协作提交代码的仓库，即私有 gitlab 服务器或公有云github,gitee网站等<br>利用远程仓库，可以实现异地备份和远程协作<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419135734948.png)</p><h4 id="Git-文件的状态变化周期"><a href="#Git-文件的状态变化周期" class="headerlink" title="Git 文件的状态变化周期"></a>Git 文件的状态变化周期</h4><p>!!!!![](..&#x2F;image&#x2F;版本管理系统 Git 和 GitLab&#x2F;image-20250419135803736.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">untracked: 在工作目录下创建的新文件，这个时候本地git仓库不知道,不能对其进行版本跟踪管理<br>unmodified: 添加到暂存区的文件未修改,把文件从暂存区推动到本地仓库<br>modified: 已经添加到暂存区的文件,在本地工作区的文件被修改了 ,需要重新添加至暂存区<br>staged: 文件添加到了暂存区<br>unstaged: 已被跟踪的工作区的文件发生更新，但还没有存入暂存区中<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志服务和文件共享</title>
    <link href="/2025/06/09/%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    <url>/2025/06/09/%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="日志服务和文件共享"><a href="#日志服务和文件共享" class="headerlink" title="日志服务和文件共享"></a>日志服务和文件共享</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络安全技术基础</title>
    <link href="/2025/06/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/06/09/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="网络安全技术基础"><a href="#网络安全技术基础" class="headerlink" title="网络安全技术基础"></a>网络安全技术基础</h1><hr><h2 id="title-网络安全技术基础date-2025-06-05categories-网络安全-tags-IDS-防火墙-网络攻击-description-网络安全技术中的基本概念和防御机制概述"><a href="#title-网络安全技术基础date-2025-06-05categories-网络安全-tags-IDS-防火墙-网络攻击-description-网络安全技术中的基本概念和防御机制概述" class="headerlink" title="title: 网络安全技术基础date: 2025-06-05categories: [网络安全]tags: [IDS, 防火墙, 网络攻击]description: 网络安全技术中的基本概念和防御机制概述"></a>title: 网络安全技术基础<br>date: 2025-06-05<br>categories: [网络安全]<br>tags: [IDS, 防火墙, 网络攻击]<br>description: 网络安全技术中的基本概念和防御机制概述</h2><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-IDS：入侵检测系统-Intrusion-Detection-Systems"><a href="#1-1-IDS：入侵检测系统-Intrusion-Detection-Systems" class="headerlink" title="1.1 IDS：入侵检测系统 (Intrusion Detection Systems)"></a>1.1 IDS：入侵检测系统 (Intrusion Detection Systems)</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 特点：<br>  - 不阻断网络访问，而是依据安全策略对网络和系统运行状况进行监控。<br>  - 尽可能发现各种攻击企图、攻击行为或攻击结果。<br>  - 保障机密性、完整性和可用性，是安全防护的重要监测手段。<br></code></pre></td></tr></table></figure><h3 id="1-2-IPS：入侵防御系统-Intrusion-Prevention-System"><a href="#1-2-IPS：入侵防御系统-Intrusion-Prevention-System" class="headerlink" title="1.2 IPS：入侵防御系统 (Intrusion Prevention System)"></a>1.2 IPS：入侵防御系统 (Intrusion Prevention System)</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 特点：<br>  - 以串行方式接入系统，能深度感知并检测经过的数据报文。<br>  - 根据预设安全策略对报文进行深度检测（协议分析、特征匹配、流量统计、事件关联等）。<br>  - 如发现网络攻击，立即采取措施（中断连接、丢弃报文、隔离文件、告警等），实现主动防御。<br></code></pre></td></tr></table></figure><h3 id="1-3-防火墙-Firewall"><a href="#1-3-防火墙-Firewall" class="headerlink" title="1.3 防火墙 (Firewall)"></a>1.3 防火墙 (Firewall)</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 功能与作用：<br>  - 在内部网络与外部网络、专用网络与公共网络、可信网络与不可信网络之间建立安全屏障。<br>  - 通过访问控制允许经许可的数据进出，同时阻断非法流量。<br>  - 支持规则配置，既可禁止本地网络向外发送数据，也可根据需要转发网络流量。<br></code></pre></td></tr></table></figure><h3 id="1-4-防水墙-Waterwall"><a href="#1-4-防水墙-Waterwall" class="headerlink" title="1.4 防水墙 (Waterwall)"></a>1.4 防水墙 (Waterwall)</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 功能与特点：<br>  - 防止内部信息泄漏，保护涉密信息、重要业务数据和技术专利。<br>  - 利用透明加解密、身份认证、访问控制和审计跟踪等技术手段实现安全保护。<br>  - 最大限度防止信息泄漏、破坏或违规外传，并完整记录操作日志以便日后审计。<br></code></pre></td></tr></table></figure><h3 id="1-5-网络解决方案的常见样式"><a href="#1-5-网络解决方案的常见样式" class="headerlink" title="1.5 网络解决方案的常见样式"></a>1.5 网络解决方案的常见样式</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-number">1</span>. 两层防火墙：内层防火墙限制极高，只允许特定网络访问。<br><span class="hljs-number">2</span>. 单层防火墙：一套防火墙配备三个网卡接口，但存在一定安全隐患。<br><span class="hljs-number">3</span>. 多层防火墙：在靠近互联网的外部部署更多防火墙，增强防护深度。<br><span class="hljs-number">4</span>. 禁止网络访问：完全封闭网络通信，适用于高安全性场景。<br></code></pre></td></tr></table></figure><h2 id="2-防火墙的分类与实现方式"><a href="#2-防火墙的分类与实现方式" class="headerlink" title="2. 防火墙的分类与实现方式"></a>2. 防火墙的分类与实现方式</h2><h3 id="2-1-按照保护范围划分"><a href="#2-1-按照保护范围划分" class="headerlink" title="2.1 按照保护范围划分"></a>2.1 按照保护范围划分</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 主机防火墙：<br>  - 针对单个主机进行防护，运行在终端设备上。<br>  - 能阻止未授权程序和数据的进出（Windows和Linux均内置防火墙）。<br><br>- 网络防火墙：<br>  - 部署在整个系统的主干网络上，过滤所有进出数据包。<br></code></pre></td></tr></table></figure><h3 id="2-2-按实现方式划分"><a href="#2-2-按实现方式划分" class="headerlink" title="2.2 按实现方式划分"></a>2.2 按实现方式划分</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 硬件防火墙：<br>  - 独立硬件设备，具备独立供电与部署。<br>  - 软件独立运行，专用硬件资源使其在功能和性能上均表现优异。<br>  - 常基于Linux内核二次开发，针对特定场景进行深度优化。<br><br>- 软件防火墙：<br>  - 以应用程序形式提供服务，运行于通用硬件平台并寄生于操作系统中。<br>  - 通过纯软件实现防护，灵活性较高，便于管理和更新。<br></code></pre></td></tr></table></figure><h3 id="2-3-按网络协议划分"><a href="#2-3-按网络协议划分" class="headerlink" title="2.3 按网络协议划分"></a>2.3 按网络协议划分</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 网络层防火墙：<br>  - 分析数据包的源地址、目标地址、端口号及协议，依据访问控制列表（ACL）执行规则。<br>  - 仅基于数据包头部信息过滤，无法解析应用层数据。<br><br>- 应用层防火墙：<br>  - 针对特定网络应用服务协议设计数据过滤逻辑。<br>  - 部署在内外部网络隔离点，作为中间转接控制数据通信。<br></code></pre></td></tr></table></figure><h3 id="2-4-按实现细节划分"><a href="#2-4-按实现细节划分" class="headerlink" title="2.4 按实现细节划分"></a>2.4 按实现细节划分</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 包过滤防火墙：<br>  - 根据用户定制关键字检查数据包的网络信息，不解析具体数据。<br>  - 应用层控制较弱，适用于基本过滤需求。<br><br>- 应用网关防火墙：<br>  - 检查数据包的具体数据信息（如IP、TCP报头），实现较为细致的控制。<br>  - 网络层控制较弱，但可针对特定应用场景进行配置。<br><br>- 状态检测防火墙：<br>  - 在包过滤基础上增加数据包状态检测，判断连接状态。<br>  - 能够动态控制连接，提供更强的安全性，但应用层控制依然有限。<br><br>- 复合型防火墙：<br>  - 综合网络层与应用层控制，并具备会话层控制能力。<br>  - 实现更全面的防护，适用于高安全性要求的环境。<br></code></pre></td></tr></table></figure><h2 id="3-Linux-防火墙基础知识"><a href="#3-Linux-防火墙基础知识" class="headerlink" title="3. Linux 防火墙基础知识"></a>3. Linux 防火墙基础知识</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 封装数据：<br>  - 应用数据从上层进入传输层，添加源/目标端口形成数据段（TCP/UDP首部），<br>    然后进入网络层，加上源/目标IP形成数据包，<br>    最后进入链路层，加上源/目标MAC地址构成数据帧，形成完整数据包。<br><br>- 解封装数据：<br>  - 数据到达目标主机后，按照封装的反向顺序逐层解包，最终还原出真实的应用内容。<br><br>- 数据包过滤：<br>  - 在数据传输过程中对数据包进行严格过滤，<br>    确保只有符合安全策略的流量能够通过。<br></code></pre></td></tr></table></figure><h2 id="4-防火墙工具"><a href="#4-防火墙工具" class="headerlink" title="4. 防火墙工具"></a>4. 防火墙工具</h2><h3 id="4-1-iptables"><a href="#4-1-iptables" class="headerlink" title="4.1 iptables"></a>4.1 iptables</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 由iptables软件包提供的命令行工具，运行于用户空间。<br>- 用于编写防火墙规则，规则传递给netfilter指导内核处理数据包。<br>- 默认安装于多数操作系统，如需扩展功能可开发专用模块。<br></code></pre></td></tr></table></figure><h3 id="4-2-xtables-nft-multi"><a href="#4-2-xtables-nft-multi" class="headerlink" title="4.2 xtables-nft-multi"></a>4.2 xtables-nft-multi</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 过渡工具，旨在帮助用户从传统iptables平滑迁移至nftables体系。<br>- 管理iptables、arptables及ebtables规则，基于nftables后端实现。<br></code></pre></td></tr></table></figure><h3 id="4-3-firewalld"><a href="#4-3-firewalld" class="headerlink" title="4.3 firewalld"></a>4.3 firewalld</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">- Linux中用于动态管理防火墙规则的系统守护进程。<br>- 支持定义网络区域（Zone）和接口安全等级，可实时更改规则而无需重启服务。<br></code></pre></td></tr></table></figure><h3 id="4-4-nftables"><a href="#4-4-nftables" class="headerlink" title="4.4 nftables"></a>4.4 nftables</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 新一代Linux防火墙技术，旨在取代传统iptables。<br>- 在性能、功能及易用性方面有显著提升，适合现代网络需求。<br></code></pre></td></tr></table></figure><h3 id="4-5-ufw-Uncomplicated-Firewall"><a href="#4-5-ufw-Uncomplicated-Firewall" class="headerlink" title="4.5 ufw (Uncomplicated Firewall)"></a>4.5 ufw (Uncomplicated Firewall)</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 主机级防火墙配置工具，Ubuntu默认提供。<br>- 简化iptables配置，兼顾易用性和灵活性。<br>- 核心原理：<br>  - 底层依然使用iptables，通过简单语法和默认配置进行管理。<br>  - 提供便捷的命令行接口，方便规则添加、删除和管理。<br></code></pre></td></tr></table></figure><h2 id="5-iptables命令格式与匹配条件"><a href="#5-iptables命令格式与匹配条件" class="headerlink" title="5. iptables命令格式与匹配条件"></a>5. iptables命令格式与匹配条件</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 命令格式：<br>  iptables -子命令 &lt;链&gt; &lt;规则策略&gt;<br><br>- 匹配条件（多条件默认“与”关系）：<br>  - [!] -s|<span class="hljs-comment">--source address[/mask][,...]    # 匹配源IP地址或网段（逗号分隔多个地址）</span><br>  - [!] -d|<span class="hljs-comment">--destination address[/mask][,...]  # 匹配目标IP地址或网段</span><br>  - [!] -p|<span class="hljs-comment">--protocol protocol                # 匹配具体协议（协议号或名称，0代表所有协议）</span><br>  - [!] -i|<span class="hljs-comment">--in-interface name                # 匹配数据包输入接口（适用于INPUT/FORWARD/PREROUTING链）</span><br>  - [!] -o|<span class="hljs-comment">--out-interface name               # 匹配数据包输出接口（适用于OUTPUT/FORWARD/POSTROUTING链）</span><br>- “!” 表示规则取反。<br></code></pre></td></tr></table></figure><h2 id="6-网络防火墙与NAT技术"><a href="#6-网络防火墙与NAT技术" class="headerlink" title="6. 网络防火墙与NAT技术"></a>6. 网络防火墙与NAT技术</h2><h3 id="6-1-NAT原理解析"><a href="#6-1-NAT原理解析" class="headerlink" title="6.1 NAT原理解析"></a>6.1 NAT原理解析</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">- NAT (Network Address Translation) 网络地址转换：<br>  - 局域网内主机通常分配私有IP地址，这些地址在互联网中不可路由。<br>  - 当局域网主机访问互联网时，私有IP地址经NAT转换为公网IP，<br>    数据包出站进行源地址转换，入站进行目标地址转换，实现内外通信。<br></code></pre></td></tr></table></figure><h3 id="6-2-SNAT-实现源IP地址转换"><a href="#6-2-SNAT-实现源IP地址转换" class="headerlink" title="6.2 SNAT 实现源IP地址转换"></a>6.2 SNAT 实现源IP地址转换</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">- SNAT (Source NAT)：<br>  - 基于nat表，在POSTROUTING链上工作，将数据包的源IP转换为指定的公网IP。<br>- 配置示例：<br>  iptables -t nat -A POSTROUTING -s LocalNet ! -d LocalNet -j SNAT <span class="hljs-comment">--to-source ExtIP [--random]</span><br>  - <span class="hljs-comment">--to-source：指定转换后的IP或IP范围及端口（可选）。</span><br>  - <span class="hljs-comment">--random：基于hash算法实现端口映射随机化。</span><br></code></pre></td></tr></table></figure><h3 id="6-3-MASQUERADE-实现源IP地址转换"><a href="#6-3-MASQUERADE-实现源IP地址转换" class="headerlink" title="6.3 MASQUERADE 实现源IP地址转换"></a>6.3 MASQUERADE 实现源IP地址转换</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada">- MASQUERADE：<br>  - 用于出口设备IP可能变化（如拨号上网）的场景，<br>    自动获取网卡IP作为出口IP进行地址转换。<br>- 配置示例：<br>  iptables -t nat -A POSTROUTING -s LocalNet ! -d LocalNet -j MASQUERADE [<span class="hljs-comment">--to-ports port[-port]] [--random]</span><br>  - <span class="hljs-comment">--to-ports：指定端口范围（可选）。</span><br>  - <span class="hljs-comment">--random：随机化端口映射.</span><br></code></pre></td></tr></table></figure><h3 id="6-4-DNAT-实现目标IP地址转换"><a href="#6-4-DNAT-实现目标IP地址转换" class="headerlink" title="6.4 DNAT 实现目标IP地址转换"></a>6.4 DNAT 实现目标IP地址转换</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ada">- DNAT (Destination NAT)：<br>  - 用于将内网私有IP地址转换为公网IP，使内网服务在公网可见。<br>  - 基于nat表，在PREROUTING链上工作。<br>- 配置示例：<br>  iptables -t nat -A PREROUTING -d ExtIP -p tcp|udp|icmp <span class="hljs-comment">--dport PORT -j DNAT --to-destination InterSeverIP[:PORT]</span><br>  - -d ExtIP：指定固定公网IP。<br>  - <span class="hljs-comment">--to-destination：转换为指定内网IP（及端口可选）。</span><br>- 注意：<br>  - DNAT规则仅能重定向到单台后端主机，无法实现负载均衡。<br>  - 防火墙作为内核模块，其监听端口可能不通过netstat或ss显示。<br></code></pre></td></tr></table></figure><h3 id="6-5-REDIRECT-实现本机端口转换"><a href="#6-5-REDIRECT-实现本机端口转换" class="headerlink" title="6.5 REDIRECT 实现本机端口转换"></a>6.5 REDIRECT 实现本机端口转换</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">- REDIRECT：<br>  - 将数据包重定向到同一主机的其他端口，无需开启内核ip_forward转发。<br>- 配置示例：<br>  iptables -t nat -A PREROUTING -d ExtIP -p tcp|udp <span class="hljs-comment">--dport PORT -j REDIRECT --to-ports PORT</span><br>  - <span class="hljs-comment">--to-ports：指定新的目标端口。</span><br></code></pre></td></tr></table></figure><h2 id="7-FORWARD链转发机制"><a href="#7-FORWARD链转发机制" class="headerlink" title="7. FORWARD链转发机制"></a>7. FORWARD链转发机制</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">- FORWARD链：<br>  - 处理需转发至其他主机的数据包（目的地址非本机）。<br>  - 通过规则决定数据包是否允许、拒绝或丢弃。<br>- 应用场景：<br>  - 路由器或网关设备：转发不同网络间的数据包。<br>  - 防火墙：通过规则允许或拒绝特定IP地址或端口范围的数据包。<br></code></pre></td></tr></table></figure><h2 id="8-自定义链"><a href="#8-自定义链" class="headerlink" title="8. 自定义链"></a>8. 自定义链</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">- 除系统自带链外，iptables支持自定义链以便分组规则及重复调用。<br>- 添加自定义链后，需将其作为系统链的target关联，才能生效。<br></code></pre></td></tr></table></figure><h2 id="9-firewalld"><a href="#9-firewalld" class="headerlink" title="9. firewalld"></a>9. firewalld</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">- firewalld是用于管理netfilter的用户空间工具，支持iptables、ip6tables及ebtables。<br>- 通过守护进程实现防火墙规则的动态配置与监控。<br>- 内置多个Zone，每个Zone对应一套防火墙规则，支持自定义修改。<br></code></pre></td></tr></table></figure><hr><h1 id="总结与要点"><a href="#总结与要点" class="headerlink" title="总结与要点"></a>总结与要点</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ada">- IDS与IPS：<br>  - IDS主要用于监控与检测，不直接干预网络访问；<br>  - IPS则在检测到异常时采取主动防御措施，确保网络安全。<br><br>- 防火墙：<br>  - 作为网络安全的第一道防线，防火墙通过多种技术和策略过滤网络流量，<br>    分为主机防火墙和网络防火墙，硬件和软件实现各有优劣。<br>  - 依据网络协议和实现细节进一步细分，以适应不同安全需求。<br><br>- NAT技术：<br>  - NAT在实现私有IP与公网IP转换中起关键作用，<br>    包括SNAT、MASQUERADE、DNAT和REDIRECT等多种实现方式，各自适用于不同场景。<br><br>- FORWARD链与自定义链：<br>  - FORWARD链用于转发非本机目的地的数据包，是路由器和防火墙的重要组成部分。<br>  - 自定义链有助于规则管理和复用，提升配置灵活性。<br><br>- firewalld：<br>  - 提供现代化、动态化的防火墙管理，简化规则配置和监控，适用于多种Linux发行版。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运算符-</title>
    <link href="/2025/06/09/%E8%BF%90%E7%AE%97%E7%AC%A6-/"/>
    <url>/2025/06/09/%E8%BF%90%E7%AE%97%E7%AC%A6-/</url>
    
    <content type="html"><![CDATA[<h1 id="运算符-x20"><a href="#运算符-x20" class="headerlink" title="运算符&#x20;"></a>运算符&#x20;</h1><p>+- *&#x2F;%的用法</p><p><img src="/../image/%E8%BF%90%E7%AE%97%E7%AC%A6-/image_XS2ISyv_SB.png"></p><p>输出</p><p><img src="/../image/%E8%BF%90%E7%AE%97%E7%AC%A6-/image_EiXHMnCd6Q.png"></p><p><img src="/../image/%E8%BF%90%E7%AE%97%E7%AC%A6-/image_om2w_GnRIb.png"></p><p><img src="/../image/%E8%BF%90%E7%AE%97%E7%AC%A6-/image_Gr3P0mOGxq.png"></p><p>结论:1.整数参与计算结果只能是整数</p><p>&#x20;       2.如果有在计算时有小数参与结果有可能不精确</p><p>练习：录入一个三位数 拆分成个位，十位，百位</p><p>公式:</p><p>个位：数值%10</p><p>十位:  数值&#x2F;10%10</p><p>百位:  数值&#x2F;100%10 &#x20;</p><p>千位:  数值&#x2F;1000%10</p><p>………</p><p><img src="/../image/%E8%BF%90%E7%AE%97%E7%AC%A6-/image_l081vAAIav.png"></p><p><img src="/../image/%E8%BF%90%E7%AE%97%E7%AC%A6-/image_xqPJKauaOM.png"></p><p>数字进行运算时,数据类型不一样不能运算,要转成一样的,才能运算.</p><p>类型转换的分类:</p><p>①隐式转换 ·取值范围小的数值→取值范围大的数值(程序自动实现转换)</p><p>取值范围排序: byte→short→int→long→float→double</p><p>byte,short,char先提升为int,在计算</p><p>例:int a&#x3D;10:</p><p>&#x20;   double b&#x3D;a; <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="此时double范围大所以b=10.0 小数类型">[1]</span></a></sup></p><p>②强制转换<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="可能会发生数据错乱">[2]</span></a></sup>·取值范围大的数值→取值范围小的数值</p><p>代码格式;目标数据类型 变量名&#x3D;(目标数据类型)<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="想转谁就在括号里写谁">[3]</span></a></sup>被强制转换的数据</p><p>例:double a&#x3D;12.3;</p><p>&#x20;    nit b&#x3D;(int) a;</p><h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><p>＋＋(变量值加一)</p><p>－－(变量值减一)</p><p><img src="/../image/%E8%BF%90%E7%AE%97%E7%AC%A6-/image_RZOiPe_rDi.png"></p><p><img src="/../image/%E8%BF%90%E7%AE%97%E7%AC%A6-/image_6t_Wf70kX4.png"></p><p>不管是先++，还是后++。单独写在一行的时候，运算结果是一模一样的。</p><p>赋值运算符 &#x3D;</p><h1 id="扩展赋值运算符"><a href="#扩展赋值运算符" class="headerlink" title="扩展赋值运算符"></a>扩展赋值运算符</h1><p>+&#x3D;、-&#x3D;、 *&#x3D;、&#x2F;&#x3D;、%&#x3D;;(就是把左边跟右边进行运算，把最终的结果赋值给左边，对右边没有任何影响)</p><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>&amp;：逻辑与（而且）</p><p>两边都为真，结果才是真，只要有一个为假，那么结果就是假。</p><p>|：逻辑或（或者）</p><p>两边都为假，结果才是假，只要有一个为真，那么结果就是真。</p><p>应用场景:用户登录比较用户名和密码的对错(&amp;)</p><p>^:(异或)</p><p>如果两边相同,结果为false,如果两边不同,结果为true.</p><p>!;(取反)</p><p>一次用一个</p><h1 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h1><p>&amp;&amp;:(和&amp;运算结果一样)</p><p>||:(和|运算结果一样)</p><p>当左边不能确定整个表达式的结果，右边才会执行。</p><p>当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率。</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>格式:关系表达式 ？ 表达式1 ：表达式2 ；</p><p>代码规则:①计算关系表达式的值。</p><p>&#x20;              ②如果关系表达式的值为真，那么执行表达式1。</p><p>&#x20;               ③如果关系表达式的值为假，那么执行表达式2。</p><p>三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来。</p><p><img src="/../image/%E8%BF%90%E7%AE%97%E7%AC%A6-/image_sgJQusV92X.png"></p><p><img src="/../image/%E8%BF%90%E7%AE%97%E7%AC%A6-/image_ol8mrzCe8W.png"></p><h1 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h1><p><img src="/../image/%E8%BF%90%E7%AE%97%E7%AC%A6-/image_t5R3zy2gx1.png"></p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>此时double范围大所以b&#x3D;10.0 小数类型<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>可能会发生数据错乱<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>想转谁就在括号里写谁<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程管理、系统性能和计划任务</title>
    <link href="/2025/06/09/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/"/>
    <url>/2025/06/09/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="进程管理、系统性能和计划任务"><a href="#进程管理、系统性能和计划任务" class="headerlink" title="进程管理、系统性能和计划任务"></a>进程管理、系统性能和计划任务</h1><p>进程管理</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs ada">基础知识:<br>内核是操作系统最基本的部分，它的功能非常强大且多样    <br>  <span class="hljs-number">1</span>.系统调用接口：<br>      这是内核与应用软件之间的桥梁，它允许应用软件通过系统调用来请求内核提供的服务，如文件操作、进程控制等。<br><br>  <span class="hljs-number">2</span>.进程管理：<br>      内核负责创建、销毁、调度和同步进程。它确保每个进程都能公平地获得CPU资源，同时防止进程间的非法访问和干扰。<br><br>  <span class="hljs-number">3</span>.内存管理：<br>      内核管理计算机的内存资源，包括物理内存和虚拟内存的分配、回收和保护。它确保每个进程都有足够的内存来执行其任务，同时防止内存泄漏和非法访问。  <br><br>  <span class="hljs-number">4</span>.文件系统管理：<br>      内核提供对文件和文件夹的管理和访问功能，包括文件的创建、读取、写入、删除和重命名等。它确保文件系统的完整性和安全性，同时提供方便的文件访问接口。<br><br>  <span class="hljs-number">5</span>.设备驱动：<br>      内核提供对硬件设备的访问接口，包括输入输出设备、存储设备和网络设备等。它通过与硬件设备的驱动程序交互，实现设备的初始化、配置和控制等功能。<br><br>  <span class="hljs-number">6</span>.硬件抽象：<br>      内核提供硬件抽象层，隐藏了硬件的复杂性和差异性，为应用软件提供了一套简洁、统一的接口。这使得应用软件可以无需关心底层硬件的具体实现，从而专注于实现其业务逻辑。<br><br>cpu分片机制<br>  CPU分片机制，也称为时间分片或轮转调度，是操作系统用来管理和分配CPU时间的策略。在这种机制下，操作系统将CPU的执行时间分割成固定或可变长度的时间片，每个进程或线程获得一个时间片来执行其任务。这种机制确保了每个进程或线程都能获得一定的CPU时间，从而实现了并发执行  <br><br>进程管理概念:<br>   进程管理是操作系统中的一个重要功能，它负责监控、调度和控制计算机系统中所有进程的执行。通过有效的进程管理，可以提高系统的资源利用率和吞吐量，同时保证系统的稳定性和可靠性。 <br>  进程是运行中的程序<br>  进程管理是指操作系统对系统中所有进程进行有效的监控、调度和控制的过程。进程是操作系统进行资源分配和调度的基本单位，它代表了程序的执行实例。<br>  进程是程序的一次执行过程，它包含了程序的代码、数据和运行状态等信息。每个进程都有一个唯一的标识符（PID），用于区分不同的进程。  <br>进程状态:<br>   进程的状态包括就绪态、运行态、阻塞态和终止态等，这些状态的转换与CPU分片机制密切相关。<br>        就绪态表示进程已经准备好执行，但尚未被分配CPU资源；<br>        运行态表示进程正在占用CPU资源执行；<br>        阻塞态表示进程因为等待某个事件（如I/O操作）而无法继续执行；<br>        终止态表示进程已经执行完毕或被操作系统强制终止。<br>        <br>    CPU分片机制使得进程的状态转换更加频繁和高效，从而提高了系统的响应速度和吞吐量。<br><br>进程的表现样式:<br>  Process: 运行中的程序的一个副本，是被载入内存的一个指令集合，是资源分配的单位<br>    - 进程ID（Process ID，PID）号码被用来标记各个进程<br>    - UID、GID、和SELinux语境决定对文件系统的存取和访问权限【/usr/bin/passwd】<br>    - 通常从执行进程的用户来继承<br>    - 存在生命周期       <br><br>进程分类:<br>  按操作系统分类：  <br>    - 协作式多任务<br>    - 抢占式多任务<br>  按进程运行方式分类：<br>    - 守护进程:daemon，在系统引导过程中启动的进程，和终端无关进程  <br>    - 前台进程:跟终端相关，通过终端启动的进程<br>  按进程资源使用的分类:<br>    - CPU-Bound：CPU 密集型，非交互<br>    - IO-Bound：IO 密集型，交互<br><br>进程结构:<br>  进程由程序、数据和进程控制块（Program Control Block，PCB）三部分组成。<br>       程序是进程要执行的指令集合，<br>       数据是进程在执行过程中需要处理的信息，<br>       进程控制块则包含了进程的各种信息和控制信息，<br>       如进程标识符（PID）、状态、优先级、程序计数器、寄存器集合等。<br>         <br><br>线程:<br>  线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。<br>  一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。  <br>关联关系:<br>   查看进程的相关信息<br>     ls /proc/PID<br>   查看进程中的线程 - 包括进程本身<br>     grep -i threads /proc/PID/status<br>   查看进程的二进制文件<br>     ll /proc/PID/exe<br>   查看进程打开的文件<br>     /proc/PID/fd/  <br><br>多进程和多线程:<br>多进程查看:  <br>  安装软件<br>   root@rocky924:~# apt install -y nginx<br>  查看多进程模型<br>   root@rocky924:~# pstree -p | grep nginx<br>           |-nginx(<span class="hljs-number">1160</span>)-+-nginx(<span class="hljs-number">1161</span>)<br>           |             `-nginx(<span class="hljs-number">1162</span>)    <br>多线程查看:<br>  安装软件<br>   root@rocky924:~# apt install -y redis-server<br>  查看多线程模型<br>   root@rocky924:~# pstree -p | grep redis<br>           |-redis-server(<span class="hljs-number">2831</span>)-+-&#123;redis-server&#125;(<span class="hljs-number">2833</span>)<br>           |                    |-&#123;redis-server&#125;(<span class="hljs-number">2834</span>)<br>           |                    |-&#123;redis-server&#125;(<span class="hljs-number">2835</span>)<br>           |                    `-&#123;redis-server&#125;(<span class="hljs-number">2836</span>)  <br><br>内存问题:<br>  内存泄露:<br>   内存泄露是指程序在动态分配内存后，未能正确释放这些内存空间，导致系统无法回收这部分内存空间。内存泄露通常表现为程序运行过程中占用的内存空间不断增大，直至耗尽系统资源，导致程序崩溃或异常。 <br>  内存溢出:<br>   溢出是指数据超出了其存储空间的范围，导致数据损坏或程序崩溃。常见的溢出类型包括整数溢出和缓冲区溢出。<br>  内存不足: <br>   OOM即 <span class="hljs-keyword">Out</span> <span class="hljs-keyword">Of</span> Memory 内存用完了，是指系统或应用程序在运行时因内存不足而无法继续执行的情  况。这通常会导致应用程序崩溃或系统变得不稳定。  <br><br>进程状态:<br>  创建状态：<br>   进程在创建时需要申请一个空白PCB(process control block进程控制块)，向其中填写控制和管理进程的信息，完成资源分配。如果创建工作无法完成，比如资源无法满足，就无法被调度运行，把此时进程所处状态称为创建状态；<br>  就绪状态：<br>   进程已准备好，已分配到所需资源，只要分配到CPU就能够立即运行；<br>  执行状态：<br>   进程处于就绪状态被调度后，进程进入执行状态；<br>  阻塞状态：<br>   正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用；<br>  终止状态：<br>   进程结束，或出现错误，或被系统终止，进入终止状态。无法再执行；  <br>         STAT字段解析<br>           D：不可中断的睡眠状态。<br>           R：运行或可运行状态。<br>           S：可中断的睡眠状态。<br>           T：停止或被跟踪状态。<br>           l：代表多线程<br>           Z：僵尸状态（已经终止，但父进程尚未读取其退出状态）。<br>           I：空闲（Idle）或可中断的睡眠状态（Interruptible Sleep）的变种。 <br>               I 后跟 &lt; 或 &gt; 可能表示特定的内核线程状态，不是严格意义上的“睡眠”状态。<br>               I&lt;：表示一个低优先级的内核线程，它正在等待某个事件，但可以被信号中断。<br>               I&gt;：这个组合不太常见，理论上可能表示一个高优先级的内核线程。<br><br>状态切换:<br>  运行——&gt;就绪：<br>    <span class="hljs-number">1</span>：主要是进程占用CPU的时间过长，而系统分配给该进程占用CPU的时间是有限的；<br>    <span class="hljs-number">2</span>：在采用抢先式优先级调度算法的系统中，当有更高优先级的进程要运行时，该进程就被迫让出CPU，该进程便由执行状态转变为就绪状态；<br>  就绪——&gt;运行：<br>    运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配CPU；<br>  运行——&gt;阻塞：<br>    正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如发生了I/O请求；<br>  阻塞——&gt;就绪：<br>    进程所等待的事件已经发生，就进入就绪队列；<br>    <br>内存清理策略:<br>  先进先出（FIFO）：<br>    按照数据或进程进入内存的顺序进行淘汰，即先进先出。这种策略实现简单，但可能无法有效保留重要或频繁访问的数据。<br>  最近最少使用（LRU）：<br>     根据数据最近被访问的时间来决定哪些数据应该被移除。具体来说，系统会记录每个数据项最后一次被访问的时间，当需要淘汰数据时，会选择最近最少使用的数据项进行淘汰。这种策略适用于读操作频繁，且希望保留最近被频繁访问的数据的场景。<br>  最不经常使用（LFU）：<br>     根据数据被访问的频率来决定哪些数据应该被移除。系统会记录每个数据项被访问的次数，当需要淘汰数据时，会选择最不经常使用的数据项进行淘汰。这种策略适用于读操作频繁，且希望保留被频繁访问的数据的场景。<br><br> <br>    <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br></code></pre></td></tr></table></figure><p><img src="/../image/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image_P2XqWpS2iP.png"></p><p><img src="/../image/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image_JNWFMe2whO.png"></p><p><img src="/../image/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image_LS96S7w-NQ.png"></p><p><img src="/../image/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image_C3iS0oIxcB.png"></p><p><img src="/../image/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image_X788B41qmj.png"></p><p><img src="/../image/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E3%80%81%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%92%8C%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1/image_QxgGYrTBYo.png"></p><p>进程管理工具</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs ada">pstree 查看进程<br>      -p 查看进程树 <br><br>ps 进程状态信息(pid)<br>   -a #选项包括所有终端中的进程<br>   -x #选项包括不链接终端的进程<br>   -u #选项显示进程所有者的信息<br>   -f #选项显示进程树<br>   <br>prtstat  打印指定进程统计信息   <br>    -a| #显示详细完整的进程信息<br>    -t| #显示指定终端的进程<br>    -f| #使用完整的进程名匹配   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>   <br>    <br></code></pre></td></tr></table></figure><p>其他管理工具</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><br></code></pre></td></tr></table></figure><p>计划任务</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高可用集群Keepalived</title>
    <link href="/2025/03/16/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4Keepalived/"/>
    <url>/2025/03/16/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4Keepalived/</url>
    
    <content type="html"><![CDATA[<h1 id="高可用集群Keepalived"><a href="#高可用集群Keepalived" class="headerlink" title="高可用集群Keepalived"></a>高可用集群Keepalived</h1><h4 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h4><p>!!!!<img src="/../image/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4Keepalived/image-20250321113325305.png"></p><table><thead><tr><th>类型</th><th>解析</th></tr></thead><tbody><tr><td>高扩展集群</td><td>在当前业务环境集群中，所有的主机节点都处于正常的工作活动状态，它们共同承担起用户的请求带来的工作负载压力，保证用户的正常访问。</td></tr><tr><td>高可用集群</td><td>将核心业务使用多台 (一般是 2 台) 主机共同工作，支撑并保障核心业务的正常运行，尤其是业务的对外不间断的对外提供服务。核心特点就是 “冗余”，它存在的目的就是为了解决单点故障 (Single Point of Failure) 问题。</td></tr><tr><td>高性能集群</td><td>基于前两种技术实现的集群基础上，高效利用这些主机资源，结合某些特有的技术方案，提供强大的计算能力，从而实现特定用户大型任务的高复杂度数据处理功能，比如生物计算、大场景模拟计算、预测计算等。</td></tr></tbody></table><h4 id="高可用指标"><a href="#高可用指标" class="headerlink" title="高可用指标"></a>高可用指标</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">高可用集群是基于高扩展基础上的一个更高层次的网站稳定性解决方案。网站的稳定性体现在两个方面：网站可用性和恢复能力<br></code></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>描述</th><th>简称</th><th>可用性级别</th><th>年度停机时间</th></tr></thead><tbody><tr><td>1</td><td>基本的可用性</td><td>2 个 9</td><td>99%</td><td>87.6 小时</td></tr><tr><td>2</td><td>较高的可用性</td><td>3 个 9</td><td>99.9%</td><td>8.8 小时</td></tr><tr><td>3</td><td>故障自动恢复的可用性</td><td>4 个 9</td><td>99.99%</td><td>53 分钟</td></tr><tr><td>4</td><td>极高可用性</td><td>5 个 9</td><td>99.999%</td><td>5 分钟</td></tr></tbody></table><h4 id="恢复能力"><a href="#恢复能力" class="headerlink" title="恢复能力"></a>恢复能力</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">所谓的恢复能力，指的是一个网站从发生故障到故障修复这个过程的能力，而这个能力涉及到两个子内容：数据恢复能力和业务恢复能力。<br>数据恢复能力 RPO(Recovery Point Obejective)<br> 是指业务系统所允许的在灾难过程中的最大数据丢失量，用来衡量高可用系统的数据冗余备份能力。<br> 例如，恢复到灾难发生前最后一次数据备份的数据状态。<br> <br>系统恢复能力 RTO(Recovery Time Objective)<br> 是指应用系统从灾难状态恢复到物理系统环境可运行状态所需的时间，用来衡量高可用系统的恢复能力。<br> 例如，服务器重启、数据库重启、数据恢复、应用回归正常运行。<br> <br>网络恢复能力 NRO(Network Recovery Objective)<br> 是指网络系统从灾难状态恢复到网络可连接状态所需的时间，用来衡量高可用系统的网络恢复能力。<br> 例如，用户在灾难后可以连接到灾备中心的时间。<br> <br>业务恢复能力 RAO(Recovery Access Objective)<br> 是指业务系统从灾难状态恢复到可运行状态所需的时间，用来衡量高可用系统的业务恢复能力。<br> 例如，用户在灾难后，可以感受到灾难前的业务应用状态。<br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4Keepalived/image-20250321113635027.png"></p><h4 id="高可用方式"><a href="#高可用方式" class="headerlink" title="高可用方式"></a>高可用方式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">对于集群来说，高可用的最主要的目的就是保证网站接入口的稳定性，通过一个虚拟的接入口，将真实的请求转发到不同地址(一般是两个)的真实接入口出，进而将请求转发到后续高扩展集群主机中。<br>这个虚拟的接入口，我们一般称之为VIP，这个VIP一般附加在后端的真实接入口，二这两个接入口一个做主一个做从，共同负担起VIP传输过来的信息。<br>做主的接口主机我们一般称之为Master或者Active，做备的接口主机我们一般称之为Slave或者Passive。<br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4Keepalived/image-20250321113724019.png"></p><h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><table><thead><tr><th>模式名称</th><th>模式解析</th></tr></thead><tbody><tr><td>主备模式 (Active&#x2F;Passive)</td><td>后端的高可用结点运行一致的服务实例，正常情况下，VIP 配置在主节点上，只有作为主的 Active 结点响应用户的请求，当主节点故障，备用结点 Passive 自动接管一切，当主节点恢复后，通过自动或者手动方式，用户的请求重新有主节点来接管，整个过程用户感受不到任何影响。</td></tr><tr><td>双主模式 (Active&#x2F;Active)</td><td>后端的高可用结点运行各自的服务实例，都可以正常接收用户访问请求，当 A 结点故障，他会将访问请求自动转移到正常运行的 B 结点上，从而保证不对用户产生影响。但是有可能在 A 节点出现异常的时候，有可能导致 B 节点因为负载的因素导致整体崩溃。</td></tr><tr><td>集群模式 (N+M)</td><td>在这种模式下，当主节点故障时候，后备结点主机会通过某些策略，从中选择一个结点，作为临时主节点，接管所有请求。原来的主节点恢复的时候，通过多种策略来响应。</td></tr></tbody></table><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">为了实现高可用的效果，后端的高可用结点需要如下几种技术来保证：<br> 时间同步 和 心跳检测<br> <br>时间同步<br>   作为一个集群，他们彼此间进行信息通信的一个前提是，时间状态必须一致，如果出现一个主机在<span class="hljs-number">2018</span>年，一个在<span class="hljs-number">2020</span>年，这种情况下，集群的通信肯定会出现问题，甚至不会传输信息。<br>    我们一般会采用时间协议，从一个专用的时间服务器上获取时间，从而保证同一个集群中的所有主机时间都是一致的，这个协议我们一般使用ntp协议。<br>    <br>心跳检测<br>   对于高可用集群的各种模式来说，有一个关键的点就是：主节点故障了，从节点接管一切。这就涉及到了一种场景：高可用集群节点间需要知道彼此的状态，就类似于我们要知道一个人是否是活的，就看他有没有心跳。<br>    所以我们需要通过一种专用的技术来时刻了解集群节点间的状态，我们一般称这种技术为<span class="hljs-string">&quot;心跳检测&quot;</span>，常见的软件有VRRP。<br></code></pre></td></tr></table></figure><h2 id="Keepalived基础"><a href="#Keepalived基础" class="headerlink" title="Keepalived基础"></a><strong>Keepalived</strong>基础</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">vrrp 属于 网络层的一种 协议。<br><br>工作流程<br>keepalived部署在多台主机上(一般是两台)，keepalived服务启动后，会加载专用的配置文件，调用内核的LVS服务以创建虚拟服务器，并根据配置启用对外的统一访问接口，并且基于相关插件脚本对服务进行监控。<br> 为了保证服务对外的统一接口的高可用，VRRP协议将物理Router进行统一管理，并创建一个虚拟路由地址，作为外网的统一出口，物理Router内部通过VRRP机制进行内部通信，保证虚拟路由地址永远可用。<br> <br>通过我们对keepalived软件的结构和官方的介绍，我们可以知道，Keepalived其实就是通过整合和加<br>强LVS和VRRP软件，从而得到的一套适用于高扩展和高可用的软件整合解决方案。<br> 根据Keepalived软件的简单结构，我们可以了解到，我们要实现Keepalived的功能，需要在用户空间<br>安装相应的软件才可以。<br></code></pre></td></tr></table></figure><h4 id="vrrp"><a href="#vrrp" class="headerlink" title="vrrp"></a>vrrp</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs powershell">虚拟路由冗余协议(Virtual Router Redundancy Protocol，简称VRRP)是由IETF提出的解决局域网中配置静态网关出现单点故障现象的路由协议，其本质上是一种路由容错协议。<br><br>VRRP将局域网内的一组路由器虚拟为单个路由器。我们称该路由器组为VRRP备份组，它根据 <span class="hljs-string">&quot;优先级&quot;</span>选择一个Master主路由器，承担网关功能，其他路由器称为Backup从路由器。基于VRRP虚拟出来是路由我们称之为虚拟路由，该虚拟路由有独立的IP地址(VIP)。<br><br>工作模式：<br> 主/备：单个虚拟路由器<br> 主/主：主/备（虚拟路由器<span class="hljs-number">1</span>），备/主（虚拟路由器<span class="hljs-number">2</span>）<br> <br> 局域网内主机不知道后端真实的路由器的ip地址，仅仅知道这个虚拟路由的ip地址，让后将VIP设定为其数据包的出网地址，通过该虚拟路由与外部的其他网络进行通信。<br>    在整个过程中，如果Master路由器发生故障时，Backup取代Master继续履行网关职责，从而保证网络呢·`内的主机不间断地与外部网络进行通信。<br>    <br>虚拟路由器：Virtual Router <br>虚拟路由器标识：VRID(<span class="hljs-number">0</span><span class="hljs-literal">-255</span>)，唯一标识虚拟路由器<br>VIP：Virtual IP <br>VMAC：Virutal MAC (<span class="hljs-number">00</span><span class="hljs-literal">-00-5e-00-01-VRID</span>)<br>物理路由器：<br>    master：主设备<br>    backup：备用设备<br>    priority：优先级<br>    <br>通告：心跳，优先级等；周期性<br>工作方式：抢占式，非抢占式<br>安全认证：<br>    无认证 - 互相通信的时候，不需要任何认证信息<br>    简单字符认证：预共享密钥，通信双方使用简单字符进行基本的认证<br> MD5：通信双方使用md5的方式传输认证信息。<br>工作模式：<br>    主/备：单个虚拟路由器<br>    主/主：主/备（虚拟路由器<span class="hljs-number">1</span>），备/主（虚拟路由器<span class="hljs-number">2</span>）<br></code></pre></td></tr></table></figure><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Keepalived 是一个基于 VRRP 协议的实现高可用的软件，在 Keepalived 中，抢占式和非抢占式是两种重要的工作模式<br><br>抢占式<br>工作原理<br>在抢占式模式下，优先级最高的主服务器会一直处于 Master 状态，只要它处于正常运行状态且网络连接正常。当主服务器出现故障或网络问题时，备份服务器会接管其工作，成为 Master 状态。一旦主服务器恢复正常，它会立即抢占回 Master 角色，重新接管工作。<br><br>优缺点<br>快速恢复：主服务器恢复后能迅速重新承担主要工作，确保服务的连续性和稳定性。<br>    资源利用高效：高优先级的服务器能及时获取控制权，充分发挥其性能优势。<br>缺点：<br> 频繁的抢占可能会导致网络抖动或服务短暂中断，对一些对稳定性要求极高的服务可能产生一定影响。<br> <br>适用场景<br>适用于对主服务器性能要求较高，且能容忍短暂服务中断的场景，如一些非关键业务的负载均衡场景。<br><br>非抢占式<br>工作原理<br>在非抢占式模式下，当主服务器出现故障时，备份服务器会接管成为 Master 状态。即使主服务器恢复正常，它也不会主动抢占 Master 角色，而是继续由备份服务器提供服务，直到备份服务器出现故障或其他异常情况，主服务器才会再次成为 Master。<br><br>优缺点<br>优点<br>    稳定性高：避免了频繁抢占带来的网络抖动和服务中断风险，能保持服务的稳定运行。<br>    减少切换次数：减少了服务器角色的切换频率，有利于延长服务器硬件的使用寿命。<br>缺点：<br>    主服务器恢复后不能及时发挥作用，可能造成资源浪费，特别是当主服务器性能远高于备份服务器<br>    <br>适用场景<br>  适用于对服务稳定性要求极高，不容许有任何短暂中断的关键业务场景，如金融交易系统、大型数据库系统等。<br></code></pre></td></tr></table></figure><h4 id="非抢占模式"><a href="#非抢占模式" class="headerlink" title="非抢占模式"></a>非抢占模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">注意：要关闭 VIP抢占，必须将各 Keepalived 服务器 state 配置为 BACKUP<br></code></pre></td></tr></table></figure><h4 id="nopreempt-属性解析"><a href="#nopreempt-属性解析" class="headerlink" title="nopreempt****属性解析"></a><strong>nopreempt****属性解析</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">在 Keepalived 配置文件的 VRRP 实例部分使用nopreempt参数，就是明确将该 VRRP 实例设置为非抢占式模式。在这种模式下，如果主服务器（具有较高优先级的设备）出现故障，备份服务器会接管并承担起主服务器的工作，转变为 Master 状态来提供服务。<br> 当原本的主服务器恢复正常后，由于nopreempt的设置，它不会主动抢占回 Master 角色，而是继续让备份服务器（当前的 Master）提供服务，直到备份服务器出现故障或其他异常情况，原主服务器才会再次成为 Master。<br> nopreempt的主要目的是为了保持服务的稳定性和连续性，避免由于主服务器的频繁恢复和抢占导致的<br>服务中断和网络抖动。<br> 应用场景<br>nopreempt通常应用于对服务连续性和稳定性要求极高的场景，如金融交易系统、大型数据库系统、电信核心网等关键业务领域。在这些场景中，任何短暂的服务中断都可能导致严重的后果，因此采用非抢占式模式可以确保在主服务器故障恢复后，不会因为抢占操作而引发潜在的服务中断风险，从而保障业务的稳定运行。 <br><br><br></code></pre></td></tr></table></figure><h4 id="非抢占延迟模式"><a href="#非抢占延迟模式" class="headerlink" title="非抢占延迟模式"></a>非抢占延迟模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell">工作原理<br>在非抢占延时模式下，当主服务器出现故障时，备份服务器会在等待一个特定的延时时间后，才会接管成为 Master 状态来提供服务。<br> 同样，当主服务器恢复正常后，它也不会立即抢占 Master 角色，而是要等待一段预先设置好的延时时间，确认当前的 Master（即原备份服务器）确实出现异常或故障，或者经过延时后网络状况等条件满足切换要求，才会重新成为 Master。这个延时时间可以通过配置参数来设定，一般以秒为单位。<br> <br>优缺点<br>优点:<br>    增强稳定性：进一步减少了不必要的切换操作，避免因网络瞬间波动或主服务器短暂故障恢复等情况导致的频繁切换，使系统更加稳定。<br>    避免资源浪费：可以防止备份服务器在主服务器只是短暂故障，很快就能恢复的情况下，不必要地接管服务，从而避免了资源的浪费和可能出现的服务质量下降。<br>缺点:<br>    响应速度相对较慢：由于增加了延时等待，在主服务器出现故障时，备份服务器不能立即接管服务，可能会导致服务中断时间相对较长。<br>    配置复杂：需要合理设置延时时间，若设置不当，可能无法达到预期效果，甚至可能影响系统的正常运行。<br>    <br>适用场景<br>适用于对稳定性要求极高，且能容忍一定服务中断时间的场景。例如大型数据中心的核心服务，数据同步和一致性要求很高，不希望因为偶尔的网络波动或服务器小故障就进行切换，通过设置非抢占延时模式，可以在确保服务稳定的前提下，减少不必要的切换带来的风险和数据不一致问题。还有一些工业控制系统，对可靠性要求高，但对实时性要求不是特别苛刻，也可以采用这种模式来保证系统的稳定运行。<br><br></code></pre></td></tr></table></figure><h4 id="消息传播"><a href="#消息传播" class="headerlink" title="消息传播"></a>消息传播</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs powershell">单播和多播<br>单播：<br> 是一种点到点的通信方式，数据从发送方发送到特定的一个接收方。就像打电话时，通话双方是一对一的关系，信息只在这两者之间传递。<br>多播：<br> 是一种点到多点的通信方式，数据从发送方发送到一组特定的接收方，这些接收方构成一个多播组。类似于在一个群组通话中，说话者的声音可以同时被群组中的多个成员听到。<br> <br>地址类型<br>单播：<br> 使用单播地址来标识网络中的单个主机。每个主机都有唯一的单播地址，如 IPv4 或 IPv6 地址，数据根据目标单播地址进行精确传输。 <br>多播：<br> 使用多播地址来标识一组接收者。多播地址是一个特殊的地址范围，用于标识不同的多播组，发送到多播地址的数据会被该组内的所有成员接收。<br> <br>网络资源占用<br>单播：<br> 当需要向多个目标发送相同数据时，发送方需要为每个目标单独发送一份数据，会占用较多的网络带宽和服务器资源。比如服务器向 <span class="hljs-number">10</span> 个客户端发送相同的文件，就需要发送 <span class="hljs-number">10</span> 次。<br>多播：<br> 发送方只需发送一份数据，网络中的路由器会根据多播组的成员信息，在必要的节点处对数据进行复制和转发，从而节省了网络带宽和服务器资源。同样是服务器向 <span class="hljs-number">10</span> 个客户端发送相同文件，采用多播只需发送一次数据。<br> <br>应用场景<br>单播：<br> 适用于需要一对一精确通信的场景，如远程登录、文件传输、视频点播等，这些应用需要确保数据准确无误地传输到特定的接收方。 <br>多播：<br> 适用于一对多或多对多的通信场景，如在线直播、视频会议、网络游戏中的多人对战、网络电视等，这些应用需要将相同的数据同时发送给多个接收方<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运维自动化工具Ansible</title>
    <link href="/2025/03/07/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7Ansible/"/>
    <url>/2025/03/07/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7Ansible/</url>
    
    <content type="html"><![CDATA[<h1 id="运维自动化工具Ansible"><a href="#运维自动化工具Ansible" class="headerlink" title="运维自动化工具Ansible"></a>运维自动化工具Ansible</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs ada">Ansible基础:<br>  Ansible是一个开源软件，提供配置管理和应用程序部署等项目通用的管理功能。它主要运行在类Unix系统上，通过特性语言来描述各种资源对象，进而管理类Unix系统和Microsoft Windows系统等系统资源。  <br>  Ansible的工作特性:<br>    基础属性:<br>    开发 基于Python语言实现<br>    部署 基于Python和SSH、agentless实现简单部署<br>    安全 基于OpenSSH加密方式来传输，无序代理不依赖PKI，命令执行幂等性  <br>    功能属性:<br>    设计 基于插件化方式实现定制的功能<br>    关键 三大关键模块：Paramiko、PyYAML、Jinja2<br>    定制 支持自定义功能模块，编程语言格式无所谓<br>      注意：<br>        ansible的每一个模块的使用方法就类似于一条专用的命令<br>    进阶属性:<br>    劣势:<br>      由于基于ssh方式来通信，所以受ssh的限制比较多，因为ssh不是专门为ansible做准备的，所以由于性能损耗方面的原因，特别是主机量比较多的场景，效率是相当的低，解决该办法就是通过专用的代理或者客户端的方式来解决这种大环境下的低效。     <br>  使用场景:<br>    自动化云服务管理、自动化设备管理、自动化应用部署、自动化配置管理、自动化持续交付、自动化安全管理等.一句话：业务环境自动化管理  <br><br>架构解析:<br>  三层结构:用户端,控制端,被控端<br>工作流程:<br>  <span class="hljs-number">1</span> 用户基于命令或者playbook方式，向ansible的控制端发起用户请求<br>  <span class="hljs-number">2</span> ansible根据用户请求目标，到控制端的主机列表中验证目标是否存在<br>  <span class="hljs-number">3</span> 若目标主机存在，然后基于连接插件与被控端处于连接状态<br>  <span class="hljs-number">4</span> 根据用户请求指令，结合相应的功能模块，指定目标主机执行相应的功能<br>  <span class="hljs-number">5</span> 目标主机执行完毕后，会将相应的状态结果返回给控制端。<br>  <span class="hljs-number">6</span> 控制端在处理过程中，还会通过插件工具实现日志、邮件等辅助功能      <br>Ansible 命令执行来源:<br>  - 系统用户直接执行：系统用户登录终端后直接在命令行下执行单条命令<br>  - 在 playbooks 中间接执行，playbook中编写多条 ansible 命令，ansible 根据playbook文件的内容依次执行<br>  - 在 web 管理界面上执行<br>  - 使用 API 调用执行：配置API接口，让第三方应用或程序调用接口执行 ansible 命令   <br> <br> 软件部署:<br>   通用环境需求<br>     ansible的服务端和客户端基于ssh协议进行通信，所以必须提前准备ssh环境  <br>   控制端专用需求<br>     控制端支持类unix系统，不支持Windows系统<br>     需要python支持，提前准备python2.<span class="hljs-number">7</span>+或者python3.<span class="hljs-number">5</span>+的环境<br>   被控端专用需求<br>     一般功能无需部署python环境，如果涉及到Python业务的话，必须配置相应的Python环境<br>       - 被控端Python版本小于<span class="hljs-number">2.4</span>，需要安装python-simplejson<br>       - 被控端如开启SELinux需要安装libselinux-python<br>       - windows 只能做为被控制端<br> 软件环境:<br> ansible常见的命令;<br>/usr/bin/ansible # ansible主命令<br>/usr/bin/ansible-config # ansible 配置管理命令<br>/usr/bin/ansible-console # ansible交互式命令<br>/usr/bin/ansible-doc # ansible模块帮助命令<br>/usr/bin/ansible-galaxy # ansible 扩展命令，用于获取别人的优秀的角色模板文件<br>/usr/bin/ansible-playbook # ansible 任务管理工具<br>/usr/bin/ansible-pull # ansible 反模式工作命令<br>/usr/bin/ansible-vault # ansible 文件专用加密工具<br>利用ansible实现管理的主要方式：<br>  Ad-Hoc 即利用ansible命令，主要用于临时命令使用场景<br>  Ansible-playbook 主要用于长期规划好的，大型项目的场景，需要有前期的规划过程   <br>命令格式:<br>  通用格式：ansible &lt;目标主机&gt; 参数<br>  专用格式：ansible &lt;目标主机&gt; -m 模块 -a 模块参数<br>  命令方式：在命令行执行ansible的方式叫<span class="hljs-string">&quot;Ad-Hoc&quot;</span>,肯定还有其他执行方式。<br>  主要功能：ansible的主要功能都是通过各种各样的插件模块来实现特有功能的。<br>  拓展内容：ansible的默认模块叫command<br>注意：<br> Ansible 中的 Ad-Hoc 命令允许用户快速地在远程主机上执行单个任务或命令，而无需创建复杂的剧本（Playbook）。 <br> <br>主配置文件结构:<br>root@ubuntu24-<span class="hljs-number">13</span>:~# tree /etc/ansible/<br>/etc/ansible/<br>├── ansible.cfg<br>├── hosts<br>└── roles   <br>ansible有几个默认的配置文件:<br>  /etc/ansible/ansible.cfg<br>    主配置文件，配置ansible工作特性,也可以在项目的目录中创建此文件,当前目录下如果也有<br>    ansible.cfg,则此文件优先生效,建议每个项目目录下,创建独有的ansible.cfg文件<br>  /etc/ansible/hosts<br>    主机清单文件<br>  /etc/ansible/roles/<br>    存放角色的目录<br> <br> Ansible 的配置文件可以放在多个不同地方,表示作用范围的不同，优先级从高到低顺序如下:<br>   ANSIBLE_CONFIG 环境变量<br>   ./ansible.cfg   当前目录下的ansible.cfg<br>   ~/.ansible.cfg 当前用户家目录下的.ansible.cfg<br>   /etc/ansible/ansible.cfg 系统默认配置文件<br>   注意：<br>     对于ansible来说，他们的优先级是按照从上到下排列的，软件的根目录下的配置文件是最后的承载效果了。  <br> <br>  主配置文件中又间接定义了其它的配置项，在使用时，可以为不同的项目建立不同的配置文件放到不同的目录中，再去到该目录下执行 ansible，或者用变量指定不同的配置文件用来区分不同的项目配置，对于不同用户的配置，可以写在相应的家目录中。 <br> <br>command模块:<br>  对于默认模块来说，我们不需要-m来指定模块，可以对目标主机使用<span class="hljs-string">&quot;-a&quot;</span>传入一个命令参数，来执行查看本机上的信息，命令格式如下：<br>  ansible &lt;目标主机&gt; -a 模块参数<br>ping模块:<br>  ansible 可以通过 ping模块来探测目标主机的存活性，格式如下：<br>   ansible localhost -m ping  <br>ansible-doc命令:<br>  ansible-doc命令是专门用来查看ansible的模块帮助信息的，我们可以通过-h参数来查看他的帮助信息  <br>查看模块帮助:<br>  查看command模块帮助<br>  查看完整帮助：ansible-doc command<br>  查看简单帮助：ansible-doc command -s <br> <br> ansible-config命令:<br>   ansible-config命令用于专门管理ansible的配置信息<br>   ansible-config -h  <br>   结果显示：<br>   view用于查看ansible配置<br>   dump用于查看ansible的默认环境变量<br>   list用于罗列ansible详细的配置项<br>   init用于创建初始化配置项<br><br>主机清单<br> ansible的主要功用在于批量主机操作，为了便捷地使用其中的部分主机，可以在inventory file中将其分组命名.默认的inventory file为 /etc/ansible/hosts<br> inventory file可以有多个，且也可以通过插件模块的方式，从mysql、云平台等上面，以Dynamic <br>Inventory的方式生成主机清单.<br>  生产建议在每个项目目录下创建项目独立的hosts文件<br>主机清单属性样式<br>  主机清单的描述方式有两种：主机ip地址和主机名<br>    ## blue.example.com<br>    ## <span class="hljs-number">192.168</span>.<span class="hljs-number">100.1</span>   <br>  主机列表有两种形式：散列主机列表和主机组列表<br>    散列主机列表            主机组列表            嵌套主机组列表<br>    ## blue.example.com   ## [webservers]     ## [server:children]<br>    ## <span class="hljs-number">192.168</span>.<span class="hljs-number">100.1</span>:<span class="hljs-number">9999</span> ## beta.example.org ## webservers<br>    ## <span class="hljs-number">192.168</span>.<span class="hljs-number">1.100</span>      ## [webservers]     ## www[<span class="hljs-number">1</span>:<span class="hljs-number">100</span>].example.com<br>  主机列表范围形式可以使用<span class="hljs-string">&quot;[起始值:结束值]&quot;</span>样式来表示<br>    ## www[<span class="hljs-number">001</span>:<span class="hljs-number">006</span>].example.com        主机名方式表示<span class="hljs-number">6</span>台目标主机<br>    ## <span class="hljs-number">192.168</span>.<span class="hljs-number">1.10</span>[<span class="hljs-number">0</span>:<span class="hljs-number">9</span>]               主机ip地址表示<span class="hljs-number">10</span>台目标主机<br>主机清单文件格式<br>  inventory文件遵循INI文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；此外，当如若目标主机使用了非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来标明。  <br><br>[root@ubuntu13 ~]# ansible <span class="hljs-number">10.0</span>.<span class="hljs-number">0.13</span> -a <span class="hljs-string">&quot;ls /root&quot;</span><br>Enter passphrase <span class="hljs-keyword">for</span> key &#x27;/root/.ssh/id_ed25519&#x27;:<br>[WARNING]: Platform linux on host <span class="hljs-number">10.0</span>.<span class="hljs-number">0.13</span> <span class="hljs-keyword">is</span> using the discovered Python interpreter <span class="hljs-keyword">at</span> /usr/bin/python3.<span class="hljs-number">12</span>, but<br>future installation <span class="hljs-keyword">of</span> another Python interpreter could change the meaning <span class="hljs-keyword">of</span> that path. See<br>https://docs.ansible.com/ansible-core/<span class="hljs-number">2.17</span>/reference_appendices/interpreter_discovery.html <span class="hljs-keyword">for</span> more information.<br><span class="hljs-number">10.0</span>.<span class="hljs-number">0.13</span> | CHANGED | rc=<span class="hljs-number">0</span> &gt;&gt;<br><span class="hljs-number">1</span>.sh<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></code></pre></td></tr></table></figure><p><img src="/../image/image_qFSYfcE8i3.png"></p><p><img src="/../image/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7Ansible/image_xQymoCzkDV.png"></p><p><img src="/../image/image_4D9m_nqlww.png"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络属性和配置工具</title>
    <link href="/2024/12/27/%E7%BD%91%E7%BB%9C%E5%B1%9E%E6%80%A7%E5%92%8C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/"/>
    <url>/2024/12/27/%E7%BD%91%E7%BB%9C%E5%B1%9E%E6%80%A7%E5%92%8C%E9%85%8D%E7%BD%AE%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="网络属性和配置工具"><a href="#网络属性和配置工具" class="headerlink" title="网络属性和配置工具"></a>网络属性和配置工具</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java">虚拟网络:<br>  桥接网络|NAT网络|仅主机网络<br><br>网卡  <br>网卡名字：<br>  CentOS <span class="hljs-number">6</span>之前，网络接口使用连续号码命名：eth0、eth1等，但是，如果删除旧网卡再新增硬件设备，也有可能会被识别成 eth0，eth1 等。<br>  CentOS <span class="hljs-number">7</span>开始，改变了网卡设备命名规则，基于硬件生成网卡名，例如 ens33，ens160 等，可以保证网卡名称稳定且唯一；但是在批量环境中，没办法统一。  <br>  centos9之前网卡名字：<br>   /etc/sysconfig/network-scripts/ifcfg-IFACE<br> <br>  Cenos9之后的网卡名字<br>   /etc/NetworkManager/system-connections/IFACE.nmconnection<br> <br>  Ubuntu系统的网卡名字<br>   /etc/netplan/<br><br>网卡改名流程：<br>  <span class="hljs-number">1</span> 更改网卡配置<br>  <span class="hljs-number">2</span> grub应用新网卡配置<br>  <span class="hljs-number">3</span> 重启生效<br>立刻生效方法<br>  通过卸载驱动方式来实现：<br>    查看驱动：ethtool -i ens160<br>    卸载驱动：modprobe -r e1000<br>    安装驱动：modprobe e1000<br><br>网络配置：<br>  网卡配置：<br>    静态配置：<br>      网络管理员手动设置网络设备的IP地址、子网掩码、网关等参数。这种配置方式适用于网络结构相对固定、设备数量较少的场景。<br>    动态配置：<br>      网络设备通过动态主机配置协议（DHCP Dynamic Host Configuration Protocol）等协议自动获取IP地址等配置信息。这种配置方式适用于网络结构复杂、设备数量众多的场景，可以简化网络管理并提高工作效率。<br>  配置工具：<br>    命令行工具：<br>      如Windows的ipconfig命令和Linux的ifconfig或ip命令，用于查看和修改网络配置。<br>    图形化界面工具：<br>      如Windows的网络和共享中心、Linux的网络管理工具等，提供直观的图形界面供用户进行网络配置。<br>    网络管理软件：<br>      如Cisco的IOS、华为的eSight等，用于对网络设备进行集中管理和配置。<br> <br><br></code></pre></td></tr></table></figure><p>&#x20;</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs ada">网络命令：<br> <br>  hostname  主机名    <br>  hostnamectl 永久设置主机名  <br>  <br>   ifconfig  查看网卡信息<br>     -a #显示所有<br>     -s #以短格式显示<br>     -v #显示详细错误信息   <br>     add #给设备添加IPV6地址<br>     del #删除IPV6地址<br>     up #启用设备<br>     down #禁用设备<br>     临时修改网卡信息：<br>       ifconfig eth1 <span class="hljs-number">10.0</span>.<span class="hljs-number">0.55</span> netmask <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span>  #netmask如果不写表示默认的掩码，根据A|B|C类自动识别； <br>     清除网卡设备信息：<br>       ifconfig eth1 <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>  <br>     禁用网络设备：<br>       ifconfig eth1 down    <br>     启用网络设备：<br>       ifconfig eth1 up<br>     创建网卡别名：<br>       ifconfig ens160:<span class="hljs-number">1</span> <span class="hljs-number">10.0</span>.<span class="hljs-number">0.200</span>/<span class="hljs-number">24</span> up   # 注意：up不写，默认就是up  <br>     <br>   route  查看路由信息<br>     -n|<span class="hljs-comment">--numeric #以IP格式显示，而不是以主机名显示</span><br>     -net #目标是一个网络<br>     -host #目标是一个主机    <br>     增加路由：<br>       route add -net&#123;网段&#125;| -host&#123;ip&#125; gw  &#123;网关&#125; <br>     删除路由：  <br>       route del -net&#123;网段&#125;| -host&#123;ip&#125; gw  &#123;网关&#125;<br> <br>   netstat<br>     -r|<span class="hljs-comment">--route #显示路由表</span><br>     -t|<span class="hljs-comment">--tcp #显示tcp端口数据</span><br>     -u|<span class="hljs-comment">--udp #显示udp端口数据</span><br>     -n|<span class="hljs-comment">--numeric #以数字显示IP和端口</span><br>     -p|<span class="hljs-comment">--program #显示相关进程及PID</span><br>     常用组合<br>     -tan, -uan, -tnl, -unl，tnulp<br>     如何查看是哪个程序在监听端口<br>     netstat -tunlp | grep <span class="hljs-string">&quot;:22&quot;</span><br>     ss -ntulp | grep <span class="hljs-string">&quot;:22&quot;</span><br>     lsof -i:<span class="hljs-number">22</span>  <br>   <br>   ip  管理与配置网络接口和路由表    <br>     常用对象和命令<br>       link：网络设备的相关设定，包括MTU、MAC地址等。<br>         ip link show：显示网络接口信息。<br>         ip link set &lt;<span class="hljs-keyword">interface</span>&gt; up：开启网卡。<br>         ip link set &lt;<span class="hljs-keyword">interface</span>&gt; down：关闭网卡。<br>         ip link set &lt;<span class="hljs-keyword">interface</span>&gt; name &lt;newname&gt;：修改网卡名称。<br>         ip link set &lt;<span class="hljs-keyword">interface</span>&gt; mtu &lt;value&gt;：设置网卡最大传输单元。          <br>     ip link  查看链路层信息<br>     ip address  查看网卡ip地址信息<br>     ip route  查看主机的路由信息<br>     ip a show ens160  查看指定设备的信息  <br>    网卡管理：<br>      禁用网卡<br>        ip link set ens160 down<br>      网卡改名<br>        ip link set ens160 name ens160-test<br>      启用网卡<br>        ip link set ens160-test up<br>      查看网卡效果<br>        ip link show ens160-test<br>      网卡名字恢复<br>        ip link set ens160-test name ens160   <br>     <br>     ip address 添加ip地址<br>       ip addr add &lt;IP&gt;/&lt;prefixlen&gt; dev &lt;<span class="hljs-keyword">interface</span>&gt;：为指定网卡添加IP地址  <br>       ip addr del &lt;IP&gt;/&lt;prefixlen&gt; dev &lt;<span class="hljs-keyword">interface</span>&gt;：删除指定网卡上的IP地址<br>     <br>     ip route<br>       添加路由<br>       ip route add TARGET via   GW  dev IFACE src SOURCE_IP <br>       添加网关：<br>       ip route add default via GW dev IFACE<br>       删除路由：<br>       ip route del TARGET <br>       显示路由：<br>       ip route show|list<br>       清空路由表：<br>       ip route flush [dev IFACE] [via PREFIX]<br>       查看路由过程<br>       ip route get IP         <br>     ss  获取系统中socket的统计信息<br>       常用选项<br>         -n|<span class="hljs-comment">--numeric       #不以主机名的格式显示</span><br>         -u|<span class="hljs-comment">--udp           #仅显示udp数据</span><br>         -p|<span class="hljs-comment">--processes     #显示对应的进程</span><br>         -t|<span class="hljs-comment">--tcp           #仅显示tcp数据</span><br>         -a|<span class="hljs-comment">--all           #显示所有数据    </span><br>         -l|<span class="hljs-comment">--listening     #仅显示listen状态的连接        </span><br>     <br>     nmcli  网卡配置|网络状态管理|网络设备管理<br>       nmcli con [show]  查看网络连接 <br>       nmcli con show <span class="hljs-comment">--active  查看活跃连接 </span><br>       nmcli con show ens160  查看指定设备 <br>       nmcli dev status  显示设备状态  <br>       nmcli dev show ens160  网络接口属性      <br>       nmcli con del ens160  删除连接 <br>       nmcli con up ens160   启用连接 <br>       nmcli con down ens160  禁用连接 <br>       nmcli connection reload  刷新连接<br>   <br>   fping  是一个程序，用于将ICMP探测发送到网络主机，类似于ping<br>     -c：指定向每个目标发送的ping数据包数。  <br>     -s：打印最终统计数据<br>     -r：设置重试次数    <br>     -g：生成目标列表。通过指定起始和结束IP地址或CIDR地址来生成要ping的目标列表。<br>    <br>   tcpdump  网络数据包截获分析工具<br>    -n #不转换主机名和IP地址  <br>    -i #指定设备   <br>    -c #达到数量后就不再抓包<br>    <br>    <br>    <br>   nmap  网络探测和安全审核工具<br>     nmap <span class="hljs-number">10.0</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">24</span> 指定网段扫描   <br>     nmap -p22,<span class="hljs-number">80</span>,<span class="hljs-number">3306</span>  -p 指定多端口扫描   <br>     nmap -O <span class="hljs-number">10.0</span>.<span class="hljs-number">0.12</span>  探测目标主机操作系统类型<br>     nmap -A <span class="hljs-number">10.0</span>.<span class="hljs-number">0.12</span>  探测目标主机全部信息<br>   <br>    tcpdump -i eth0 -nn icmp <span class="hljs-keyword">and</span> src host <span class="hljs-number">10.0</span>.<span class="hljs-number">0.6</span> <span class="hljs-keyword">and</span> dst host <span class="hljs-number">10.0</span>.<span class="hljs-number">0.7</span>  <br>    解析：<br>     -i eth0: 这个选项指定了tcpdump应该监听的网络接口。<br>     -nn: 这个选项有两个部分：<br>        第一个 n 告诉 tcpdump 不要将地址解析为主机名（即，不要进行反向DNS查找）。<br>        第二个 n 告诉 tcpdump 不要将端口号解析为服务名（即，不要进行反向端口查找）。<br>      icmp: 这指定了tcpdump应该捕获的包类型 <span class="hljs-comment">-- ICMP数据包。</span><br>      <span class="hljs-keyword">and</span>: 这是逻辑运算符，用于组合多个过滤条件。<br>      src host <span class="hljs-number">10.0</span>.<span class="hljs-number">0.6</span>: 这个条件指定了数据包的源IP地址。<br>      dst host <span class="hljs-number">10.0</span>.<span class="hljs-number">0.7</span>: 这个条件指定了数据包的目的IP地址。   <br>   <br>   nc  <br>      -v|<span class="hljs-comment">--verbose #显示过程     </span><br>      -l| <span class="hljs-comment">--listen #使用监听模式，管控传入的资料 </span><br>            <br></code></pre></td></tr></table></figure><p>网桥</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">桥接：把一台机器上的若干个网络接口“连接”起来。其结果是，其中一个网口收到的报文会被复制给其他网口并发送出去。以使得网口之间的报文能够互相转发。网桥就是这样一个设备，它有若干个网口，并且这些网口是桥接起来的。与网桥相连的主机就能通过交换机的报文转发而互相通信。<br></code></pre></td></tr></table></figure><p>常用诊断工具</p><table><thead><tr><th>作用分类</th><th>工具&#x2F;命令</th></tr></thead><tbody><tr><td>测试网络连通性</td><td>fping</td></tr><tr><td>显示正确的路由表  跟踪路由  确定名称服务器使用  抓包工具  安全扫描工具  流量控制工具</td><td>ip route，route  traceroute，tracepath，mtr  nslookup，host，dig  tcpdump，wireshark  nmap，netcat(即nc)  tc</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>企业级堡垒机 JumpServer</title>
    <link href="/2024/11/09/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%A0%A1%E5%9E%92%E6%9C%BA%20JumpServer/"/>
    <url>/2024/11/09/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%A0%A1%E5%9E%92%E6%9C%BA%20JumpServer/</url>
    
    <content type="html"><![CDATA[<h1 id="企业级堡垒机-JumpServer"><a href="#企业级堡垒机-JumpServer" class="headerlink" title="企业级堡垒机 JumpServer"></a>企业级堡垒机 JumpServer</h1><h4 id="跳板机和堡垒机"><a href="#跳板机和堡垒机" class="headerlink" title="跳板机和堡垒机"></a>跳板机和堡垒机</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">跳板机<br>跳板机是一种用于单点登陆的主机应用系统。跳板机通常是由一台服务器通过特定的软件实现维护人员在维护过程中，首先要统一登录到这台服务器上，然后从这台服务器再登录到目标设备进行维护。<br>但跳板机没有实现对运维人员操作行为的控制和审计，此外，跳板机存在严重的安全风险，一旦跳板机系统被攻入，则将后端资源风险完全暴露无遗。<br>对于一些服务（如:telnet）可以通过跳板机来完成一定的控制访问，但是对于更多的服务（SSH、RDP等）来讲，就显得力不从心了。<br><br>堡垒机<br>由于跳板机的不足，更多的组织需要更先进、更好的安全技术,来实现运维操作管理和安全。<br>堡垒机开始以独立的产品形态被广泛部署，有效降低了运维操作风险，使得运维操作管理变得更简单、更安全。<br>堡垒机能满足角色管理与授权审批、信息资源访问控制、操作记录和审计、系统变更和维护控制要求，并生成一些统计报表配合管理规范，从而不断提升IT内控的合规性。<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;企业级堡垒机 JumpServer&#x2F;image-20250416191853145.png)</p><h4 id="JumpServer-生产应用场景"><a href="#JumpServer-生产应用场景" class="headerlink" title="JumpServer 生产应用场景"></a>JumpServer 生产应用场景</h4><p>!!!!![](..&#x2F;image&#x2F;企业级堡垒机 JumpServer&#x2F;image-20250416191956975.png)</p><h4 id="JumpServer的优势和功能"><a href="#JumpServer的优势和功能" class="headerlink" title="JumpServer的优势和功能"></a>JumpServer的优势和功能</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">特色优势<br>开源: 零门槛，线上快速获取和安装<br>分布式: 轻松支持大规模并发访问；<br>无插件: 仅需浏览器，极致的 Web Terminal 使用体验<br>多云支持: 一套系统，同时管理不同云上面的资产<br>云端存储: 审计录像云端存储，永不丢失<br>多租户: 一套系统，多个子公司和部门同时使用<br><br></code></pre></td></tr></table></figure><h5 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h5><p>!!!!![](..&#x2F;image&#x2F;企业级堡垒机 JumpServer&#x2F;image-20250416192121131.png)</p><p>堡垒机四个核心能力: 运维安全审计的4A规范</p><p>!!!!![](..&#x2F;image&#x2F;企业级堡垒机 JumpServer&#x2F;image-20250416192617753.png)</p><table><thead><tr><th>身份认证 Authentication</th><th>登录认证</th><th>资源统一登录与认证</th></tr></thead><tbody><tr><td>LDAP&#x2F;AD 认证</td><td>-</td><td>-</td></tr><tr><td>RADIUS 认证</td><td>-</td><td>-</td></tr><tr><td>OpenID 认证（实现单点登录）</td><td>-</td><td>-</td></tr><tr><td>CAS 认证（实现单点登录）</td><td>-</td><td>-</td></tr><tr><td>MFA 认证</td><td>MFA 二次认证（Google Authenticator）</td><td>-</td></tr><tr><td>RADIUS 二次认证</td><td>-</td><td>-</td></tr><tr><td>登录复核（X-PACK）</td><td>用户登录行为受管理员的监管与控制</td><td>-</td></tr><tr><td><strong>账号管理 Account</strong></td><td>集中账号</td><td>管理用户管理</td></tr><tr><td>系统用户管理</td><td>-</td><td>-</td></tr><tr><td>统一密码</td><td>资产密码托管</td><td>-</td></tr><tr><td>自动生成密码</td><td>-</td><td>-</td></tr><tr><td>自动推送密码</td><td>-</td><td>-</td></tr><tr><td>密码过期设置</td><td>-</td><td>-</td></tr><tr><td>批量改密（X-PACK）</td><td>定期批量改密</td><td>-</td></tr><tr><td>多种密码策略</td><td>-</td><td>-</td></tr><tr><td>多云纳管（X-PACK）</td><td>对私有云、公有云资产自动统一纳管</td><td>-</td></tr><tr><td>收集用户（X-PACK）</td><td>自定义任务定期收集主机用户</td><td>-</td></tr><tr><td>密码匣子（X-PACK）</td><td>统一对资产主机的用户密码进行查看、更新、测试操作</td><td>-</td></tr><tr><td><strong>授权控制 Authorization</strong></td><td>多维授权</td><td>对用户、用户组、资产、资产节点、应用以及系统用户进行授权</td></tr><tr><td>资产授权</td><td>资产以树状结构进行展示</td><td>-</td></tr><tr><td>资产和节点均可灵活授权</td><td>-</td><td>-</td></tr><tr><td>节点内资产自动继承授权</td><td>-</td><td>-</td></tr><tr><td>子节点自动继承父节点授权</td><td>-</td><td>-</td></tr><tr><td>应用授权</td><td>实现更细粒度的应用级授权</td><td>-</td></tr><tr><td>MySQL 数据库应用、RemoteApp 远程应用（X-PACK）</td><td>-</td><td>-</td></tr><tr><td>动作授权</td><td>实现对授权资产的文件上传、下载以及连接动作的控制</td><td>-</td></tr><tr><td>时间授权</td><td>实现对授权资源使用时间段的限制</td><td>-</td></tr><tr><td>特权指令</td><td>实现对特权指令的使用（支持黑白名单）</td><td>-</td></tr><tr><td>命令过滤</td><td>实现对授权系统用户所执行的命令进行控制</td><td>-</td></tr><tr><td>文件传输</td><td>SFTP 文件上传 &#x2F; 下载</td><td>-</td></tr><tr><td>文件管理</td><td>实现 Web SFTP 文件管理</td><td>-</td></tr><tr><td>工单管理（X-PACK）</td><td>支持对用户登录请求行为进行控制</td><td>-</td></tr><tr><td>组织管理（X-PACK）</td><td>实现多租户管理与权限隔离</td><td>-</td></tr><tr><td><strong>安全审计 Audit</strong></td><td>操作审计</td><td>用户操作行为审计</td></tr><tr><td>会话审计</td><td>在线会话内容审计</td><td>-</td></tr><tr><td>历史会话内容审计</td><td>-</td><td>-</td></tr><tr><td>录像审计</td><td>支持对 Linux、Windows 等资产操作的录像进行回放审计</td><td>-</td></tr><tr><td>支持对 RemoteApp（X-PACK）、MySQL 等应用操作的录像进行回放审计</td><td>-</td><td>-</td></tr><tr><td>指令审计</td><td>支持对资产和应用等操作的命令进行审计</td><td>-</td></tr><tr><td>文件传输</td><td>可对文件的上传、下载记录进行审计</td><td>-</td></tr></tbody></table><h4 id="JumpServer-组成"><a href="#JumpServer-组成" class="headerlink" title="JumpServer 组成"></a>JumpServer 组成</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Core 组件是 JumpServer 的核心组件，其他组件依赖此组件启动。<br>Koko 是服务于类 Unix 资产平台的组件，通过 SSH、Telnet 协议提供字符型连接。<br>Lion 是服务于 Windows 资产平台的组件，用于 Web 端访问 Windows 资产。<br>XRDP 是服务于 RDP 协议组件，该组件主要功能是通过 JumpServer Client 方式访问 windows2000、XP 等系统的资产。<br>Razor 是服务于 RDP 协议组件，JumpServer Client 默认使用 Razor 组件访问 Windows 资产。<br>Magnus 是服务于数据库的组件，用于通过客户端代理访问数据库资产。<br>Kael 是服务于 GPT 资产平台的组件，用于纳管 ChatGPT 资产。<br>Chen 是服务于数据库的组件，用于通过 Web GUI 方式访问数据库资产。<br>Celery 是处理异步任务的组件，用于执行 JumpServer 相关的自动化任务。<br>Video 是专门处理 Razor 组件和 Lion 组件产生录像的格式转换工作，将产生的会话录像转化为MP4 格式。<br></code></pre></td></tr></table></figure><h4 id="JumpServer-安装"><a href="#JumpServer-安装" class="headerlink" title="JumpServer 安装"></a>JumpServer 安装</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Mysql<br><br>docker run <span class="hljs-literal">--name</span> mysql <span class="hljs-literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> <span class="hljs-literal">-e</span> MYSQL_DATABASE=jumpserver <span class="hljs-literal">-e</span> MYSQL_USER=jumpserver <span class="hljs-literal">-e</span> MYSQL_PASSWORD=<span class="hljs-number">123456</span> <span class="hljs-literal">-d</span> <span class="hljs-literal">-v</span> ./mysqld.cnf:/etc/mysql/conf.d/mysqld.cnf <span class="hljs-literal">--restart</span> always <span class="hljs-literal">--network</span> jumpserver<span class="hljs-literal">-net</span> registry.cn<span class="hljs-literal">-beijing</span>.aliyuncs.com/wangxiaochun/mysql:<span class="hljs-number">8.0</span>.<span class="hljs-number">29</span><span class="hljs-literal">-oracle</span><br><br><br>Redis<br>docker run <span class="hljs-literal">-d</span> <span class="hljs-literal">--name</span> redis <span class="hljs-literal">--restart</span> always <span class="hljs-literal">--network</span> jumpserver<span class="hljs-literal">-net</span> registry.cn<span class="hljs-literal">-beijing</span>.aliyuncs.com/wangxiaochun/redis:<span class="hljs-number">7.2</span>.<span class="hljs-number">5</span> redis<span class="hljs-literal">-server</span> <span class="hljs-literal">--requirepass</span> <span class="hljs-number">123456</span><br><br><br>Jumpserver<br>docker run <span class="hljs-literal">--name</span> jms_all <span class="hljs-literal">-d</span> \<br>  <span class="hljs-literal">--network</span> jumpserver<span class="hljs-literal">-net</span> \<br>  <span class="hljs-literal">--restart</span> always \<br>  <span class="hljs-literal">-p</span> <span class="hljs-number">80</span>:<span class="hljs-number">80</span> \<br>  <span class="hljs-literal">-p</span> <span class="hljs-number">2222</span>:<span class="hljs-number">2222</span> \<br>  <span class="hljs-literal">-p</span> <span class="hljs-number">30000</span><span class="hljs-literal">-30100</span>:<span class="hljs-number">30000</span><span class="hljs-literal">-30100</span> \<br>  <span class="hljs-literal">-e</span> SECRET_KEY=gXqxW5aIdLs3DfLAjDDIyCb8IqD2bEtnYkGrPrdEDk2ETo9mxG \<br>  <span class="hljs-literal">-e</span> BOOTSTRAP_TOKEN=SjjdI4O1rmNqNpodd7qnazr5lKN9oR \<br>  <span class="hljs-literal">-e</span> LOG_LEVEL=ERROR \<br>  <span class="hljs-literal">-e</span> DB_ENGINE=mysql \<br>  <span class="hljs-literal">-e</span> DB_HOST=mysql \<br>  <span class="hljs-literal">-e</span> DB_PORT=<span class="hljs-number">3306</span> \<br>  <span class="hljs-literal">-e</span> DB_USER=jumpserver \<br>  <span class="hljs-literal">-e</span> DB_PASSWORD=<span class="hljs-number">123456</span> \<br>  <span class="hljs-literal">-e</span> DB_NAME=jumpserver \<br>  <span class="hljs-literal">-e</span> REDIS_HOST=redis \<br>  <span class="hljs-literal">-e</span> REDIS_PORT=<span class="hljs-number">6379</span> \<br>  <span class="hljs-literal">-e</span> REDIS_PASSWORD=<span class="hljs-number">123456</span> \<br>  <span class="hljs-literal">--privileged</span>=true \<br>  <span class="hljs-literal">-v</span> /opt/jumpserver/core/<span class="hljs-keyword">data</span>:/opt/jumpserver/<span class="hljs-keyword">data</span> \<br>  <span class="hljs-literal">-v</span> /opt/jumpserver/koko/<span class="hljs-keyword">data</span>:/opt/koko/<span class="hljs-keyword">data</span> \<br>  <span class="hljs-literal">-v</span> /opt/jumpserver/lion/<span class="hljs-keyword">data</span>:/opt/lion/<span class="hljs-keyword">data</span> \<br>  <span class="hljs-literal">-v</span> /opt/jumpserver/kael/<span class="hljs-keyword">data</span>:/opt/kael/<span class="hljs-keyword">data</span> \<br>  <span class="hljs-literal">-v</span> /opt/jumpserver/chen/<span class="hljs-keyword">data</span>:/opt/chen/<span class="hljs-keyword">data</span> \<br>  <span class="hljs-literal">-v</span> /opt/jumpserver/web/log:/var/log/nginx \<br>  jumpserver/jms_all:v4.<span class="hljs-number">8.1</span><br><br><br><br><br><br><br>docker volume create jsdata &amp;&gt; /dev/null<br>docker volume create pgdata &amp;&gt; /dev/null<br>docker run <span class="hljs-literal">--name</span> jms_all \<br>     <span class="hljs-literal">-e</span> SECRET_KEY=NCcm4YWap8HBBb5TRCQLh1P1Wt4k8h1Ut9zRbcJBzWQvirdxSJ \<br>     <span class="hljs-literal">-e</span> BOOTSTRAP_TOKEN=<span class="hljs-number">0</span>KlD4Jtp0ZHhjAspPtRssJ3VAOlqND \<br>     <span class="hljs-literal">-v</span> jsdata:/opt/<span class="hljs-keyword">data</span> \<br>     <span class="hljs-literal">-v</span> pgdata:/var/lib/postgresql \<br>     <span class="hljs-literal">-p</span> <span class="hljs-number">2222</span>:<span class="hljs-number">2222</span> \<br>     <span class="hljs-literal">-p</span> <span class="hljs-number">80</span>:<span class="hljs-number">80</span> jumpserver/jms_all:v4.<span class="hljs-number">8.1</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs pow">services:<br>  mysql:<br>    #image: mariadb:10.6<br>    image: registry.cn-beijing.aliyuncs.com/wangxiaochun/mariadb:10.6<br>    container_name: jms_mysql<br>    restart: always<br>    environment:<br>      MARIADB_ROOT_PASSWORD: $&#123;DB_PASSWORD:-123456&#125;<br>      MARIADB_DATABASE: $&#123;DB_NAME:-jumpserver&#125;<br>    healthcheck:<br>      test: &quot;mysql -h127.0.0.1 -uroot -p$$MARIADB_ROOT_PASSWORD -e &#x27;SHOW DATABASES;&#x27;&quot;<br>      interval: 10s<br>      timeout: 5s<br>      retries: 3<br>      start_period: 30s<br>    volumes:<br>      - $&#123;VOLUME_DIR:-./data&#125;/mariadb/data:/var/lib/mysql<br>    networks:<br>      - net<br>  redis:<br>    #image: redis:7.0<br>    image: registry.cn-beijing.aliyuncs.com/wangxiaochun/redis:7.2.5<br>    container_name: jms_redis<br>    restart: always<br>    command: redis-server --requirepass $&#123;REDIS_PASSWORD:-123456&#125;<br>    environment:<br>      REDIS_PASSWORD: $&#123;REDIS_PASSWORD:-123456&#125;<br>    healthcheck:<br>      test: &quot;redis-cli -h 127.0.0.1 -a $$REDIS_PASSWORD info Replication&quot;<br>      interval: 10s<br>      timeout: 5s<br>      retries: 3<br>      start_period: 10s<br>    volumes:<br>      - $&#123;VOLUME_DIR:-./data&#125;/redis/data:/data<br>    networks:<br>      - net<br>  jumpserver:<br>    image: jumpserver/jms_all:v4.8.1<br>    #image: registry.cn-beijing.aliyuncs.com/wangxiaochun/jms_all:v4.6.0<br>    #build:<br>    #  context: .<br>    #  dockerfile: Dockerfile<br>    container_name: jms_all<br>    privileged: true<br>    restart: always<br>    environment:<br>      SECRET_KEY: $&#123;SECRET_KEY:-LfFL6zB2mt4fMVq1D3hGKxxW0hopV1tlNicUHvsKJMQxsFPhBM&#125;<br>      BOOTSTRAP_TOKEN: $&#123;BOOTSTRAP_TOKEN:-OVxLWFfTmXRd2f0e&#125;<br>      LOG_LEVEL: $&#123;LOG_LEVEL:-ERROR&#125;<br>      DB_ENGINE: $&#123;DB_HOST:-mysql&#125; # 新版要求<br>      DB_HOST: $&#123;DB_HOST:-mysql&#125;<br>      DB_PORT: $&#123;DB_PORT:-3306&#125;<br>      DB_USER: $&#123;DB_USER:-root&#125;<br>      DB_PASSWORD: $&#123;DB_PASSWORD:-123456&#125;<br>      DB_NAME: $&#123;DB_NAME:-jumpserver&#125;<br>      REDIS_HOST: $&#123;REDIS_HOST:-redis&#125;<br>      REDIS_PORT: $&#123;REDIS_PORT:-6379&#125;<br>      REDIS_PASSWORD: $&#123;REDIS_PASSWORD:-123456&#125;<br>      DOMAINS: $&#123;DOMAINS:-&#125;<br>    ports:<br>      - $&#123;HTTP_PORT:-80&#125;:80/tcp<br>      - $&#123;SSH_PORT:-2222&#125;:2222/tcp<br>    depends_on:<br>      mysql:<br>        condition: service_healthy<br>      redis:<br>        condition: service_healthy<br>    healthcheck:<br>      test: &quot;curl -fsL http://localhost/api/health/ &gt; /dev/null&quot;<br>      interval: 10s<br>      timeout: 5s<br>      retries: 3<br>      start_period: 90s<br>    volumes:<br>      - $&#123;VOLUME_DIR:-./data&#125;/core/data:/opt/jumpserver/core/data<br>      - $&#123;VOLUME_DIR:-./data&#125;/koko/data:/opt/jumpserver/koko/data<br>      - $&#123;VOLUME_DIR:-./data&#125;/lion/data:/opt/jumpserver/lion/data<br>      - $&#123;VOLUME_DIR:-./data&#125;/chen/data:/opt/jumpserver/chen/data<br>      - $&#123;VOLUME_DIR:-./data&#125;/kael/data:/opt/jumpserver/kael/data<br>      - $&#123;VOLUME_DIR:-./data&#125;/web/log:/var/log/nginx<br>    networks:<br>      - net<br>networks:<br>  net:<br>    ipam:<br>      driver: default<br>      config:<br>        - subnet: 172.27.0.0/16<br>        <br>        <br>        <br>        <br>        <br>[root@bogon ~]$ VERSION=4.8.1<br>[root@bogon ~]$ curl -sSL https://resource.fit2cloud.com/jumpserver/jumpserver/releases/download/v$&#123;VERSION&#125;/quick_start.sh|bash<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell</title>
    <link href="/2024/09/29/shell/"/>
    <url>/2024/09/29/shell/</url>
    
    <content type="html"><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><figure class="highlight bash"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>普通变量：自定义变量名和变量值<br>   表示方法：<br>    变量名=变量值    变量值中间不能有特殊符号<br>    变量名=<span class="hljs-string">&#x27;变量值&#x27;</span>  完全当做变量<br>    变量名=<span class="hljs-string">&quot;变量值&quot;</span>  可以解析里面的内容<br>命令变量：自定义变量名，而变量值通过一条命令获取<br>   key=$(cmd)或key=`cmd`<br>      [root@bogon ~]# num=`<span class="hljs-built_in">seq</span> 10`<br>      [root@bogon ~]# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$num</span><br>      1 2 3 4 5 6 7 8 9 10<br> <br>   <br>       <br><br>        <br><br><br><br></code></pre></td></tr></table></figure><figure class="highlight bash"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">env</span>              查看全局环境变量 配合grep进行查找<br><br>变量=值<br><span class="hljs-built_in">export</span> 变量=值    定义全局环境变量 <br>  <br></code></pre></td></tr></table></figure><p>shell内置变量 特点：不需要去管理</p><figure class="highlight bash"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">变量文件： .bashrc结尾        可以加入变量  <br>        删除环境变量：  先清理.bashrc中的变量<br>                      <span class="hljs-built_in">unset</span> name    <br>        /etc/profile 在执行的时候，会自动去加载 /etc/profile.d/*.sh 文件内容，默认情况下，该目录下的文件都是 普通文件，作用范围都是超级用户。<br>        对于一些特殊的 软件级别的应用来说，如果我们在该目录下创建一个脚本环境文件，比如/etc/profile.d/xxx.sh, 如果在普通用户下不生效的话，可以尝试，添加 +x 权限来试试。  <br>                      <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">shell嵌套<br></code></pre></td></tr></table></figure><p>&#x20;        &#x20;</p><p>&#x20;     软件管理</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br> 程序如何去运行<br>1.编写程序<br>   -功能逻辑<br>2.调用底层库文件<br>   -posix文件集<br>3.调用底层系统的接口<br>  -ABI   <br> 程序编译：c语言为例<br>c程序源代码（获取代码）<br>1.预处理<br>2.编译（编译过程就是把预处理完的文件进行一系列的词法分析，语法分析，语义分析及优化后，最后生成的汇编<br>代码）<br>3.汇编（生成可执行文件 找到依赖库文件然后整合）（汇编是将汇编代码转变成机器码可以执行的命令，每一个汇编语句几乎都对应一条机器指令。汇编相对于<br>编译过程比较简单，根据汇编指令和机器指令的对照表一一翻译即可）<br>4.链接（通过调用链接器ld来链接程序运行需要的一大堆目标文件，以及所依赖的其它库文件，最后生成可执行文件）（系统级别 跟系统进行对接-） <br> 两种方式实现可执行文件和底层文件的关联<br>1.静态连接 （在程序编译时，将程序中使用的所有库文件（包括标准库和用户自定义库）中的代码和数据都 &quot;复制&quot;到最终的可执行文件中。<br> 这种方式的优点是程序在运行时不需要额外的库文件支持，但缺点是生成的可执行文件体积较大，且如果<br>库文件更新，需要重新编译整个程序。）（执行文件和库文件打包在一起）<br>2.动态链接（默认）（在程序编译时，不将库文件中的代码和数据复制到可执行文件中，而是在程序运行时 &quot;由操作系统动态加载&quot; 所需的库文件。<br> 这种方式的优点是减少了可执行文件的大小，且库文件更新后不需要重新编译整个程序，但缺点是程序运<br>行时需要依赖外部库文件。）（直接使用系统级别的库文件） <br> 库文件（共享库和给内核使用的专用库）（uname -r看系统架构）<br>内核库文件（内核模块文件通常以.ko(Kernel Object)或.o(Object)作为文件扩展名，并且位于/lib/modules/$(uname -r)/kernel/目录下的子目录中。加载和卸载内核模块可以使用insmod、rmmod、modprobe等命令进行。）<br>共享库文件（共享库文件在Linux上一般以.so（Shared Object）作为文件扩展名，它们被存储在/lib、/usr/lib或/usr/local/lib等目录下。动态链接器（Dynamic Linker/Loader）如ld.so（也称为ld-linux.so）在程序运行时负责将需要的共享库加载到内存中。）<br>如果我们将一个基础的库文件移除后，有可能导致所有的依赖该文件的命令都无法执行<br>命令：<br>软件使用问题：软件不运行：底层库问题<br>查看异常的执行文件查找 所依赖的库文件<br> ldd 二进制文件<br> ldconfig（加载配置文件中指定的库文件）<br> ldconfig -p（显示本机已经缓存的所有可用库文件名及文件路径映射关系） <br>  软件包管理<br> 软件包分类<br> 1.源码包（1.纯源码：编译过生成可执行文件2.源代码【编译过的】二进制文件携带系统架构信息）<br> 包含软件的源代码文件、编译指令和配置文件。<br><span class="hljs-code">    需要用户自行编译安装，过程相对复杂，但灵活性高，可以定制安装选项。</span><br><span class="hljs-code">    文件格式通常为.tar.gz、.tar.bz2等压缩格式。</span><br><span class="hljs-code">    注意：软件运行所有的文件都会在同一个包文件里面</span><br><span class="hljs-code"> 2.二进制包</span><br><span class="hljs-code"> 包含已经编译好的可执行文件、库文件、配置文件、帮助文件等，用户可以直接安装使用。</span><br><span class="hljs-code">    常见的二进制包格式有RPM包（Red Hat Package Manager）、DEB包（Debian Package）等。</span><br><span class="hljs-code">    注意：软件运行所有的文件分别放到相互依赖的多个包文件里面。</span><br><span class="hljs-code"> 包管理工具：yum|dnf apt</span><br><span class="hljs-code"> 查看包命令：</span><br><span class="hljs-code">  Centos系统中：</span><br><span class="hljs-code">    预览包内文件：rpm2cpio 包文件|cpio -itv</span><br><span class="hljs-code">    释放包内文件：rpm2cpio 包文件|cpio -idv &quot;.conf&quot;</span><br><span class="hljs-code">        </span><br><span class="hljs-code">ubuntu系统中：</span><br><span class="hljs-code">    预览包内文件：dpkg -c package.deb</span><br><span class="hljs-code">    释放包内文件：dpkg-deb -x package.deb 解压目录</span><br><span class="hljs-code">  仅下载不安装</span><br><span class="hljs-code">  Centos:</span><br><span class="hljs-code"> yum --downloadonly --downloaddir=./ xxx</span><br><span class="hljs-code"> Ubuntu:</span><br><span class="hljs-code">   apt-get install -d nginx</span><br><span class="hljs-code"> apt download xxx </span><br><span class="hljs-code">  二进制打包文件命名  </span><br><span class="hljs-code"> 命名示例：</span><br><span class="hljs-code"> httpd-2.4.57-15.el9.x86_64.rpm：</span><br><span class="hljs-code"> -----</span><br><span class="hljs-code">    httpd：软件包名。</span><br><span class="hljs-code">    2.4.57：包的版本号，格式为“主版本号.次版本号.修正号”。</span><br><span class="hljs-code">    15：二进制包发布的次数，表示这是第几次编译生成的。</span><br><span class="hljs-code">    el9：软件发行商，表示此包是由Red Hat公司发布，适合在RHEL|Centos|Rocky 9.x上使用。</span><br><span class="hljs-code">            EL是Red Hat Enterprise Linux（EL）的缩写</span><br><span class="hljs-code">    x86_64：表示此包使用的硬件平台。</span><br><span class="hljs-code">    rpm：RPM包的扩展名，表明这是编译好的二进制包，可以直接使用rpm命令安装。    </span><br><span class="hljs-code">  包分类：</span><br><span class="hljs-code"> 软件包为了管理和使用的便利，会将一个大的软件分类，放在不同的子包中。</span><br><span class="hljs-code">- Application-VERSION-ARCH.rpm: 主包</span><br><span class="hljs-code">- Application-core-VERSION-ARCH.rpm 核心功能包</span><br><span class="hljs-code">- Application-devel-VERSION-ARCH.rpm 开发子包</span><br><span class="hljs-code">- Application-utils-VERSION-ARHC.rpm 其它子包</span><br><span class="hljs-code">- Application-libs-VERSION-ARHC.rpm 其它子包</span><br><span class="hljs-code">包依赖：</span><br><span class="hljs-code">软件包之间可能存在依赖关系，甚至循环依赖，即：A包依赖B包，B包依赖C包，C包依赖A包，安装软件</span><br><span class="hljs-code">包时，会因为缺少依赖的包，而导致安装包失败。</span><br><span class="hljs-code"> 关于这些包的依赖关系，我们可以在不同的平台上，借助各自的软件包管理器来实现自动处理。 </span><br><span class="hljs-code"> 关于Rocky和ubuntu安装软件的注意事项：</span><br><span class="hljs-code">rocky安装软件</span><br><span class="hljs-code">    仅仅是安装软件，如果存在对应的服务需要手动去开启；</span><br><span class="hljs-code">    systemctl start 服务名</span><br><span class="hljs-code">ububtu安装软件</span><br><span class="hljs-code">不仅仅是安装软件，如果存在对应的服务会自动开启；</span><br><span class="hljs-code">（查看服务）systemctl status 服务名 </span><br><span class="hljs-code">获取软件包</span><br><span class="hljs-code">  1.光盘方式</span><br><span class="hljs-code">  2.线上方式</span><br><span class="hljs-code">    Community Enterprise Linux Repository：支持最新的内核和硬件相关包</span><br><span class="hljs-code">   http://www.elrepo.org</span><br><span class="hljs-code"> 包管理器rpm</span><br><span class="hljs-code">  命令格式</span><br><span class="hljs-code"> rpm &#123;-i|--install&#125; [install-options] PACKAGE_FILE…</span><br><span class="hljs-code">常用选项</span><br><span class="hljs-code"> -q # 检查安装软件</span><br><span class="hljs-code"> -ivh # 安装软件</span><br><span class="hljs-code"> -evh # 卸载软件</span><br><span class="hljs-code"> （卸载注意） 当包卸载时，对应的配置文件不会删除(前提是该文件被改动过)， 以FILENAME.rpmsave形式保留 </span><br><span class="hljs-code"> --root #在光盘救援模式下，安装软件到操作系统的所在位置路径，</span><br><span class="hljs-code">   #假如系统位置/mnt/sysimage，则在光盘下安装 使用如下命令</span><br><span class="hljs-code">   #rpm -ivh /path/to/file.rpm -root=/mnt/sysimage</span><br><span class="hljs-code"> --nodeps   #忽略依赖关系</span><br><span class="hljs-code"> --replacefiles      #忽略软件包之间的冲突的文件 </span><br><span class="hljs-code">  包查询：</span><br><span class="hljs-code">   命令格式：</span><br><span class="hljs-code">  rpm &#123;-q|--query&#125; [select-options] [query-options]</span><br><span class="hljs-code">    常用选项</span><br><span class="hljs-code">    -i #information</span><br><span class="hljs-code">    -l #查看指定的程序包安装后生成的所有文件</span><br><span class="hljs-code">    -f   #查看指定的文件由哪个程序包安装生成</span><br><span class="hljs-code">    -d #查询程序的文档</span><br><span class="hljs-code">     常用组合：-qi、-qf、-ql、-qa </span><br><span class="hljs-code">  包校验：</span><br><span class="hljs-code">  rpm --rebuilddb（重建数据库） </span><br><span class="hljs-code"> yum</span><br><span class="hljs-code"> 架构模式</span><br><span class="hljs-code"> yum/dnf 是基于C/S 模式</span><br><span class="hljs-code">    - yum 服务器存放rpm包和相关包的元数据库</span><br><span class="hljs-code">    - yum 客户端访问yum服务器进行安装或查询等 </span><br><span class="hljs-code">yum实现过程</span><br><span class="hljs-code">   先在yum服务器上创建 yum repository（仓库），在仓库中事先存储了众多rpm包，以及包的相关的元数据文件（放置于特定目录repodata下），当yum客户端利用yum/dnf工具进行安装包时，会自动下载repodata中的元数据，查询元数据是否存在相关的包及依赖关系，自动从仓库中找到相关包下载并安装。</span><br><span class="hljs-code">   如何下载软件:</span><br><span class="hljs-code">   1.指定服务器  </span><br><span class="hljs-code">   2.获取软件源信息（yum makecache）将服务端的软件属性信息拉到本地，在本地进行保存；</span><br><span class="hljs-code">        如果不想用了删除 --清理软件源信息（yum clean all）</span><br><span class="hljs-code">   3.查看|安装|卸载|检索软件等操作</span><br><span class="hljs-code">  客户端环境配置</span><br><span class="hljs-code">   yum客户端配置环境：</span><br><span class="hljs-code">   通用配置 --yum软件（/etc/yum.conf #为所有仓库提供公共配置）</span><br><span class="hljs-code">   专用配置 --特定软件源（/etc/yum.repos.d/*.repo #为每个仓库的提供配置文件）</span><br><span class="hljs-code">   定制软件源：</span><br><span class="hljs-code">     Rocky9.4上配置aliyun的repo源</span><br><span class="hljs-code">      [root@rocky9 yum.repos.d]# cat aliyun-baseos.repo </span><br><span class="hljs-code">          [aliyun-baseos]</span><br><span class="hljs-code">          name=aliyun baseos</span><br><span class="hljs-code">          baseurl=https://mirrors.aliyun.com/rockylinux/9.4/BaseOS/x86_64/os/</span><br><span class="hljs-code">          gpgcheck=0</span><br><span class="hljs-code"></span><br>   更新软件源<br><span class="hljs-code">     [root@rocky9 yum.repos.d]# yum makecache</span><br><span class="hljs-code">   查看源</span><br><span class="hljs-code">     [root@rocky9 yum.repos.d]# yum repolist</span><br><span class="hljs-code">   查看源信息</span><br><span class="hljs-code">     [root@rocky9 yum.repos.d]# yum repolist -v</span><br><span class="hljs-code">   查看指定源信息</span><br><span class="hljs-code">     [root@rocky9 yum.repos.d]# yum repolist --repoid=aliyun-baseos -v</span><br><span class="hljs-code">  本地repo源</span><br><span class="hljs-code">    定制专属的本地镜像源信息</span><br><span class="hljs-code">        [root@rocky9 yum.repos.d]# cat cdrom.repo </span><br><span class="hljs-code">         [cdrom-appstream]</span><br><span class="hljs-code">         name=cdrom appstream</span><br><span class="hljs-code">         baseurl=file:///mnt/AppStream/</span><br><span class="hljs-code">         gpgcheck=0</span><br><span class="hljs-code">         [cdrom-baseos]</span><br><span class="hljs-code">         name=cdrom baseos</span><br><span class="hljs-code">         baseurl=file:///mnt/BaseOS/</span><br><span class="hljs-code">         gpgcheck=0</span><br><span class="hljs-code">   yum命令</span><br><span class="hljs-code">    命令格式：</span><br><span class="hljs-code">   yum [options] COMMAND</span><br><span class="hljs-code">   常用子命令</span><br><span class="hljs-code">    autoremove               #卸载包，同时卸载依赖</span><br><span class="hljs-code">    clean                     #清除本地缓存</span><br><span class="hljs-code">    install                   #包安装</span><br><span class="hljs-code">    list                     #列出所有包</span><br><span class="hljs-code">    makecache                 #重建缓存</span><br><span class="hljs-code">    search                   #包搜索，包括包名和描述</span><br><span class="hljs-code">    yum list --installed  #查看所有已安装软件</span><br><span class="hljs-code">     --downloaddir path|--destdir path #指定下载目录,如果下载目录不存在，则自动创建</span><br><span class="hljs-code">     yum localinstall|install [options] rpmfile1 [...] #安装本地RPM包 </span><br><span class="hljs-code"> 软件组管理</span><br><span class="hljs-code">  常用：</span><br><span class="hljs-code">    yum grouplist [options] #列出所有包组</span><br><span class="hljs-code">    yum groupinstall [options] group1 [...] #包组安装</span><br><span class="hljs-code">    yum groupremove [options] group1 [...] #包组卸载 </span><br><span class="hljs-code"> 自建yum仓库</span><br><span class="hljs-code">   步骤：</span><br><span class="hljs-code">   1. 在 yum server 机上搭建 web 服务（nginx|apache），保证其它机器能能过web服务访问本机</span><br><span class="hljs-code">   2. 在 yum server 机上搭建 yum 仓库服务（获取软件；软件源数据信息）</span><br><span class="hljs-code">   3. 在 client 机上将yum 的 repos 源指向 yum server 机</span><br><span class="hljs-code">   4. 测试</span><br><span class="hljs-code">   </span><br><span class="hljs-code">   </span><br><span class="hljs-code">  </span><br><span class="hljs-code"> </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2024/09/27/Nginx/"/>
    <url>/2024/09/27/Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs ada">Nginx的结构:(web程序)<br>  在Nginx中，Master进程和Worker进程分别承担不同的角色，共同协作以提供高性能的服务<br>Master进程和Worker进程:<br>  Master进程：<br>    负责管理Worker进程的生命周期。<br>    处理来自管理员的信号。<br>    负责配置文件的加载和重新加载。<br>    启动、停止Worker进程，管理共享资源（如缓存）。<br>    <br>    - 启动过程：<br>      启动Nginx后，Master紧随启动。读取配置并初始化全局资源，并创建指定数量的Worker进程<br>    - 创建Worker进程：<br>      Master创建的Worker进程来处理实际的客户端请求。<br>      每个Worker进程都是一个独立的进程，它们之间相互独立，互不影响<br>    - 管理Worker进程：<br>      Master进程负责监控Worker进程的状态。<br>      若某个Worker进程异常退出，Master会重新启动一个新的Worker进程，确保服务可用     <br>  Worker进程:<br>    - 处理客户端请求：<br>      Worker进程是实际处理客户端请求的进程。<br>      每个Worker进程是单线程的，但通过多进程的方式，Nginx能够同时处理多个请求，实现高并发<br>    - 事件驱动和异步处理：<br>      Worker进程采用事件驱动的异步模型。<br>      它使用事件循环和非阻塞I/O操作，允许在不同的连接之间高效切换，以处理大量并发请求<br>    - 负载均衡：<br>      如果配置了负载均衡，多个Worker进程可以分担负载，均衡地分配请求，提高系统的整体性能  <br>  Master 进程 与 Worker 进程的联系:<br>    在运行时，Master 进程负责监控 Worker 进程的状态，<br>      如果某个 Worker 进程异常退出，Master 进程会重新启动一个新的 Worker 进程，确保服务的稳定性。<br>    Master 进程和 Worker 进程之间通过信号进行通信，<br>      例如在重新加载配置时，Master 进程会向 Worker 进程发送信号，通知它们重新加载配置而无需停止服务。    <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>  <br>    <br><br><br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/Nginx/image_HIaZ-YfNO5.png"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 数据库</title>
    <link href="/2024/09/08/MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2024/09/08/MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a><strong>MySQL</strong> <strong>数据库</strong></h1><hr><h2 id="title-MySQL-数据库date-2025-06-05-12-00-00categories-数据库-tags-MySQL-数据分类-description-MySQL-数据库中数据的分类概述与示例"><a href="#title-MySQL-数据库date-2025-06-05-12-00-00categories-数据库-tags-MySQL-数据分类-description-MySQL-数据库中数据的分类概述与示例" class="headerlink" title="title: MySQL 数据库date: 2025-06-05 12:00:00categories: [数据库]tags: [MySQL, 数据分类]description: MySQL 数据库中数据的分类概述与示例"></a>title: MySQL 数据库<br>date: 2025-06-05 12:00:00<br>categories: [数据库]<br>tags: [MySQL, 数据分类]<br>description: MySQL 数据库中数据的分类概述与示例</h2><h2 id="数据的分类"><a href="#数据的分类" class="headerlink" title="数据的分类"></a><strong>数据的分类</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">结构化数据<br>结构化数据一般是指可以用二维表来逻辑表达实现的数据。是有固定的格式和有限长度的数据，可以用关系型数据库表示和存储。<br> 其特点是：数据以行为单位，一行数据表示一个实体信息，每一行数据的属性是相同的，存储在数据库中；能够用统一的数据类型和结构加以表示；也能够用二维表结构来逻辑表达实现，包含属性和元组。<br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;MySQL 数据库&#x2F;image-20250306095427883.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">半结构化数据<br> 半结构化数据就是介于完全结构化数据和完全无结构的数据之间的数据。<br>    半结构化数据是结构化数据的一种形式，它并不符合关系型数据库或其它数据表的形式关联起来的数据模型结构，但包含相关的标记，用来分隔语义元素及对记录和字段进行分层，数据的结构和内容混在一起，没有明显的区分，因此，这种数据也被称为自描述结构的数据。<br>  例如：HTML文档、JSON、XML、yaml 和一些 NoSQL 数据库等就属于半结构化数据。<br><br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;MySQL 数据库&#x2F;image-20250306095604134.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">非结构化数据<br>  就是没有固定结构的数据，这种数据没有固定格式和有限长度，无法用数据库二维逻辑表来表现其结构，对于这类数据，我们一般进行整体存储。<br>  典型的非结构化数据包括：二进制文件，音视频文件，位置信息，markdown文件等 <br> <br></code></pre></td></tr></table></figure><h2 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">全称为实体联系模型、实体关系模型或实体联系模式图（ERD：Entity<span class="hljs-literal">-relationship</span> model），它提供不受任何DBMS约束的面向用户的表达方法，在数据库设计中被广泛用作数据建模的工具。<br>一般情况下，当我们要设计一个数据库或者数据表的时候，只要看到ER图，不管你用的是哪一种关系型数据库软件，你都可以将这个数据库和表建出来。<br></code></pre></td></tr></table></figure><p>E-R图模型的组成是由实体，属性和联系三部份组成。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">实体：( Entity ) <br> 实体是数据的使用者，代表软件系统中客观存在的生活中的实物，同一类实体构成实体集。<br> 在ER图中，实体用矩形表示。<br>属性：( Attribute ) <br> 实体中的所有特性称为属性，每个属性描述的是实体的单个特性。在ER图中，属性用椭圆形表示。<br>联系：( Relationship ) <br> 描述了实体的属性之间的关联规则。在ER图中，联系用菱形表示。<br></code></pre></td></tr></table></figure><p>ER模型范例：</p><p>!!!!![](..&#x2F;image&#x2F;MySQL 数据库&#x2F;image-20250306095930198.png)</p><p>实体间的联系有三种类型：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">一对一联系 ( <span class="hljs-number">1</span>:<span class="hljs-number">1</span> )：<br> 例如，一个学号只能分配给一个同学，每个同学都有一个学号，则学号与同学的联系是一对一。<br>一对多联系 ( <span class="hljs-number">1</span>:n )：<br> 例如，一个老师可以教授多门课程，每门课程只能有一个老师教授，则老师与课程的联系是一对多。<br>多对多联系 ( m:n )：<br> 例如，一个同学可以报名多门课程，每门课程下有多个同学，则同学与课程的联系是多对多。<br></code></pre></td></tr></table></figure><h2 id="SQL-结构化查询语言"><a href="#SQL-结构化查询语言" class="headerlink" title="SQL 结构化查询语言"></a>SQL <strong>结构化查询语言</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SQL：( Structure Query Language )， 结构化查询语言。<br>  是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统，SQL语句就是用SQL语言写的用于操作数据库的语句。<br>工作模式:<br>  关系型数据库一般工作于C/S模式下，使用专有协议进行通信，服务端程序监听特有端口，客户端程序发送查询语句到服务端，服务端将查询结果返回给客户端。<br>  MySQL自带<span class="hljs-built_in">CLI</span> 接口，GUI 接口可以使用第三方工具实现，在应用程序或后端开发语言中，使用相应的编程语言下的数据库驱动来进行与数据库服务端的通信。  <br> <br>  <br></code></pre></td></tr></table></figure><p>MySQL数据库中的SQL查询语句执行流程</p><p>!!!!![](..&#x2F;image&#x2F;MySQL 数据库&#x2F;image-20250306100230762.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-number">1</span> 接收查询语句：<br> 用户通过客户端或编程语言框架里面的驱动模块，经由专门的通信协议，向MySQL服务器发送SQL查询语句。<br> 如果是mysql服务端，这里的通信协议端口是 <span class="hljs-number">3306</span><br> 数据库服务端内部的连接器接收查询请求后，首先到本地的缓存记录中检索信息<br> 如果有信息，则直接返回查询结果<br> 如果没有信息，则将信息直接传递给后端的数据库解析器来进行处理<br> <br><span class="hljs-number">2</span> 词法分析和语法分析：<br> MySQL服务器首先会对接收到的查询语句进行词法分析，将其分解成一系列的词法单元。<br> 接着，进行语法分析，检查这些词法单元是否符合SQL语法规则。如果语法错误，MySQL会立即返回错误信息。<br><br><span class="hljs-number">3</span> 语义分析：<br>    在语法分析之后，MySQL会进行语义分析，检查查询语句中的表、列、函数等是否存在，以及用户是否有足够的权限执行该查询。<br>    语义分析还会检查查询语句中的数据类型是否匹配，以及是否存在违反数据库完整性的约束。<br><br><span class="hljs-number">4</span> 查询优化：<br>    MySQL的查询优化器会对查询语句进行优化，决定最优的执行查询计划 <span class="hljs-literal">--</span> 也就是怎么走会效率更快。<br>    优化过程包括选择最佳的访问路径、索引、连接顺序等，以最小化查询的执行时间和资源消耗。<br>    优化器还会考虑统计信息，如表的行数、索引的分布等，以做出更明智的决策。<br><br><span class="hljs-number">5</span> 查询执行：<br>    优化后的查询计划被传递给执行器进行执行。执行器根据查询计划访问存储引擎，获取数据。<br>   存储引擎将文件系统里面的数据库文件数据，加载到内存，然后在内存中做一次聚合<br>   然后，临时放到查询缓存中，便于下次遇到相同的查询语句重复过来。<br>    在执行过程中，MySQL可能会使用缓存来加速查询的执行。从MySQL <span class="hljs-number">8.0</span>开始，查询缓存已被移除。<br><br><span class="hljs-number">6</span> 结果集返回：<br> 执行器将查询结果集返回给客户端。结果集可以包含零行或多行数据，具体取决于查询的内容。<br> 如果查询涉及聚合函数（如SUM、AVG等）或分组操作（如<span class="hljs-built_in">GROUP</span> BY），执行器还会在返回结果之前对这些数据进行相应的处理。<br><br><span class="hljs-number">7</span> 错误处理和日志记录：<br> 如果在执行过程中遇到任何错误（如权限不足、表不存在等），MySQL会返回相应的错误信息给客户端。<br>  同时，MySQL还会记录查询的执行日志，以便进行性能分析和故障排查。<br></code></pre></td></tr></table></figure><h2 id="MySQL-安装和基本使用"><a href="#MySQL-安装和基本使用" class="headerlink" title="MySQL 安装和基本使用"></a><strong>MySQL</strong> 安装和基本使用</h2><h3 id="MySQL-软件"><a href="#MySQL-软件" class="headerlink" title="MySQL 软件"></a><strong>MySQL</strong> 软件</h3><p>!!!!![](..&#x2F;image&#x2F;MySQL 数据库&#x2F;image-20250306100537304.png)</p><p>MySQL 的特性</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">- MySQL 是基于开源协议发布的，可以免费使用，也可以基于源码进行二次开发。<br>- MySQL 使用标准 SQL 语言进行管理。<br>- MySQL 可以运行于多个系统上，具有跨平台特性，并且支持多种语言。<br>- MySQL 使用插件式存储引擎，不同的存储引擎，有着不同的功能和特性，使用者可以根据需要灵活选择。<br>- MySQL 基于单进程，多线程的模式进行工作。<br>- MySQL 提供了大量的测试组件和诸多的扩展。<br></code></pre></td></tr></table></figure><h3 id="MySQL-安装方式"><a href="#MySQL-安装方式" class="headerlink" title="MySQL 安装方式"></a><strong>MySQL</strong> 安装方式</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">root</span>@<span class="hljs-type">rocky9</span> ~]<span class="hljs-comment"># yum install -y mysql-server</span><br>root@ubuntu24:~<span class="hljs-comment"># apt install mysql-server -y</span><br></code></pre></td></tr></table></figure><h3 id="mariadb安装方式"><a href="#mariadb安装方式" class="headerlink" title="mariadb安装方式"></a><strong>mariadb</strong>安装方式</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">root</span>@<span class="hljs-type">rocky9</span> ~]<span class="hljs-comment"># yum install mariadb-server -y</span><br></code></pre></td></tr></table></figure><h2 id="MySQL-多实例"><a href="#MySQL-多实例" class="headerlink" title="MySQL 多实例"></a><strong>MySQL</strong> <strong>多实例</strong></h2><h3 id="数据库多实例"><a href="#数据库多实例" class="headerlink" title="数据库多实例"></a>数据库多实例</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">拿 MySQL 数据库来说明，就是在一台服务器上运行多个 MySQL 服务端进程，每个进程监听一个端口（<span class="hljs-number">3306</span>，<span class="hljs-number">3307</span>，<span class="hljs-number">3308</span>），维护一套属于其自己的配置和数据，客户端使用不同的端口来连接具体服端进程，从而实现对不同的实例的操作。<br></code></pre></td></tr></table></figure><p>多实例的优点</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">- 节约硬件资源：<br> 在某些场景下（比如说测试，调研，新旧业务并存等），需要配置不同的 MySQL 数据库版本，而又没有<br>足够多的服务器资源，则可以选择在一台服务器上用不同的版本实现多开来满足需求。<br> <br>- 便于对比：<br> 在一个完全相同的硬件环境中，运行不同的 MySQL 版本，使用相同的参数进行测试，调研时，可以最大<br>程度的减少外部环境因素的影响，便于得出更准确的结论。<br> <br>- 便于管理：<br> 在一台服务器上运行多个实例，同理，只需要在这一台服务器上配置安全规则，就可以完成对多个实例的<br>访问授权，而且对于数据库的备份，停启等工作，也只需要在这一台服务器上完成。<br></code></pre></td></tr></table></figure><p>多实例的缺点</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">- 资源抢占：<br> 一台服务器上运行多个服务实例，资源总量恒定，一个实例占用的资源无法被另一个实例所使用，在这种情况下，服务性能会受到影响，无法体现 MySQL 服务的实际性能。<br>- 存在单点风险：<br> 一台服务器上部署多个服务实例，如果该服务器当机，则这多个服务实例都会受影响。<br></code></pre></td></tr></table></figure><h2 id="MySQL-组成和常用工具"><a href="#MySQL-组成和常用工具" class="headerlink" title="MySQL 组成和常用工具"></a><strong>MySQL</strong> <strong>组成和常用工具</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mysql 基于 C/S 模式提供服务，主要有客户端程序和服务端程序组成，另外还有一些管理工具。<br></code></pre></td></tr></table></figure><h2 id="MySQL-命令行操作"><a href="#MySQL-命令行操作" class="headerlink" title="MySQL 命令行操作"></a><strong>MySQL</strong> <strong>命令行操作</strong></h2><h3 id="MySQL-命令行工具"><a href="#MySQL-命令行工具" class="headerlink" title="MySQL****命令行工具"></a><strong>MySQL****命令行工具</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL 服务基于 C/S 架构，用户主要使用客户端工具来与远程服务端进行连接，从而与 MySQL 服务进行交互。<br>MySQL 客户端常用选项<br>  mysql [<span class="hljs-type">OPTIONS</span>] [<span class="hljs-type">database</span>]<br>  常用选项<br>  <span class="hljs-literal">-V</span>|<span class="hljs-literal">--version</span> <span class="hljs-comment">#显示客户端版本</span><br>  <span class="hljs-literal">-u</span>|<span class="hljs-literal">--user</span>=name <span class="hljs-comment">#指定远程连接用户名</span><br>  <span class="hljs-literal">-p</span>|<span class="hljs-literal">--password</span>[=<span class="hljs-type">name</span>] <span class="hljs-comment">#指定密码, 默认为空</span><br>  <span class="hljs-literal">-h</span>|<span class="hljs-literal">--host</span>=host     <span class="hljs-comment">#指定服务端主机</span><br>  <span class="hljs-literal">-P</span>|<span class="hljs-literal">--port</span>=port <span class="hljs-comment">#指定端口，默认3306</span><br>  <span class="hljs-literal">-S</span>|<span class="hljs-literal">--socket</span>=name <span class="hljs-comment">#指定连接时使用的socket文件，该文件在服务端启动后生成</span><br>  <span class="hljs-literal">-D</span>|<span class="hljs-literal">--database</span>=db <span class="hljs-comment">#指定数据库</span><br>  <span class="hljs-literal">-H</span>|<span class="hljs-literal">--html</span>         <span class="hljs-comment">#以html格式输出</span><br>  <span class="hljs-literal">-X</span>|<span class="hljs-literal">--xml</span>           <span class="hljs-comment">#以xml格式输出</span><br>  <span class="hljs-literal">-t</span>|<span class="hljs-literal">--table</span> <span class="hljs-comment">#以table格式输出，默认项</span><br>  <span class="hljs-literal">-E</span>|<span class="hljs-literal">--vertical</span> <span class="hljs-comment">#垂直显示执行结果</span><br>  <span class="hljs-literal">-v</span>|<span class="hljs-literal">--verbose</span> <span class="hljs-comment">#显示详细信息，配合 -t 选项</span><br>  <span class="hljs-literal">-C</span>|<span class="hljs-literal">--compress</span> <span class="hljs-comment">#启用压缩</span><br>  <span class="hljs-literal">-G</span>|<span class="hljs-literal">--named-commands</span> <span class="hljs-comment">#启用长命令</span><br>  <span class="hljs-literal">-e</span>|<span class="hljs-literal">--execute</span>=sql <span class="hljs-comment">#执行完就退出，非交互式运行</span><br>  <span class="hljs-literal">--prompt</span>=name <span class="hljs-comment">#修改命令提示符</span><br>  <span class="hljs-literal">--line-numbers</span>     <span class="hljs-comment">#输出行号</span><br>  <span class="hljs-literal">--print-defaults</span> <span class="hljs-comment">#打印参数列表，放在最前面</span><br>  <span class="hljs-literal">--connect-timeout</span>=N <span class="hljs-comment">#连接超时时长，单位S</span><br>  <span class="hljs-literal">--max-allowed-packet</span>=N <span class="hljs-comment">#一次查交互发送或反回数据的大小，默认16MB，最大值为1GB，最小值为4096字节  </span><br></code></pre></td></tr></table></figure><h2 id="mysql客户端命令"><a href="#mysql客户端命令" class="headerlink" title="mysql客户端命令"></a>mysql客户端命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL 中的命令分为两类，分别是客户端命令和服务端命令。<br>客户端命令在本地执行。服务端命令发送到服务端执行，再返回执行结果到客户端上。<br>客户端命令和服务端命令，都是通过MySQL 客户端工具进行输入输出。<br></code></pre></td></tr></table></figure><p>MySQL 客户端命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MariaDB [(<span class="hljs-type">none</span>)]&gt; ?<br><span class="hljs-comment">#常用命令</span><br>?|\? <span class="hljs-comment">#显示帮助</span><br>help|\h <span class="hljs-comment">#显示帮助</span><br><span class="hljs-built_in">clear</span>|\c <span class="hljs-comment">#清屏，直接使用无法生效，要配合 system 命令使用，清掉未执行的输入</span><br><span class="hljs-keyword">exit</span>|\q <span class="hljs-comment">#退出客户端</span><br>quit|\q <span class="hljs-comment">#退出客户端</span><br>status|\s <span class="hljs-comment">#显示当前状态</span><br>use|\u <span class="hljs-comment">#切换数据库</span><br>system|\! <span class="hljs-comment">#调用系统命令</span><br>prompt|\R <span class="hljs-comment">#修改提示符</span><br>source|\. <span class="hljs-comment">#执行SQL脚本文件</span><br>connect|\r <span class="hljs-comment">#客户端重新连接，使用之前的参数</span><br><span class="hljs-built_in">tee</span>|\T <span class="hljs-comment">#设置文件名，将输出结果同时保存一份到指定文件</span><br>notee|\t <span class="hljs-comment">#不保存输出结果至文件</span><br>delimiter|\d <span class="hljs-comment">#自定义SQL语句分隔符</span><br>go|\g <span class="hljs-comment">#将语句送到服务端执行</span><br>ego|\G <span class="hljs-comment">#将语句送到服务端执行，垂直显示</span><br>print|\p <span class="hljs-comment">#输出语句，但不执行</span><br>warnings|\W <span class="hljs-comment">#总是输出告警信息</span><br>nowarning|\w <span class="hljs-comment">#不输出告警信息</span><br>charset|\C <span class="hljs-comment">#设置编码</span><br>edit|\e <span class="hljs-comment">#先编辑SQL语句，再执行</span><br></code></pre></td></tr></table></figure><h2 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a><strong>mysqladmin</strong></h2><h5 id="mysqladmin-只能关闭服务，不能启动服务"><a href="#mysqladmin-只能关闭服务，不能启动服务" class="headerlink" title="mysqladmin 只能关闭服务，不能启动服务"></a>mysqladmin 只能关闭服务，不能启动服务</h5><h5 id="mysqladmin-shutdown"><a href="#mysqladmin-shutdown" class="headerlink" title="mysqladmin shutdown"></a>mysqladmin shutdown</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mysqladmin 也是用于管理 mysql 服务的本地工具。<br>格式：<br>mysqladmin [<span class="hljs-type">OPTIONS</span>] command command....<br>常用选项<br>-?|<span class="hljs-literal">--help</span>         <span class="hljs-comment">#显示帮助信息</span><br><span class="hljs-literal">-V</span>|<span class="hljs-literal">--version</span>       <span class="hljs-comment">#显示客户端版本</span><br><span class="hljs-operator">-f</span>|<span class="hljs-literal">--force</span>         <span class="hljs-comment">#删库时不确认</span><br><span class="hljs-literal">-C</span>|<span class="hljs-literal">--compress</span>     <span class="hljs-comment">#启用压缩</span><br><span class="hljs-literal">-h</span>|<span class="hljs-literal">--host</span>=name     <span class="hljs-comment">#指定服务器地址</span><br><span class="hljs-literal">-u</span>|<span class="hljs-literal">--user</span>=name     <span class="hljs-comment">#指定用户名</span><br><span class="hljs-literal">-p</span>|<span class="hljs-literal">--password</span>[=<span class="hljs-type">name</span>] <span class="hljs-comment">#指定连接服务器的密码</span><br><span class="hljs-literal">-P</span>|<span class="hljs-literal">--port</span>=N       <span class="hljs-comment">#指定连接端口，默认3306</span><br><span class="hljs-literal">-l</span>|<span class="hljs-literal">--local</span>         <span class="hljs-comment">#在本地执行，语句不写入binlog</span><br><span class="hljs-literal">-b</span>|<span class="hljs-literal">--no-beep</span>       <span class="hljs-comment">#执行出错时不发出告警音</span><br><span class="hljs-literal">-s</span>|<span class="hljs-literal">--silent</span>       <span class="hljs-comment">#如果无法连接，则静默退出</span><br><span class="hljs-literal">-c</span>|<span class="hljs-literal">--count</span>=N       <span class="hljs-comment">#总共执行多少次，配合-i选项使用</span><br><span class="hljs-literal">-i</span>|<span class="hljs-literal">--sleep</span>=N     <span class="hljs-comment">#持续执行命令，间隔N秒执行一次</span><br><span class="hljs-literal">-S</span>|<span class="hljs-literal">--socket</span>=name <span class="hljs-comment">#指定连接时使用的socket文件</span><br><span class="hljs-literal">-w</span>|<span class="hljs-literal">--wait</span>[=<span class="hljs-comment">#]     #如果连接失败，是否等待重试，如果指定了具体数字，则表示重试几次</span><br>--<span class="hljs-type">plugin</span>-<span class="hljs-type">dir</span>=<span class="hljs-type">name</span>   <span class="hljs-comment">#客户端查件目录</span><br>--<span class="hljs-type">print</span>-<span class="hljs-type">defaults</span>         <span class="hljs-comment">#显示运行参数，</span><br>--<span class="hljs-type">defaults</span>-<span class="hljs-type">file</span>=<span class="hljs-type">path</span>     <span class="hljs-comment">#从指定文件中读取选项</span><br>--<span class="hljs-built_in">connect-timeout</span>=<span class="hljs-type">N</span> <span class="hljs-comment">#指定连接超时时长</span><br>--<span class="hljs-type">shutdown</span>-<span class="hljs-type">timeout</span>=<span class="hljs-type">N</span> <span class="hljs-comment">#指定关机超时时长</span><br>--<span class="hljs-type">protocol</span>=<span class="hljs-type">name</span>     <span class="hljs-comment">#指定连接方式 (tcp|socket|pipe|memory)</span><br>--<span class="hljs-type">ssl</span>                   <span class="hljs-comment">#使用ssl安全功能</span><br>命令<br><span class="hljs-type">create</span> <span class="hljs-type">databasename</span> <span class="hljs-comment">#创建新的数据库</span><br><span class="hljs-type">debug</span> <span class="hljs-comment">#开启调试模式，将调试信息写入log</span><br><span class="hljs-type">drop</span> <span class="hljs-type">databasename</span> <span class="hljs-comment">#删除指定数据库</span><br><span class="hljs-type">extended</span>-<span class="hljs-type">status</span>         <span class="hljs-comment">#显示扩展状态</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">all</span>-<span class="hljs-type">statistics</span>   <span class="hljs-comment">#刷新所有统计表</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">all</span>-<span class="hljs-type">status</span>       <span class="hljs-comment">#刷新状态和统计信息</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">client</span>-<span class="hljs-type">statistics</span> <span class="hljs-comment">#刷新客户端统计信息</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">hosts</span>           <span class="hljs-comment">#刷新所有缓存的主机</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">index</span>-<span class="hljs-type">statistics</span> <span class="hljs-comment">#刷新索引统计信息</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">logs</span>             <span class="hljs-comment">#刷新所有日志</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">privileges</span>       <span class="hljs-comment">#刷新访问权限</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">binary</span>-<span class="hljs-type">log</span>       <span class="hljs-comment">#刷新二进制日志</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">engine</span>-<span class="hljs-type">log</span>       <span class="hljs-comment">#刷新引擎日志</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">error</span>-<span class="hljs-type">log</span>         <span class="hljs-comment">#刷新错误日志，开一个新日志文件</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">general</span>-<span class="hljs-type">log</span>       <span class="hljs-comment">#刷新执行日志</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">relay</span>-<span class="hljs-type">log</span>         <span class="hljs-comment">#刷新中继日志</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">slow</span>-<span class="hljs-type">log</span>         <span class="hljs-comment">#刷新慢查询日志</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">status</span>           <span class="hljs-comment">#清除状态变量</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">table</span>-<span class="hljs-type">statistics</span> <span class="hljs-comment">#清除表统计信息</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">tables</span>           <span class="hljs-comment">#刷新所有表，会强制关闭己打开的表</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">threads</span>           <span class="hljs-comment">#刷新线程缓存</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">user</span>-<span class="hljs-type">statistics</span>   <span class="hljs-comment">#刷新用户统计信息</span><br><span class="hljs-type">flush</span>-<span class="hljs-type">user</span>-<span class="hljs-type">resources</span>   <span class="hljs-comment">#刷新用户资源</span><br><span class="hljs-type">kill</span> <span class="hljs-type">id</span>,<span class="hljs-type">id</span>,<span class="hljs-type">...</span> <span class="hljs-comment">#关闭指定的线程</span><br><span class="hljs-type">password</span> [<span class="hljs-built_in">new-password</span>] <span class="hljs-comment">#修改密码</span><br><span class="hljs-type">old</span>-<span class="hljs-type">password</span> [<span class="hljs-built_in">new-password</span>] <span class="hljs-comment">#修改密码时指定旧密码</span><br><span class="hljs-type">ping</span> <span class="hljs-comment">#心跳检测</span><br><span class="hljs-type">processlist</span> <span class="hljs-comment">#显示活动线程列表</span><br><span class="hljs-type">reload</span> <span class="hljs-comment">#刷新授权信息</span><br><span class="hljs-type">refresh</span> <span class="hljs-comment">#刷新所有数据表，重新打开日志文件</span><br><span class="hljs-type">shutdown</span> <span class="hljs-comment">#关闭服务</span><br><span class="hljs-type">status</span> <span class="hljs-comment">#简短显示服务端状态</span><br><span class="hljs-built_in">start-slave</span> <span class="hljs-comment">#开启主从同步</span><br><span class="hljs-built_in">stop-slave</span> <span class="hljs-comment">#停止主从同步</span><br><span class="hljs-type">variables</span>             <span class="hljs-comment">#显示服务端所有变量</span><br><span class="hljs-type">version</span> <span class="hljs-comment">#显示客户端和服务端版本</span><br></code></pre></td></tr></table></figure><p>mysql信息显示</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mysqladmin <span class="hljs-literal">-V</span>  客户端版本  <br>mysqladmin version  服务端版本信息<br>mysqladmin status  显示状态信息<br>mysqladmin <span class="hljs-literal">--connect-timeout</span>=<span class="hljs-number">2</span> ping  测试主机服务存活性  <br></code></pre></td></tr></table></figure><p>数据库操作</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mysqladmin create db1  创建数据库<br>mysqladmin drop db3306  删除数据库(一次只能删一个)<br><br></code></pre></td></tr></table></figure><p><strong>mycli</strong> <strong>工具</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MyCLI 是基于 Python 开发的 MySQL 的命令行工具，具有自动完成和语法突出显示功能<br><br></code></pre></td></tr></table></figure><h2 id="SQL-语言"><a href="#SQL-语言" class="headerlink" title="SQL 语言"></a><strong>SQL</strong> <strong>语言</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">关系数据库的构成<br></code></pre></td></tr></table></figure><table><thead><tr><th><strong>组件</strong></th><th><strong>关键字</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>数据库</td><td>database</td><td>表的集合，一个数据库中可以有多个表，在文件系统中表现为一个目录</td></tr><tr><td>表</td><td>table</td><td>在数据库中以二维表的形式出现，有行和列，数据库中的数据就是存放于表中的</td></tr><tr><td>索引</td><td>index</td><td>索引通常建立在一个列上，用以加快数据查询速度</td></tr><tr><td>视图</td><td>view</td><td>用 SQL 语言构建的虚拟表，可以临时把两个或多个表以逻辑关系关联，对外提供查询</td></tr><tr><td>存储过程</td><td>procedure</td><td>存储过程是一组为了完成特定功能的 SQL 语句集合，客户端可以直接调用</td></tr><tr><td>存储函数</td><td>function</td><td>存储函数和存储过程一样，都是 SQL 语句集合，但可以使用参数</td></tr><tr><td>触发器</td><td>trigger</td><td>触发器也是由 SQL 语句的集合组成，但需要达到触发条件才能调用</td></tr><tr><td>事件调度器</td><td>event scheduler</td><td>数据库中的计划任务</td></tr><tr><td>用户</td><td>user</td><td>连接服务端时的用户名</td></tr><tr><td>权限</td><td>privilege</td><td>每个用户可以对哪些数据库或表进行操作，以及在什么 IP 下能连接</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SQL：( Structured Query Language ) 结构化查询语言<br><br>SQL 语言规范:<br>- 在数据库系统中，SQL 语句不区分大小写，建议用大写。<br>- SQL语句可单行或多行书写，默认以 <span class="hljs-string">&quot; ; &quot;</span> 结尾。<br>- 关键词不能跨多行或简写。<br>- 用空格和TAB 缩进来提高语句的可读性。<br>- 子句通常位于独立行，便于编辑，提高可读性。<br><br><span class="hljs-selector-tag">@</span>符号:<br>在 SQL 中，特别是在 MySQL 和 MariaDB 这样的数据库系统中，<span class="hljs-selector-tag">@</span><span class="hljs-selector-tag">@</span> 前缀用于访问系统变量（system variables）。系统变量是数据库服务器在运行时维护的一组值，这些值可以影响服务器的操作或提供有关服务器状态的信息。<br></code></pre></td></tr></table></figure><h2 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a><strong>SQL</strong> <strong>语句</strong></h2><h4 id="类型简介"><a href="#类型简介" class="headerlink" title="类型简介"></a><strong>类型简介</strong></h4><table><thead><tr><th><strong>SQL 语句类型</strong></th><th><strong>说明</strong></th><th><strong>具体语句</strong></th></tr></thead><tbody><tr><td>DDL</td><td>Data Definition Language 数据定义语言</td><td>CREATE, DROP, ALTER</td></tr><tr><td>DML</td><td>Data Manipulation Language 数据操作语言</td><td>INSERT, DELETE, UPDATE</td></tr><tr><td>DQL</td><td>Data Query Language 数据查询语言</td><td>SELECT</td></tr><tr><td>DCL</td><td>Data Control Language 数据控制语言</td><td>GRANT, REVOKE</td></tr><tr><td>TCL</td><td>Transaction Control Language 事务控制语言</td><td>BEGIN, COMMIT, ROLLBACK, SAVEPOINT</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">示例:<br><span class="hljs-built_in">select</span> host,user,password from mysql.user <span class="hljs-built_in">where</span> Password =<span class="hljs-string">&#x27;1&#x27;</span>;<br>SHOW DATABASES; 查看数据库列表<br>create database testdb1;  创建一个名叫testdb1的数据库<br>修改数据库命令格式:<br>ALTER &#123;DATABASE | SCHEMA&#125; [<span class="hljs-type">db_name</span>]<br>   alter_specification ...<br>ALTER &#123;DATABASE | SCHEMA&#125; db_name<br>   UPGRADE <span class="hljs-keyword">DATA</span> DIRECTORY NAME<br>alter_specification:<br>   [<span class="hljs-type">DEFAULT</span>] CHARACTER <span class="hljs-built_in">SET</span> [=] charset_name<br> | [<span class="hljs-type">DEFAULT</span>] COLLATE [=] collation_name<br>删除数据库命令格式:<br>DROP DATABASE|SCHEMA [<span class="hljs-type">IF</span> <span class="hljs-type">EXISTS</span>] <span class="hljs-string">&#x27;DB_NAME&#x27;</span>;<br>DROP DATABASE testdb2;<br>DROP DATABASE <span class="hljs-keyword">IF</span> EXISTS testdb1;<br><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MariaDB [(<span class="hljs-type">none</span>)]&gt; SHOW DATABASES;<br>+<span class="hljs-literal">--------------------</span>+<br>| Database           |<br>+<span class="hljs-literal">--------------------</span>+<br>| information_schema |<br>| mysql             |<br>| performance_schema |<br>| test               |<br>+<span class="hljs-literal">--------------------</span>+<br><span class="hljs-number">4</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br>information_schema:<br> 这是一个特殊的系统数据库，包含了关于其他数据库的信息，如表结构、列信息、索引、权限等。您不能<br>在这个数据库中直接存储用户数据，但它对于获取关于数据库服务器的元数据非常有用。<br>mysql:<br> 这个数据库通常用于存储MariaDB服务器的系统级信息，如用户账户、权限、存储过程和事件等。它是<br>MariaDB服务器正常运行所必需的，您应该避免直接修改这个数据库中的表，除非您完全了解这些表的作用和<br>如何安全地修改它们。<br>performance_schema:<br> 这个数据库提供了关于MariaDB服务器性能的信息，如查询执行时间、锁等待、表I/O等。它可以帮助数<br>据库管理员监控和优化数据库的性能。与information_schema一样，您不应该在这个数据库中存储用户数<br>据。<br>test:<br> 这是一个默认创建的空数据库，通常用于测试目的。您可以在这个数据库中创建表、插入数据等，以进行<br>数据库操作的学习或测试，而不会影响其他重要的数据库。<br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL 支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。<br>数值型:<br>MySQL 支持所有标准 SQL 数值数据类型。<br>    原则上来说，<span class="hljs-number">1</span>个int <span class="hljs-number">4</span>个字节，一个字节<span class="hljs-number">8</span>位，所以一个int占<span class="hljs-number">32</span>位，一个bit位能表示两个数字<span class="hljs-number">0</span>和<span class="hljs-number">1</span>，所以一个int能够表示 <span class="hljs-number">0</span> ~ <span class="hljs-number">2</span>^<span class="hljs-number">32</span> <span class="hljs-literal">-1</span> 的数字范围。<br><br>整数型:<br>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。<br>BOOL:<br> BOOLEAN：布尔型，是TINYINT(<span class="hljs-number">1</span>)的同义词。zero值被视为假，非zero值视为真。<br><br>日期和时间型:<br>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。<br>每个时间类型有一个有效值范围和一个<span class="hljs-string">&quot;零&quot;</span>值，当指定不合法的MySQL不能表示的值时使用<span class="hljs-string">&quot;零&quot;</span>值。<br>TIMESTAMP 类型有专有的自动更新特性。即这条记录，如果有字段是 TIMESTAMP 类型，那该记录更新后，TIMESTAMP 会自动更新。<br><br>字符串类型:<br>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、<span class="hljs-class"><span class="hljs-keyword">ENUM</span>和<span class="hljs-title">SET</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">char 和 varchar<br>  char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(<span class="hljs-number">30</span>) 就可以存储 <span class="hljs-number">30</span> 个字符。<br>  CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。<br>    - 它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。<br>    - char 类型的字符串检索速度要比 varchar 类型的快。<br>    - 对于数据处理的长度也有区别<br>      char(n)  若存入字符数小于 n，则以空格补于其后，查询之时再将空格去掉，所以 char 类型存储的字符串末尾不能有空格，varchar 不限于此。<br>      char(n)  是固定长度，char(<span class="hljs-number">4</span>) 不管是存入几个字符，都将占用<span class="hljs-number">4</span>个字节，varchar 是存入的实际字符数+<span class="hljs-number">1</span> 个字节（<span class="hljs-number">0</span>&lt; n&gt;<span class="hljs-number">255</span>)，所以varchar(<span class="hljs-number">4</span>)，存入<span class="hljs-number">3</span>个字符将占用<span class="hljs-number">4</span>个字节。<br></code></pre></td></tr></table></figure><p>char 和 varchar 在存储层面，节省一些字符空间</p><table><thead><tr><th>真实值</th><th><strong>CHAR(4)中存储的内容</strong></th><th><strong>CHAR(4)存储用的空间</strong></th><th><strong>VARCHAR(4)中存储的内容</strong></th><th><strong>VARCHAR(4)存储占用的空间</strong></th></tr></thead><tbody><tr><td>“”</td><td>‘—-‘ 表示1个空格</td><td>4 字节</td><td>‘-‘</td><td>1 字节</td></tr><tr><td>‘ab’</td><td>‘ab–’</td><td>4 字节</td><td>‘ab-‘</td><td>3 字节</td></tr><tr><td>‘abcd’</td><td>‘abcd’</td><td>4 字节</td><td>‘abcd-‘</td><td>5 字节</td></tr><tr><td>‘abcde’</td><td>‘abcd’</td><td>4 字节</td><td>‘abcd-‘</td><td>5 字节</td></tr></tbody></table><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">加入有一串字符串分别使用 char 和 varchar 方式进行存储，他们的表现样式如下：<br> a<span class="hljs-literal">---ab--abc-abcd</span> <span class="hljs-comment"># char样式</span><br> a<span class="hljs-literal">-ab-abc-abcd-</span> <span class="hljs-comment"># varchar样式</span><br>看起来是varchar节省了空间，但是当我们的存储数据发生改变了，比如说第一个a变成了xyz<br> xyz<span class="hljs-literal">-ab--abc-abcd</span> <span class="hljs-comment"># char样式因为留有空间，所以可以随时替换</span><br> a<span class="hljs-literal">-ab-abc-abcd-</span> <span class="hljs-comment"># varchar样式因为数据没有空闲空间，所以需要一个额外的空间保留xyz</span><br>   <span class="hljs-comment"># 所以，a-的旧数据就变成了数据碎片，没有太大的作用了。</span><br>   <span class="hljs-comment"># 如果后来 xyz 更换成了A，那么xyz 就变成了碎片，原来的数据就变成了</span><br>   <span class="hljs-comment"># A-ab-abc-abcd￾</span><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">varchar 和 text<br>varchar 可指定 n，text 不能指定，<br>  内部存储 varchar 是存入的实际字符数+<span class="hljs-number">1</span>个字节（<span class="hljs-number">1</span>&lt; n&gt;<span class="hljs-number">255</span>)，<br>  text 是实际字符数+<span class="hljs-number">2</span>个字节。<br>text 类型不能有默认值。<br>varchar 可直接创建索引，text 创建索引要指定前多少个字符。<br>varchar 查询速度快于 text。<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">二进制数据BLOB<br>BLOB 和 text 存储方式不同，<br> - TEXT 以文本方式存储，英文存储区分大小写，<br> - Blob 以二进制方式存储，不分大小写<br> <br>BLOB 存储的数据只能整体读出。<br>TEXT 可以指定字符集，BLOB 不用指定字符集。<br><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR<br>不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。<br> 这说明它们没有字符集，并且排序和比较基于列值字节的数值。<br><br></code></pre></td></tr></table></figure><table><thead><tr><th>数据类型</th><th>占用空间大小</th><th>说明</th></tr></thead><tbody><tr><td>CHAR</td><td>0, 255 字节</td><td>定长字符串</td></tr><tr><td>VARCHAR</td><td>0, 65535 字节</td><td>变长字符串</td></tr><tr><td>TINYBLOB</td><td>0, 255 字节</td><td>不超过 255 个字符的二进制字符串</td></tr><tr><td>TINYTEXT</td><td>0, 255 字节</td><td>短文本字符串</td></tr><tr><td>BLOB</td><td>0, 255 字节</td><td>二进制形式的长文本数据</td></tr><tr><td>TEXT</td><td>0, 65535 字节</td><td>长文本数据</td></tr><tr><td>MEDIUMBLOB</td><td>0, 16777215 字节</td><td>二进制形式的中等长度文本数据</td></tr><tr><td>MEDIUMTEXT</td><td>0, 16777215 字节</td><td>中等长度文本数据</td></tr><tr><td>LONGBLOB</td><td>0, 294967295 字节</td><td>二进制形式的极大文本数据</td></tr><tr><td>LONGTEXT</td><td>0, 4294967295 字节</td><td>极大文本数据</td></tr></tbody></table><p>选择正确的数据类型对于获得高性能至关重要</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">- 更小的通常更好，尽量使用可正确存储数据的最小数据类型<br>- 简单就好，简单数据类型的操作通常需要更少的CPU周期<br>- 尽量避免NULL，包含为NULL的列，对MySQL更难优化<br></code></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs powershell">```<br><br>适用所有类型的修饰符<br><br>| 修饰符             | 说明                                                     |<br>| <span class="hljs-literal">------------------</span> | <span class="hljs-literal">--------------------------------------------------------</span> |<br>| NULL               | 数据列可包含 NULL 值，默认值                             |<br>| NOT NULL           | 数据列不允许包含 NULL 值                                 |<br>| DEFAULT            | 指定默认值                                               |<br>| PRIMARY KEY        | 主键，所有记录中此字段的值不能重复，且不能为空（NULL）   |<br>| UNIQUE KEY         | 唯一键，所有记录中此字段的值不能重复，但可以为空（NULL） |<br>| CHARACTER <span class="hljs-built_in">SET</span> name | 指定一个字符集                                           |<br><br>适用数值型的修饰符<br><br>| 修饰符         | 说明                                                         |<br>| <span class="hljs-literal">--------------</span> | <span class="hljs-literal">------------------------------------------------------------</span> |<br>| AUTO_INCREMENT | 自动递增，适用于整数类型，必须作用于某个 key 的字段，比如 primary key |<br>| UNSIGNED       | 无符号                                                       |<br><br><span class="hljs-comment">##  DDL 语句</span><br><br>```powershell<br>DDL 语句主要用来操作数据库中的表。<br>同一个库中不同表可以使用不同的存储引擎，但建议使用同一种存储引擎.<br><br>查看表:<br>SHOW [<span class="hljs-type">FULL</span>] TABLES [&#123;<span class="hljs-type">FROM</span> | <span class="hljs-type">IN</span>&#125; <span class="hljs-type">db_name</span>]<br>   [<span class="hljs-type">LIKE</span> <span class="hljs-string">&#x27;pattern&#x27;</span> | <span class="hljs-type">WHERE</span> <span class="hljs-type">expr</span>]<br>    <br><br><br>查看表的基本结构<br>DESC [<span class="hljs-type">db_name.</span>]tb_name<br>查看表有哪些字段组成<br>SHOW COLUMNS FROM [<span class="hljs-type">db_name.</span>]tb_name<br>注意：<br> 上面的两种信息，查看的效果是一样的。<br> <br>创建表:<br>直接创建<br>CREATE TABLE [<span class="hljs-type">IF</span> <span class="hljs-type">NOT</span> <span class="hljs-type">EXISTS</span>] <span class="hljs-string">&#x27;tbl_name&#x27;</span> (col1 type1 修饰符, col2 type2 修饰符, ...)<br><span class="hljs-comment">#字段格式</span><br>col type1 <span class="hljs-comment">#定义字段数据类型</span><br>PRIMARY KEY(col1,...) <span class="hljs-comment">#将该字段设为主键</span><br>INDEX(col1, ...) <span class="hljs-comment">#设置为索引</span><br>UNIQUE KEY(col1, ...) <span class="hljs-comment">#设置为联合主键</span><br><span class="hljs-comment">#表选项</span><br>ENGINE [=] engine_name<br>ROW_FORMAT [=] &#123;DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT&#125;<br><br><br><br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs powershell">查看数据库信息<br>MariaDB root<span class="hljs-selector-tag">@</span>(none):(none)&gt; show databases;<br>+<span class="hljs-literal">--------------------</span>+<br>| Database           |<br>+<span class="hljs-literal">--------------------</span>+<br>| db3306             |<br>| information_schema |<br>| mysql              |<br>| performance_schema |<br>| test               |<br>+<span class="hljs-literal">--------------------</span>+<br><br><span class="hljs-number">5</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span><br>Time: <span class="hljs-number">0.007</span>s<br><br>在数据库外面查看所有表<br>MariaDB root<span class="hljs-selector-tag">@</span>(none):(none)&gt; show tables <span class="hljs-keyword">in</span> mysql;<br>+<span class="hljs-literal">---------------------------</span>+<br>| Tables_in_mysql           |<br>+<span class="hljs-literal">---------------------------</span>+<br>| column_stats              |<br>| columns_priv              |<br>| db                        |<br>| event                     |<br>| func                      |<br>| general_log               |<br>| global_priv               |<br>| gtid_slave_pos            |<br>| help_category             |<br>| help_keyword              |<br>| help_relation             |<br>| help_topic                |<br>| index_stats               |<br>| innodb_index_stats        |<br>| innodb_table_stats        |<br>| plugin                    |<br>| proc                      |<br>| procs_priv                |<br>| proxies_priv              |<br>| roles_mapping             |<br>| servers                   |<br>| slow_log                  |<br>| table_stats               |<br>| tables_priv               |<br>| time_zone                 |<br>| time_zone_leap_second     |<br>| time_zone_name            |<br>| time_zone_transition      |<br>| time_zone_transition_type |<br>| transaction_registry      |<br>| user                      |<br>+<span class="hljs-literal">---------------------------</span>+<br><br><span class="hljs-number">31</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span><br>Time: <span class="hljs-number">0.005</span>s<br><br>进入数据库<br>MariaDB root<span class="hljs-selector-tag">@</span>(none):(none)&gt; use mysql;<br>You are now connected to database <span class="hljs-string">&quot;mysql&quot;</span> as user <span class="hljs-string">&quot;root&quot;</span><br>Time: <span class="hljs-number">0.000</span>s<br><br>查看表结构信息<br>MariaDB root<span class="hljs-selector-tag">@</span>(none):mysql&gt; desc servers;<br>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">-------</span>+<br>| Field       | <span class="hljs-built_in">Type</span>          | Null | Key | Default | Extra |<br>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">-------</span>+<br>| Server_name | char(<span class="hljs-number">64</span>)      | NO   | PRI |         |       |<br>| Host        | varchar(<span class="hljs-number">2048</span>) | NO   |     |         |       |<br>| Db          | char(<span class="hljs-number">64</span>)      | NO   |     |         |       |<br>| Username    | char(<span class="hljs-number">80</span>)      | NO   |     |         |       |<br>| Password    | char(<span class="hljs-number">64</span>)      | NO   |     |         |       |<br>| Port        | int(<span class="hljs-number">4</span>)        | NO   |     | <span class="hljs-number">0</span>       |       |<br>| Socket      | char(<span class="hljs-number">64</span>)      | NO   |     |         |       |<br>| Wrapper     | char(<span class="hljs-number">64</span>)      | NO   |     |         |       |<br>| Owner       | varchar(<span class="hljs-number">512</span>)  | NO   |     |         |       |<br>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">-------</span>+<br><br><span class="hljs-number">9</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span><br>Time: <span class="hljs-number">0.005</span>s<br><br>查看表的基本字段信息<br>MariaDB root<span class="hljs-selector-tag">@</span>(none):mysql&gt; show columns from servers;<br>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">-------</span>+<br>| Field       | <span class="hljs-built_in">Type</span>          | Null | Key | Default | Extra |<br>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">-------</span>+<br>| Server_name | char(<span class="hljs-number">64</span>)      | NO   | PRI |         |       |<br>| Host        | varchar(<span class="hljs-number">2048</span>) | NO   |     |         |       |<br>| Db          | char(<span class="hljs-number">64</span>)      | NO   |     |         |       |<br>| Username    | char(<span class="hljs-number">80</span>)      | NO   |     |         |       |<br>| Password    | char(<span class="hljs-number">64</span>)      | NO   |     |         |       |<br>| Port        | int(<span class="hljs-number">4</span>)        | NO   |     | <span class="hljs-number">0</span>       |       |<br>| Socket      | char(<span class="hljs-number">64</span>)      | NO   |     |         |       |<br>| Wrapper     | char(<span class="hljs-number">64</span>)      | NO   |     |         |       |<br>| Owner       | varchar(<span class="hljs-number">512</span>)  | NO   |     |         |       |<br>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">-------</span>+<br><br><span class="hljs-number">9</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span><br>Time: <span class="hljs-number">0.005</span>s<br><br><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell">创建表的基本流程 <span class="hljs-literal">--</span> 进入库，然后创建表<br>创建数据库<br>MariaDB [(<span class="hljs-type">none</span>)]&gt; create database db1;<br>Query OK, <span class="hljs-number">1</span> row affected (<span class="hljs-number">0.002</span> sec)<br>选择数据库<br>MariaDB [(<span class="hljs-type">none</span>)]&gt; use db1;<br>Database changed<br>进入数据库后，创建数据表<br>MariaDB [<span class="hljs-type">db1</span>]&gt; CREATE TABLE student (<br>    -&gt; id int UNSIGNED AUTO_INCREMENT PRIMARY KEY,<br>    -&gt; name VARCHAR(<span class="hljs-number">20</span>) NOT NULL,<br>    -&gt; age tinyint UNSIGNED,<br>    -&gt; <span class="hljs-comment">#height DECIMAL(5,2),</span><br>    -&gt; gender <span class="hljs-class"><span class="hljs-keyword">ENUM</span>(&#x27;<span class="hljs-title">M</span>&#x27;,&#x27;<span class="hljs-title">F</span>&#x27;) <span class="hljs-title">default</span> &#x27;<span class="hljs-title">M</span>&#x27;</span><br><span class="hljs-class">    -&gt; )<span class="hljs-title">ENGINE</span>=<span class="hljs-title">InnoDB</span> <span class="hljs-title">AUTO_INCREMENT</span>=10 <span class="hljs-title">DEFAULT</span> <span class="hljs-title">CHARSET</span>=<span class="hljs-title">utf8mb4</span>;</span><br><span class="hljs-class"><span class="hljs-title">Query</span> <span class="hljs-title">OK</span>, 0 <span class="hljs-title">rows</span> <span class="hljs-title">affected</span> (0.028 <span class="hljs-title">sec</span>)</span><br><span class="hljs-class">查看表</span><br><span class="hljs-class"><span class="hljs-title">MariaDB</span> [<span class="hljs-title">db1</span>]&gt; <span class="hljs-title">show</span> <span class="hljs-title">tables</span>;</span><br><span class="hljs-class">+---------------+</span><br><span class="hljs-class">| <span class="hljs-title">Tables_in_db1</span> |</span><br><span class="hljs-class">+---------------+</span><br><span class="hljs-class">| <span class="hljs-title">student</span>       |</span><br><span class="hljs-class">+---------------+</span><br><span class="hljs-class">1 <span class="hljs-title">row</span> <span class="hljs-title">in</span> <span class="hljs-title">set</span> (0.001 <span class="hljs-title">sec</span>)</span><br></code></pre></td></tr></table></figure><p>复制方式创建表</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">特点： 这种方式，创建的数据表，如果源数据表内有数据的话，复制表里面也会有数据查看数据表结构<br>MariaDB [<span class="hljs-type">db1</span>]&gt; create table user1 <span class="hljs-built_in">select</span> Host,User,Password from mysql.user;<br>Query OK, <span class="hljs-number">5</span> rows affected (<span class="hljs-number">0.003</span> sec)<br>Records: <span class="hljs-number">5</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; show tables;<br>+<span class="hljs-literal">---------------</span>+<br>| Tables_in_db1 |<br>+<span class="hljs-literal">---------------</span>+<br>| student       |<br>| user1         |<br>+<span class="hljs-literal">---------------</span>+<br><span class="hljs-number">2</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br></code></pre></td></tr></table></figure><p>基于复制方式创建表-仅结构</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">通过like方式创建表<br>MariaDB [<span class="hljs-type">db1</span>]&gt;  create table user2 like user1;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.009</span> sec)<br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; show tables;<br><br></code></pre></td></tr></table></figure><p>查看建表语句格式</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SHOW CREATE TABLE [<span class="hljs-type">db_name.</span>]tbl_name<br>查看user2表的创建语法<br>MariaDB [<span class="hljs-type">db1</span>]&gt; show create table user2\G<br>*************************** <span class="hljs-number">1</span>. row ***************************<br>       Table: user2<br>Create Table: CREATE TABLE `user2` (<br>  `Host` char(<span class="hljs-number">60</span>) CHARACTER <span class="hljs-built_in">SET</span> utf8 COLLATE utf8_bin NOT NULL,<br>  `User` char(<span class="hljs-number">80</span>) CHARACTER <span class="hljs-built_in">SET</span> utf8 COLLATE utf8_bin NOT NULL,<br>  `Password` longtext CHARACTER <span class="hljs-built_in">SET</span> utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL<br>) ENGINE=InnoDB DEFAULT CHARSET=latin1 COLLATE=latin1_swedish_ci<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br></code></pre></td></tr></table></figure><p>查看表的基本状态</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SHOW TABLE STATUS LIKE <span class="hljs-string">&#x27;tb_name&#x27;</span> <span class="hljs-comment"># 查看一个表的状态,表名外侧有单引号</span><br>SHOW TABLE STATUS FROM db_name <span class="hljs-comment"># 查看一个库里面所有表的状态</span><br><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs powershell">查看user1表的的状态<br>MariaDB [<span class="hljs-type">db1</span>]&gt; show table status like <span class="hljs-string">&#x27;user1&#x27;</span>\G<br>*************************** <span class="hljs-number">1</span>. row ***************************<br>            Name: user1<br>          Engine: InnoDB<br>         Version: <span class="hljs-number">10</span><br>      Row_format: Dynamic<br>            Rows: <span class="hljs-number">5</span><br>  Avg_row_length: <span class="hljs-number">3276</span><br>     Data_length: <span class="hljs-number">16384</span><br> Max_data_length: <span class="hljs-number">0</span><br>    Index_length: <span class="hljs-number">0</span><br>       Data_free: <span class="hljs-number">0</span><br>  Auto_increment: NULL<br>     Create_time: <span class="hljs-number">2025</span><span class="hljs-literal">-03-08</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">59</span><br>     Update_time: <span class="hljs-number">2025</span><span class="hljs-literal">-03-08</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">59</span><br>      Check_time: NULL<br>       Collation: latin1_swedish_ci<br>        Checksum: NULL<br>  Create_options:<br>         Comment:<br>Max_index_length: <span class="hljs-number">0</span><br>       Temporary: N<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br>查看db1库里的所有表的状态<br>MariaDB [<span class="hljs-type">db1</span>]&gt; show table status like <span class="hljs-string">&#x27;user1&#x27;</span>\G<br>*************************** <span class="hljs-number">1</span>. row ***************************<br>            Name: user1<br>          Engine: InnoDB<br>         Version: <span class="hljs-number">10</span><br>      Row_format: Dynamic<br>            Rows: <span class="hljs-number">5</span><br>  Avg_row_length: <span class="hljs-number">3276</span><br>     Data_length: <span class="hljs-number">16384</span><br> Max_data_length: <span class="hljs-number">0</span><br>    Index_length: <span class="hljs-number">0</span><br>       Data_free: <span class="hljs-number">0</span><br>  Auto_increment: NULL<br>     Create_time: <span class="hljs-number">2025</span><span class="hljs-literal">-03-08</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">59</span><br>     Update_time: <span class="hljs-number">2025</span><span class="hljs-literal">-03-08</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">59</span><br>      Check_time: NULL<br>       Collation: latin1_swedish_ci<br>        Checksum: NULL<br>  Create_options:<br>         Comment:<br>Max_index_length: <span class="hljs-number">0</span><br>       Temporary: N<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br>MariaDB [<span class="hljs-type">db1</span>]&gt;  show table status from db1\G<br>*************************** <span class="hljs-number">1</span>. row ***************************<br>            Name: student<br>          Engine: InnoDB<br>         Version: <span class="hljs-number">10</span><br>      Row_format: Dynamic<br>            Rows: <span class="hljs-number">0</span><br>  Avg_row_length: <span class="hljs-number">0</span><br>     Data_length: <span class="hljs-number">16384</span><br> Max_data_length: <span class="hljs-number">0</span><br>    Index_length: <span class="hljs-number">0</span><br>       Data_free: <span class="hljs-number">0</span><br>  Auto_increment: <span class="hljs-number">10</span><br>     Create_time: <span class="hljs-number">2025</span><span class="hljs-literal">-03-08</span> <span class="hljs-number">15</span>:<span class="hljs-number">14</span>:<span class="hljs-number">12</span><br>     Update_time: NULL<br>      Check_time: NULL<br>       Collation: utf8mb4_general_ci<br>        Checksum: NULL<br>  Create_options:<br>         Comment:<br>Max_index_length: <span class="hljs-number">0</span><br>       Temporary: N<br>*************************** <span class="hljs-number">2</span>. row ***************************<br>            Name: user1<br>          Engine: InnoDB<br>         Version: <span class="hljs-number">10</span><br>      Row_format: Dynamic<br>            Rows: <span class="hljs-number">5</span><br>  Avg_row_length: <span class="hljs-number">3276</span><br>     Data_length: <span class="hljs-number">16384</span><br> Max_data_length: <span class="hljs-number">0</span><br>    Index_length: <span class="hljs-number">0</span><br>       Data_free: <span class="hljs-number">0</span><br>  Auto_increment: NULL<br>     Create_time: <span class="hljs-number">2025</span><span class="hljs-literal">-03-08</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">59</span><br>     Update_time: <span class="hljs-number">2025</span><span class="hljs-literal">-03-08</span> <span class="hljs-number">15</span>:<span class="hljs-number">21</span>:<span class="hljs-number">59</span><br>      Check_time: NULL<br>       Collation: latin1_swedish_ci<br>        Checksum: NULL<br>  Create_options:<br>         Comment:<br>Max_index_length: <span class="hljs-number">0</span><br>       Temporary: N<br>*************************** <span class="hljs-number">3</span>. row ***************************<br>            Name: user2<br>          Engine: InnoDB<br>         Version: <span class="hljs-number">10</span><br>      Row_format: Dynamic<br>            Rows: <span class="hljs-number">0</span><br>  Avg_row_length: <span class="hljs-number">0</span><br>     Data_length: <span class="hljs-number">16384</span><br> Max_data_length: <span class="hljs-number">0</span><br>    Index_length: <span class="hljs-number">0</span><br>       Data_free: <span class="hljs-number">0</span><br>  Auto_increment: NULL<br>     Create_time: <span class="hljs-number">2025</span><span class="hljs-literal">-03-08</span> <span class="hljs-number">15</span>:<span class="hljs-number">24</span>:<span class="hljs-number">30</span><br>     Update_time: NULL<br>      Check_time: NULL<br>       Collation: latin1_swedish_ci<br>        Checksum: NULL<br>  Create_options:<br>         Comment:<br>Max_index_length: <span class="hljs-number">0</span><br>       Temporary: N<br><span class="hljs-number">3</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br><br></code></pre></td></tr></table></figure><h4 id="查看表所支持的引擎"><a href="#查看表所支持的引擎" class="headerlink" title="查看表所支持的引擎"></a>查看表所支持的引擎</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">存储引擎决定了数据如何被存储、读取、更新和删除。它是数据库的核心服务之一，用于存储、处理和保护数据，同时控制对数据的访问权限并快速处理事务。<br>简单来说，存储引擎就是如何把数据存到文件系统中，然后如何从文件系统中读取数据到内存里面。<br><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">查看当前MySQL服务支持的引擎<br>SHOW ENGINES<br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><br></code></pre></td></tr></table></figure><p>!!!!![](..&#x2F;image&#x2F;MySQL 数据库&#x2F;image-20250308160739595.png)</p><p>数据库引擎的解读</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Aria:<br> Aria是MyISAM的改进版，提供了崩溃安全的表，并继承了MyISAM的特性。<br> 它主要用于内部临时表和权限表。不支持事务。<br>MRG_MyISAM:<br> MRG_MyISAM是MyISAM表的集合，允许将多个MyISAM表合并为一个虚拟表。不支持事务。<br>MEMORY:<br> MEMORY存储引擎基于哈希表，数据存储在内存中，非常适合用于临时表。不支持事务。<br>BLACKHOLE:<br> BLACKHOLE引擎就像一个黑洞，任何写入它的数据都会消失，类似于Unix/Linux中的/dev/null。不<br>支持事务。<br>MyISAM:<br> MyISAM是非事务性存储引擎，具有良好的性能和较小的数据占用空间。不支持事务。<br>CSV:<br> CSV存储引擎将表存储为CSV文件，非常适合与其他系统进行数据交换。不支持事务。<br>ARCHIVE:<br> ARCHIVE引擎通过gzip压缩表来减少存储占用空间，非常适合存储历史数据。不支持事务。<br>FEDERATED:<br> FEDERATED引擎允许访问其他MariaDB服务器上的表，支持事务和其他高级功能。<br>PERFORMANCE_SCHEMA:<br> PERFORMANCE_SCHEMA存储引擎用于性能监控和分析。不支持事务。<br>InnoDB:<br> InnoDB是MariaDB的默认存储引擎，支持事务、行级锁定、外键和表加密。是大多数应用场景的首选。<br>SEQUENCE:<br> SEQUENCE引擎生成填充有顺序值的表，非常适合需要生成唯一序列号的场景。支持事务。<br></code></pre></td></tr></table></figure><h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ALTER [<span class="hljs-type">ONLINE</span> | <span class="hljs-type">OFFLINE</span>] [<span class="hljs-type">IGNORE</span>] TABLE tbl_name<br>    [<span class="hljs-type">alter_specification</span> [, <span class="hljs-type">alter_specification</span>] <span class="hljs-type">...</span>]<br>    [<span class="hljs-type">partition_options</span>]<br>&#123; ADD COLUMN &lt;列名&gt; &lt;类型&gt;<br>| CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;<br>| ALTER COLUMN &lt;列名&gt; &#123; <span class="hljs-built_in">SET</span> DEFAULT &lt;默认值&gt; | DROP DEFAULT &#125;<br>| MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;<br>| DROP COLUMN &lt;列名&gt;<br>| RENAME TO &lt;新表名&gt; &#125;<br><br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell">修改student为stu<br>MariaDB [<span class="hljs-type">db1</span>]&gt; ALTER TABLE student RENAME stu;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.002</span> sec)<br><br>向表中插入一个新的字段 phone，排在name字段后面<br>MariaDB [<span class="hljs-type">db1</span>]&gt; ALTER TABLE stu ADD phone varchar(<span class="hljs-number">11</span>) AFTER name;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.002</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>删除gender字段<br>MariaDB [<span class="hljs-type">db1</span>]&gt; ALTER TABLE stu DROP COLUMN gender;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.003</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br><br></code></pre></td></tr></table></figure><p>字段类型修改</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">修改数据表的phone的字段类型改为 int 类型<br>MariaDB [<span class="hljs-type">db1</span>]&gt;  ALTER TABLE stu MODIFY phone int;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.012</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>修改表的phone的字段名字 改为mobile名字，类型是 char(<span class="hljs-number">11</span>)<br>MariaDB [<span class="hljs-type">db1</span>]&gt; ALTER TABLE stu CHANGE COLUMN phone mobile char(<span class="hljs-number">11</span>);<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.012</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h4 id="字段默认值修改"><a href="#字段默认值修改" class="headerlink" title="字段默认值修改"></a>字段默认值修改</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell">修改age的默认值为<span class="hljs-number">18</span><br>MariaDB [<span class="hljs-type">db1</span>]&gt; alter table stu alter column age <span class="hljs-built_in">set</span> default <span class="hljs-string">&#x27;18&#x27;</span>;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.001</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>添加字段的时候，设定默认值<br>MariaDB [<span class="hljs-type">db1</span>]&gt;  ALTER TABLE stu ADD is_del bool DEFAULT false;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.002</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>修改字段默认值<br>MariaDB [<span class="hljs-type">db1</span>]&gt; ALTER TABLE stu modify is_del bool DEFAULT true;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.001</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><h3 id="主键的增删"><a href="#主键的增删" class="headerlink" title="主键的增删"></a>主键的增删</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">  主键对于一个数据表来说，非常的重要，很多数据的批量操作都限制了只能依赖于主键才可以继续下去。所以，对于主键的处理，我们一定要上心，常见的主键操作，主要有以下几种样式:<br><span class="hljs-number">1</span> 为一个表的现有字段 增加|删除一个主键<br> ALTER TABLE 表名 ADD|DROP PRIMARY KEY (字段名);<br><span class="hljs-literal">---</span><br><span class="hljs-number">2</span><span class="hljs-literal">-1</span> 为一个表的 增加|删除一个 之前不存在的主键<br> ALTER TABLE 表名 ADD COLUMN id INT UNSIGNED FIRST;<br><span class="hljs-number">2</span><span class="hljs-literal">-2</span> 将一个表的现有主键进行自增属性的增加<br> ALTER TABLE 表名 MODIFY COLUMN id INT AUTO_INCREMENT PRIMARY KEY;<br> 或，将上面命令拆解成两个<br> ALTER TABLE 表名 MODIFY COLUMN 字段名 INT UNSIGNED AUTO_INCREMENT;<br> ALTER TABLE 表名 ADD PRIMARY KEY (字段名);<br><br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MariaDB [<span class="hljs-type">db1</span>]&gt; desc student2;<br>+<span class="hljs-literal">-------</span>+<span class="hljs-literal">---------------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">-------</span>+<br>| Field | <span class="hljs-built_in">Type</span>                | Null | Key | Default | Extra |<br>+<span class="hljs-literal">-------</span>+<span class="hljs-literal">---------------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">-------</span>+<br>| name  | char(<span class="hljs-number">30</span>)            | YES  |     | NULL    |       |<br>| age   | tinyint(<span class="hljs-number">3</span>) unsigned | YES  |     | <span class="hljs-number">18</span>      |       |<br>+<span class="hljs-literal">-------</span>+<span class="hljs-literal">---------------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">-------</span>+<br><span class="hljs-number">2</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br>将name字段设置为主键<br>MariaDB [<span class="hljs-type">db1</span>]&gt;  ALTER TABLE student2 ADD PRIMARY KEY (name);<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.004</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>将name主键标识从student2表中移除<br>MariaDB [<span class="hljs-type">db1</span>]&gt; ALTER TABLE student2 DROP PRIMARY KEY;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.012</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>为 student2 表增加一个 主键id , FIRST 代表是第一个位置<br>MariaDB [<span class="hljs-type">db1</span>]&gt; ALTER TABLE student2 ADD COLUMN id INT UNSIGNED FIRST;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.008</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>为student2增加一个自增主键id,类型为 无符号型<br>ariaDB [<span class="hljs-type">db1</span>]&gt; ALTER TABLE student2 ADD COLUMN id INT AUTO_INCREMENT PRIMARY KEY FIRST;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.011</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; desc student2;<br>+<span class="hljs-literal">-------</span>+<span class="hljs-literal">---------------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">----------------</span>+<br>| Field | <span class="hljs-built_in">Type</span>                | Null | Key | Default | Extra          |<br>+<span class="hljs-literal">-------</span>+<span class="hljs-literal">---------------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">----------------</span>+<br>| id    | int(<span class="hljs-number">11</span>)             | NO   | PRI | NULL    | auto_increment |<br>| name  | char(<span class="hljs-number">30</span>)            | NO   |     | NULL    |                |<br>| age   | tinyint(<span class="hljs-number">3</span>) unsigned | YES  |     | <span class="hljs-number">18</span>      |                |<br>+<span class="hljs-literal">-------</span>+<span class="hljs-literal">---------------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">-----</span>+<span class="hljs-literal">---------</span>+<span class="hljs-literal">----------------</span>+<br><span class="hljs-number">3</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br></code></pre></td></tr></table></figure><h3 id="查看自增id的起始值"><a href="#查看自增id的起始值" class="headerlink" title="查看自增id的起始值"></a>查看自增id的起始值</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">方法<span class="hljs-number">1</span><br>命令格式：<br><span class="hljs-built_in">SELECT</span> `AUTO_INCREMENT`<br>FROM information_schema.TABLES<br><span class="hljs-built_in">WHERE</span> TABLE_SCHEMA = <span class="hljs-string">&#x27;数据库名&#x27;</span><br>  AND TABLE_NAME = <span class="hljs-string">&#x27;数据表名&#x27;</span>;<br><br>方法<span class="hljs-number">2</span>:<br>命令格式：<br> SHOW CREATE TABLE 表名;<br><br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs powershell">查看db1库里面student2的自增id值<br>MariaDB [<span class="hljs-type">db1</span>]&gt; <span class="hljs-built_in">SELECT</span> `AUTO_INCREMENT`<br>    -&gt;  FROM information_schema.TABLES<br>    -&gt; <span class="hljs-built_in">WHERE</span> TABLE_SCHEMA = <span class="hljs-string">&#x27;db1&#x27;</span><br>    -&gt; AND TABLE_NAME = <span class="hljs-string">&#x27;student2&#x27;</span>;<br>+<span class="hljs-literal">----------------</span>+<br>| AUTO_INCREMENT |<br>+<span class="hljs-literal">----------------</span>+<br>|              <span class="hljs-number">1</span> |<br>+<span class="hljs-literal">----------------</span>+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; SHOW CREATE TABLE stu\G<br>*************************** <span class="hljs-number">1</span>. row ***************************<br>       Table: stu<br>Create Table: CREATE TABLE `stu` (<br>  `id` int(<span class="hljs-number">10</span>) unsigned NOT NULL AUTO_INCREMENT,<br>  `name` char(<span class="hljs-number">30</span>) DEFAULT NULL,<br>  `mobile` char(<span class="hljs-number">11</span>) CHARACTER <span class="hljs-built_in">SET</span> utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,<br>  `age` tinyint(<span class="hljs-number">3</span>) unsigned DEFAULT <span class="hljs-number">18</span>,<br>  `is_del` tinyint(<span class="hljs-number">1</span>) DEFAULT <span class="hljs-number">1</span>,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">10</span> DEFAULT CHARSET=utf8 COLLATE=utf8_general_ci<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><span class="hljs-comment"># AUTO_INCREMENT=10,自增id起始10</span><br><br></code></pre></td></tr></table></figure><h4 id="表的移除"><a href="#表的移除" class="headerlink" title="表的移除"></a>表的移除</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">删除表<br>DROP [<span class="hljs-type">TEMPORARY</span>] TABLE [<span class="hljs-type">IF</span> <span class="hljs-type">EXISTS</span>]<br>    tbl_name [, <span class="hljs-type">tbl_name</span>] ...<br>    [<span class="hljs-type">RESTRICT</span> | <span class="hljs-type">CASCADE</span>]<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MariaDB [<span class="hljs-type">db1</span>]&gt; show tables;<br>+<span class="hljs-literal">---------------</span>+<br>| Tables_in_db1 |<br>+<span class="hljs-literal">---------------</span>+<br>| stu           |<br>| student       |<br>| student2      |<br>| user1         |<br>| user2         |<br>+<span class="hljs-literal">---------------</span>+<br><span class="hljs-number">5</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br>MariaDB [<span class="hljs-type">db1</span>]&gt;  drop table user1;drop table db1.user2;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.008</span> sec)<br><br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.001</span> sec)<br><br>MariaDB [<span class="hljs-type">db1</span>]&gt;  show tables;<br>+<span class="hljs-literal">---------------</span>+<br>| Tables_in_db1 |<br>+<span class="hljs-literal">---------------</span>+<br>| stu           |<br>| student       |<br>| student2      |<br>+<span class="hljs-literal">---------------</span>+<br><span class="hljs-number">3</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br></code></pre></td></tr></table></figure><h2 id="DML-语句"><a href="#DML-语句" class="headerlink" title="DML 语句"></a>DML 语句</h2><p>DML 语句包括 INSERT，UPDATE，DELETE</p><h4 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">普通的查插入数据<br>INSERT [<span class="hljs-type">LOW_PRIORITY</span> | <span class="hljs-type">DELAYED</span> | <span class="hljs-type">HIGH_PRIORITY</span>] [<span class="hljs-type">IGNORE</span>]<br>    [<span class="hljs-built_in">INT</span><span class="hljs-type">O</span>] tbl_name [(<span class="hljs-type">col_name</span>,<span class="hljs-type">...</span>)]<br>    &#123;VALUES | VALUE&#125; (&#123;expr | DEFAULT&#125;,...),(...),...<br>    [ <span class="hljs-type">ON</span> <span class="hljs-type">DUPLICATE</span> <span class="hljs-type">KEY</span> <span class="hljs-type">UPDATE</span><br>      <span class="hljs-type">col_name</span>=<span class="hljs-type">expr</span><br>        [, <span class="hljs-type">col_name</span>=<span class="hljs-type">expr</span>] <span class="hljs-type">...</span> ]<br><br>INSERT 可以一次往表中插入一条或多条记录<br>INSERT tbl_name <span class="hljs-function">[(<span class="hljs-type">col1</span>,<span class="hljs-type">...</span>)] <span class="hljs-title">VALUES</span></span> (val1,...), (val21,...)<br><br>根据条件插入数据<br>如果记录不存在就新增，如果存在就更新<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs powershell">插入一条数据, 只给出部份字段值，因为有些字段有默认值，没有默认值的直接用NULL替代<br>MariaDB [<span class="hljs-type">db1</span>]&gt; insert stu (name,age,is_del) values(<span class="hljs-string">&#x27;xiaohong&#x27;</span>,<span class="hljs-number">18</span>,false);<br>Query OK, <span class="hljs-number">1</span> row affected (<span class="hljs-number">0.001</span> sec)<br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; <span class="hljs-built_in">select</span> * from stu;<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">--------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| id | name     | mobile | age  | is_del |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">--------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| <span class="hljs-number">10</span> | xiaoming | NULL   |   <span class="hljs-number">20</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">11</span> | xiaohong | NULL   |   <span class="hljs-number">18</span> |      <span class="hljs-number">0</span> |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">--------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br><span class="hljs-number">2</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br>不指定字段的话，那么就需要按照顺序为每个字段赋予数据值<br>MariaDB [<span class="hljs-type">db1</span>]&gt; INSERT INTO stu VALUES(<span class="hljs-number">12</span>,<span class="hljs-string">&#x27;xiaoli&#x27;</span>,<span class="hljs-number">13912345678</span>,<span class="hljs-number">19</span>,false);<br>Query OK, <span class="hljs-number">1</span> row affected (<span class="hljs-number">0.001</span> sec)<br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; <span class="hljs-built_in">select</span> * from stu;<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| id | name     | mobile      | age  | is_del |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| <span class="hljs-number">10</span> | xiaoming | NULL        |   <span class="hljs-number">20</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">11</span> | xiaohong | NULL        |   <span class="hljs-number">18</span> |      <span class="hljs-number">0</span> |<br>| <span class="hljs-number">12</span> | xiaoli   | <span class="hljs-number">13912345678</span> |   <span class="hljs-number">19</span> |      <span class="hljs-number">0</span> |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br><span class="hljs-number">3</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br>一次插入多条，字段给定后，多来几个value组合即可，彼此用逗号隔开<br>MariaDB [<span class="hljs-type">db1</span>]&gt;  INSERT INTO stu (name,age)VALUES(<span class="hljs-string">&#x27;test1&#x27;</span>,<span class="hljs-number">20</span>),(<span class="hljs-string">&#x27;test2&#x27;</span>,<span class="hljs-number">21</span>),(<span class="hljs-string">&#x27;test3&#x27;</span>,<span class="hljs-number">22</span>);<br>Query OK, <span class="hljs-number">3</span> rows affected (<span class="hljs-number">0.001</span> sec)<br>Records: <span class="hljs-number">3</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; <span class="hljs-built_in">select</span> * from stu;<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| id | name     | mobile      | age  | is_del |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| <span class="hljs-number">10</span> | xiaoming | NULL        |   <span class="hljs-number">20</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">11</span> | xiaohong | NULL        |   <span class="hljs-number">18</span> |      <span class="hljs-number">0</span> |<br>| <span class="hljs-number">12</span> | xiaoli   | <span class="hljs-number">13912345678</span> |   <span class="hljs-number">19</span> |      <span class="hljs-number">0</span> |<br>| <span class="hljs-number">13</span> | test1    | NULL        |   <span class="hljs-number">20</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">14</span> | test2    | NULL        |   <span class="hljs-number">21</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">15</span> | test3    | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br><span class="hljs-number">6</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br><br></code></pre></td></tr></table></figure><h4 id="基于select方式插入数据"><a href="#基于select方式插入数据" class="headerlink" title="基于select方式插入数据"></a>基于select方式插入数据</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">INSERT [<span class="hljs-type">LOW_PRIORITY</span> | <span class="hljs-type">HIGH_PRIORITY</span>] [<span class="hljs-type">IGNORE</span>]<br>    [<span class="hljs-built_in">INT</span><span class="hljs-type">O</span>] tbl_name [(<span class="hljs-type">col_name</span>,<span class="hljs-type">...</span>)]<br>    <span class="hljs-built_in">SELECT</span> ... <span class="hljs-comment"># 基于select筛选出来的结果作为信息，数据进入插入</span><br>    [ <span class="hljs-type">ON</span> <span class="hljs-type">DUPLICATE</span> <span class="hljs-type">KEY</span> <span class="hljs-type">UPDATE</span><br>      <span class="hljs-type">col_name</span>=<span class="hljs-type">expr</span><br>        [, <span class="hljs-type">col_name</span>=<span class="hljs-type">expr</span>] <span class="hljs-type">...</span> ]<br><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell">基于id=<span class="hljs-number">11</span>的数据，然后根据字段的方式，插入到数据表里面<br>MariaDB [<span class="hljs-type">db1</span>]&gt; insert into stu (name,age) <span class="hljs-built_in">select</span> name,age from stu <span class="hljs-built_in">where</span> id=<span class="hljs-number">11</span>;<br>Query OK, <span class="hljs-number">1</span> row affected (<span class="hljs-number">0.001</span> sec)<br>Records: <span class="hljs-number">1</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; <span class="hljs-built_in">SELECT</span> * FROM stu;<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| id | name     | mobile      | age  | is_del |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| <span class="hljs-number">10</span> | xiaoming | NULL        |   <span class="hljs-number">20</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">11</span> | xiaohong | NULL        |   <span class="hljs-number">18</span> |      <span class="hljs-number">0</span> |<br>| <span class="hljs-number">12</span> | zhangsan | <span class="hljs-number">13912345678</span> |   <span class="hljs-number">19</span> |      <span class="hljs-number">0</span> |<br>| <span class="hljs-number">13</span> | test1    | NULL        |   <span class="hljs-number">20</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">14</span> | test2    | NULL        |   <span class="hljs-number">21</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">15</span> | test3    | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">16</span> | xiaohong | NULL        |   <span class="hljs-number">18</span> |      <span class="hljs-number">1</span> |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br><span class="hljs-number">7</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br></code></pre></td></tr></table></figure><h5 id="对于NUll的空值条件判断，要使用-IS-NULL，否则会导致失败"><a href="#对于NUll的空值条件判断，要使用-IS-NULL，否则会导致失败" class="headerlink" title="对于NUll的空值条件判断，要使用 IS NULL，否则会导致失败"></a>对于NUll的空值条件判断，要使用 IS NULL，否则会导致失败</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MariaDB [<span class="hljs-type">db1</span>]&gt; update stu <span class="hljs-built_in">set</span> age=<span class="hljs-number">35</span> <span class="hljs-built_in">where</span> mobile=NULL;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.000</span> sec)<br>Rows matched: <span class="hljs-number">0</span>  Changed: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">0</span><br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; update stu <span class="hljs-built_in">set</span> age=<span class="hljs-number">35</span> <span class="hljs-built_in">where</span> mobile IS NULL;<br>Query OK, <span class="hljs-number">7</span> rows affected (<span class="hljs-number">0.001</span> sec)<br>Rows matched: <span class="hljs-number">7</span>  Changed: <span class="hljs-number">7</span>  Warnings: <span class="hljs-number">0</span><br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; <span class="hljs-built_in">SELECT</span> * FROM stu;<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| id | name     | mobile      | age  | is_del |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| <span class="hljs-number">10</span> | xiaoming | NULL        |   <span class="hljs-number">35</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">11</span> | xiaohong | NULL        |   <span class="hljs-number">35</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">12</span> | zhangsan | <span class="hljs-number">13912345678</span> |   <span class="hljs-number">30</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">13</span> | test1    | NULL        |   <span class="hljs-number">35</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">14</span> | test2    | NULL        |   <span class="hljs-number">35</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">15</span> | test3    | NULL        |   <span class="hljs-number">35</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">16</span> | xiaohong | NULL        |   <span class="hljs-number">35</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">17</span> | xiaohong | NULL        |   <span class="hljs-number">35</span> |      <span class="hljs-number">0</span> |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br><span class="hljs-number">8</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">删除表中的数据，不会缩减数据文件大小。在生产环境中，一般是逻辑删除，是指用一个字段标识该条记录己经删除了，在业务中不可用，而不是真的删除。<br>DELETE [<span class="hljs-type">LOW_PRIORITY</span>] [<span class="hljs-type">QUICK</span>] [<span class="hljs-type">IGNORE</span>] FROM tbl_name<br>   [<span class="hljs-type">WHERE</span> <span class="hljs-type">where_condition</span>]<br>   [<span class="hljs-type">ORDER</span> <span class="hljs-type">BY</span> <span class="hljs-type">...</span>]<br>   [<span class="hljs-type">LIMIT</span> <span class="hljs-type">row_count</span>]<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MariaDB [<span class="hljs-type">db1</span>]&gt; delete from stu <span class="hljs-built_in">where</span> id=<span class="hljs-number">10</span>;<br>Query OK, <span class="hljs-number">1</span> row affected (<span class="hljs-number">0.001</span> sec)<br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; <span class="hljs-built_in">SELECT</span> * FROM stu;<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| id | name     | mobile      | age  | is_del |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| <span class="hljs-number">11</span> | xiaohong | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">12</span> | zhangsan | <span class="hljs-number">13912345678</span> |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">13</span> | test1    | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">14</span> | test2    | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">15</span> | test3    | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">16</span> | xiaohong | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">17</span> | xiaohong | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">0</span> |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br><span class="hljs-number">7</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; delete from stu <span class="hljs-built_in">where</span> ( mobile IS NULL and id=<span class="hljs-number">14</span> );<br>Query OK, <span class="hljs-number">1</span> row affected (<span class="hljs-number">0.001</span> sec)<br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; <span class="hljs-built_in">SELECT</span> * FROM stu;<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| id | name     | mobile      | age  | is_del |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br>| <span class="hljs-number">11</span> | xiaohong | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">12</span> | zhangsan | <span class="hljs-number">13912345678</span> |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">13</span> | test1    | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">15</span> | test3    | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">16</span> | xiaohong | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">1</span> |<br>| <span class="hljs-number">17</span> | xiaohong | NULL        |   <span class="hljs-number">22</span> |      <span class="hljs-number">0</span> |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">----------</span>+<span class="hljs-literal">-------------</span>+<span class="hljs-literal">------</span>+<span class="hljs-literal">--------</span>+<br><span class="hljs-number">6</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br></code></pre></td></tr></table></figure><p>在直实生产环境中，一般不会对数据做物理删除，而是用字段来标记为逻辑删除，将对应字段值设为某个特定项，认为是己删除</p><h3 id="清空表数据"><a href="#清空表数据" class="headerlink" title="清空表数据"></a>清空表数据</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">TRUNCATE TABLE tbl_name; <span class="hljs-comment">#DDL语句，不支持事务，效率更高</span><br>DELETE FROM tbl_name; <span class="hljs-comment">#DML语句</span><br>TRUNCATE 清理表数据<br>ariaDB [<span class="hljs-type">db1</span>]&gt; TRUNCATE TABLE  stu;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.011</span> sec)<br>MariaDB [<span class="hljs-type">db1</span>]&gt; <span class="hljs-built_in">SELECT</span> * FROM stu;<br>Empty <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br></code></pre></td></tr></table></figure><h2 id="DQL语句"><a href="#DQL语句" class="headerlink" title="DQL语句"></a>DQL语句</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">SELECT</span><br>   [<span class="hljs-type">ALL</span> | <span class="hljs-type">DISTINCT</span> | <span class="hljs-type">DISTINCTROW</span> ]<br>     [<span class="hljs-type">HIGH_PRIORITY</span>]<br>     [<span class="hljs-type">STRAIGHT_JOIN</span>]<br>     [<span class="hljs-type">SQL_SMALL_RESULT</span>] [<span class="hljs-type">SQL_BIG_RESULT</span>] [<span class="hljs-type">SQL_BUFFER_RESULT</span>]<br>     [<span class="hljs-type">SQL_CACHE</span> | <span class="hljs-type">SQL_NO_CACHE</span>] [<span class="hljs-type">SQL_CALC_FOUND_ROWS</span>]<br>   select_expr [, <span class="hljs-type">select_expr</span> <span class="hljs-type">...</span>]<br>   [<span class="hljs-type">FROM</span> <span class="hljs-type">table_references</span><br>   [<span class="hljs-type">WHERE</span> <span class="hljs-type">where_condition</span>]<br>   [<span class="hljs-type">GROUP</span> <span class="hljs-type">BY</span> &#123;<span class="hljs-type">col_name</span> | <span class="hljs-type">expr</span> | <span class="hljs-type">position</span>&#125;<br>     [<span class="hljs-type">ASC</span> | <span class="hljs-type">DESC</span>], <span class="hljs-type">...</span> [<span class="hljs-type">WITH</span> <span class="hljs-type">ROLLUP</span>]]<br>   [<span class="hljs-type">HAVING</span> <span class="hljs-type">where_condition</span>]<br>   [<span class="hljs-type">ORDER</span> <span class="hljs-type">BY</span> &#123;<span class="hljs-type">col_name</span> | <span class="hljs-type">expr</span> | <span class="hljs-type">position</span>&#125;<br>     [<span class="hljs-type">ASC</span> | <span class="hljs-type">DESC</span>], <span class="hljs-type">...</span>]<br>   [<span class="hljs-type">LIMIT</span> &#123;[<span class="hljs-type">offset</span>,] <span class="hljs-type">row_count</span> | <span class="hljs-type">row_count</span> <span class="hljs-type">OFFSET</span> <span class="hljs-type">offset</span>&#125;]<br>   [<span class="hljs-type">PROCEDURE</span> <span class="hljs-type">procedure_name</span>(<span class="hljs-type">argument_list</span>)]<br>   [<span class="hljs-built_in">INT</span><span class="hljs-type">O</span> <span class="hljs-type">OUTFILE</span> <span class="hljs-string">&#x27;file_name&#x27;</span><br>       [<span class="hljs-built_in">CHAR</span><span class="hljs-type">ACTER</span> <span class="hljs-type">SET</span> <span class="hljs-built_in">char</span><span class="hljs-type">set_name</span>]<br>       <span class="hljs-type">export_options</span><br>     | <span class="hljs-built_in">INT</span><span class="hljs-type">O</span> <span class="hljs-type">DUMPFILE</span> <span class="hljs-string">&#x27;file_name&#x27;</span><br>     | <span class="hljs-built_in">INT</span><span class="hljs-type">O</span> <span class="hljs-type">var_name</span> [, <span class="hljs-type">var_name</span>]]<br>   [<span class="hljs-type">FOR</span> <span class="hljs-type">UPDATE</span> | <span class="hljs-type">LOCK</span> <span class="hljs-type">IN</span> <span class="hljs-type">SHARE</span> <span class="hljs-type">MODE</span>]]<br><br>说明<br>字段显示可以使用别名：col1 AS alias1, col2 AS alias2，......<br><span class="hljs-built_in">WHERE</span>子句：指明过滤条件以实现<span class="hljs-string">&quot;选择&quot;</span>的功能<br>    过滤条件：布尔型表达式<br>    算术操作符：+，-，*，/， %<br>    比较操作符：=，&lt;=&gt;（相等或都为空）,&lt;&gt;，!=(非标准SQL)，&gt;，&gt;=，&lt;，&lt;=<br>    逻辑操作符：NOT，AND，OR，XOR<br><br>范例查询：BETWEEN min_num AND max_num<br>不连续的查询：<span class="hljs-keyword">IN</span> (element1，element2，...)  <br>空查询：IS NULL,，IS NOT NULL<br><br>DISTINCT 去除重复行，范例：<span class="hljs-built_in">SELECT</span> DISTINCT gender FROM students;<br><br>模糊查询：LIKE 使用 % 表示任意长度的任意字符 _ 表示任意单个字符<br>RLIKE：正则表达式，索引失效，不建议使用<br>REGEXP：匹配字符串可用正则表达式书写模式，同上<br><br><span class="hljs-built_in">GROUP</span> BY：根据指定的条件把查询结果进行<span class="hljs-string">&quot;分组&quot;</span>以用于做<span class="hljs-string">&quot;聚合&quot;</span>运算<br>常见聚合函数： count()，sum()，max()，min()，avg()，注意：聚合函数不对null统计<br>HAVING：对分组聚合运算后的结果指定过滤条件<br>一旦分组 <span class="hljs-built_in">group</span> by，<span class="hljs-built_in">select</span>语句后只跟分组的字段，聚合函数<br><br>ORDER BY：根据指定的字段对查询结果进行排序<br>升序：ASC<br>降序：DESC<br><br>LIMIT [[<span class="hljs-type">offset</span>,]<span class="hljs-type">row_count</span>]：对查询的结果进行输出行数数量限制，跳过 offset，显示row_count 行，offset 默为值为 <span class="hljs-number">0</span>。<br><br><span class="hljs-keyword">FOR</span> UPDATE：写锁，独占或排它锁，只有一个读和写操作<br>LOCK <span class="hljs-keyword">IN</span> SHARE MODE：读锁，共享锁，同时多个读操作<br></code></pre></td></tr></table></figure><h3 id="DQL-语句进阶"><a href="#DQL-语句进阶" class="headerlink" title="DQL 语句进阶"></a><strong>DQL</strong> <strong>语句进阶</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs powershell">```<br><br>**多表查询语句类型**<br><br>| 查询分类     | 说明                                                         |<br>| <span class="hljs-literal">------------</span> | <span class="hljs-literal">------------------------------------------------------------</span> |<br>| 子查询       | 在SQL语句中嵌套着查询语句，性能较差，基于某语句的查询结果再次进行的查询 |<br>| 联合查询     | UNION                                                        |<br>| 交叉连接     | 笛卡尔积 CROSS JOIN                                          |<br>| 等值内连接   | 让表之间的字段以<span class="hljs-string">&quot;等值&quot;</span>建立连接关系                           |<br>| 不等值内连接 | 让表之间的字段以<span class="hljs-string">&quot;不等值&quot;</span>建立连接关系                         |<br>| 自然连接     | 去掉重复列的等值连接                                         |<br>| 左外连接     | LEFT JOIN                                                    |<br>| 右外连接     | RIGHT JOIN                                                   |<br>| 完全外连接   | tb1 FULL OUTER JOIN tb2 ON tb1.col=tb2.col，MySQL 不支持此写法 |<br>| 自连接       | 本表和本表进行连接查询                                       |<br><br><span class="hljs-comment">#### 子查询</span><br><br>```powershell<br>子查询 subquery<br>即 SQL 语句调用另一个 <span class="hljs-built_in">SELECT</span> 子句，可以是对同一张表，也可以是对不同表<br><br>子查询主要有四种用法<br><span class="hljs-number">1</span> 用于比较表达式中的子查询；子查询仅能返回单个值<br><span class="hljs-number">2</span> 用于<span class="hljs-keyword">IN</span>中的子查询：子查询应该单独查询并返回一个或多个值重新构成列表<br><span class="hljs-number">3</span> 用于 EXISTS 和 Not EXISTS<br><span class="hljs-number">4</span> 用于FROM子句中的子查询<br></code></pre></td></tr></table></figure><h4 id="存在与否子查询"><a href="#存在与否子查询" class="headerlink" title="存在与否子查询"></a><strong>存在与否子查询</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">用于 EXISTS 和 Not EXISTS<br>  EXISTS(包括 NOT EXISTS )子句的返回值是一个BOOL值。<br>    EXISTS 内部有一个子查询语句(<span class="hljs-built_in">SELECT</span>... FROM...)， 将其称为EXIST的内查询语句。<br>   其内查询语句返回一个结果集。<br>   <br>    EXISTS 子句根据其内查询语句的结果集空或者非空，返回一个布尔值。<br>   将外查询表的每一行，代入内查询作为检验，如果内查询返回的结果为非空值，则EXISTS子句返回TRUE，<br>   外查询的这一行数据便可作为外查询的结果行返回，否则不能作为结果。 <br><br>EXISTS (或 NOT EXISTS) 用在 <span class="hljs-built_in">where</span>之后，且后面紧跟子查询语句（带括号）<br> EXISTS (或 NOT EXISTS) 只关心子查询有没有结果,并不关心子查询的结果具体是什么<br> 下面语句把stu的记录逐条代入到Exists后面的子查询中，如果子查询结果集不为空，即说明存在，那<br>么这条stu的记录出现在最终结果集，否则被排除<br></code></pre></td></tr></table></figure><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SQL中的联合连接（或称联合、UNION）主要用于合并两个或多个<span class="hljs-built_in">SELECT</span>语句的结果集，并返回合并后的结果。这些<span class="hljs-built_in">SELECT</span>语句必须拥有相同数量的列，且对应列的数据类型也需要兼容。<br>  联合连接有两种主要形式：UNION和UNION ALL。<br></code></pre></td></tr></table></figure><h4 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a><strong>交叉连接</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SQL的交叉连接（CROSS JOIN）是一种特殊的连接操作，它返回两个或多个表中所有可能的行组合。<br>交叉连接简单地将两个表的所有记录相互匹配，生成的结果集是两个表的笛卡尔积。即，如果表A有M行，表B有N行，那么交叉连接的结果集将包含M*N行。<br></code></pre></td></tr></table></figure><h4 id="内链接"><a href="#内链接" class="headerlink" title="内链接"></a>内链接</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell"> SQL中的内连接（INNER JOIN）是一种基本的连接操作，用于从两个或多个表中返回满足连接条件的记录。内连接只返回那些在连接条件中有匹配值的记录。如果某个记录在连接的一个表中存在，但在另一个表中没有匹配的连接值，则该记录不会出现在结果集中。<br> 基本语法<br><span class="hljs-built_in">SELECT</span> 列名<span class="hljs-number">1</span>, 列名<span class="hljs-number">2</span>, ... <span class="hljs-comment"># 指定要从连接的结果集中选择的列</span><br>FROM 表<span class="hljs-number">1</span>  <span class="hljs-comment"># 指定连接操作中的第一个表。</span><br>INNER JOIN 表<span class="hljs-number">2</span>  <span class="hljs-comment"># 指定要与第一个表进行内连接的第二个表。</span><br>ON 表<span class="hljs-number">1</span>.列名 = 表<span class="hljs-number">2</span>.列名;   <span class="hljs-comment"># 定义连接条件。两个表中哪些列的值应该相等，然后记录匹配在一起。</span><br>内连接也可以使用其他SQL关键字或子句进行扩展，比如<span class="hljs-built_in">WHERE</span>、ORDER BY、<span class="hljs-built_in">GROUP</span> BY等，以满足更复杂的查询需求。<br></code></pre></td></tr></table></figure><h4 id="自然链接"><a href="#自然链接" class="headerlink" title="自然链接"></a>自然链接</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"> SQL自然连接（NATURAL JOIN）是一种特殊的内连接，用于在两个或多个表之间基于相同列名进行匹配，并将匹配到的记录组合在一起，同时消除重复的列。<br>- 当源表和目标表共享相同名称的列时，就可以在它们之间执行自然连接，而无需指定连接列。<br>- 在使用纯自然连接时，如没有相同的列时，会产生交叉连接（笛卡尔乘积）。<br>语法格式：<span class="hljs-built_in">SELECT</span> * FROM A NATURAL JOIN B;<br></code></pre></td></tr></table></figure><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SQL中的外连接（Outer Join）是一种数据库查询操作，用于联结两个或多个表，并返回满足指定条件的记录，同时包括那些在联结条件中不匹配的记录。<br></code></pre></td></tr></table></figure><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell">  自连接（Self Join）是SQL中的一种连接操作，它允许一个表与其自身进行连接。这种操作在处理需要比较表中记录之间关系的场景时非常有用。通过自连接，你可以将表看作两个不同的表，并基于它们之间的某些匹配条件来组合数据。<br>  <br>自连接的基本语法类似于其他类型的连接，但关键在于给同一个表指定两个不同的别名。<br><span class="hljs-built_in">SELECT</span> a.*, b.*<br>FROM table_name a<br>JOIN table_name b<br>ON a.common_column = b.common_column; <span class="hljs-comment"># common_column 是用于连接两个实例的表的匹配条件。</span><br><br>自连接的作用<br>查找表中具有特定关系的记录：<br> 例如，有一个员工表 employees，其中包含员工ID和经理ID（manager_id），你可以使用自连接来查找每个员工的经理信息。<br>查找表中的层级关系：<br> 例如，一个组织结构表 org_structure，其中每个节点都有一个父节点，你可以使用自连接来查找某个节点的所有上级节点。<br>查找表中的重复记录：<br> 例如，有一个客户表 customers，你想找到所有具有相同电子邮件地址的客户，你可以使用自连接来比较表中的记录。<br> <br>性能：自连接可能会产生大量的中间结果集，因此在大数据集上使用时需要特别注意性能。<br>别名：务必为同一个表的不同实例使用不同的别名，否则会导致SQL语法错误。<br>条件：确保连接条件正确，以避免返回不相关的结果。<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MariaDB [<span class="hljs-type">db1</span>]&gt; <span class="hljs-built_in">select</span> * from students;<span class="hljs-built_in">select</span> * from subjects;<span class="hljs-built_in">select</span> * from scores;<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">-----------</span>+<br>| id | name      |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">-----------</span>+<br>|  <span class="hljs-number">1</span> | zhang san |<br>|  <span class="hljs-number">2</span> | li <span class="hljs-built_in">si</span>     |<br>|  <span class="hljs-number">3</span> | wang wu   |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">-----------</span>+<br><span class="hljs-number">3</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">--------</span>+<br>| id | name   |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">--------</span>+<br>|  <span class="hljs-number">1</span> | linux  |<br>|  <span class="hljs-number">2</span> | golang |<br>|  <span class="hljs-number">3</span> | python |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">--------</span>+<br><span class="hljs-number">3</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br>+<span class="hljs-literal">------------</span>+<span class="hljs-literal">------------</span>+<span class="hljs-literal">-------</span>+<br>| student_id | subject_id | score |<br>+<span class="hljs-literal">------------</span>+<span class="hljs-literal">------------</span>+<span class="hljs-literal">-------</span>+<br>|          <span class="hljs-number">1</span> |          <span class="hljs-number">1</span> |    <span class="hljs-number">60</span> |<br>|          <span class="hljs-number">1</span> |          <span class="hljs-number">2</span> |    <span class="hljs-number">70</span> |<br>|          <span class="hljs-number">1</span> |          <span class="hljs-number">3</span> |    <span class="hljs-number">80</span> |<br>|          <span class="hljs-number">2</span> |          <span class="hljs-number">1</span> |    <span class="hljs-number">70</span> |<br>|          <span class="hljs-number">2</span> |          <span class="hljs-number">2</span> |    <span class="hljs-number">75</span> |<br>|          <span class="hljs-number">2</span> |          <span class="hljs-number">3</span> |    <span class="hljs-number">65</span> |<br>|          <span class="hljs-number">3</span> |          <span class="hljs-number">1</span> |    <span class="hljs-number">90</span> |<br>|          <span class="hljs-number">3</span> |          <span class="hljs-number">2</span> |    <span class="hljs-number">85</span> |<br>|          <span class="hljs-number">3</span> |          <span class="hljs-number">3</span> |    <span class="hljs-number">65</span> |<br>+<span class="hljs-literal">------------</span>+<span class="hljs-literal">------------</span>+<span class="hljs-literal">-------</span>+<br><span class="hljs-number">9</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br>MariaDB [<span class="hljs-type">db1</span>]&gt; <span class="hljs-built_in">select</span> students.id, students.name,subjects.name as subject_name,score from students left join scores on students.id=scores.student_id left join subjects on subjects.id=scores.subject_id;<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">-----------</span>+<span class="hljs-literal">--------------</span>+<span class="hljs-literal">-------</span>+<br>| id | name      | subject_name | score |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">-----------</span>+<span class="hljs-literal">--------------</span>+<span class="hljs-literal">-------</span>+<br>|  <span class="hljs-number">1</span> | zhang san | linux        |    <span class="hljs-number">60</span> |<br>|  <span class="hljs-number">1</span> | zhang san | golang       |    <span class="hljs-number">70</span> |<br>|  <span class="hljs-number">1</span> | zhang san | python       |    <span class="hljs-number">80</span> |<br>|  <span class="hljs-number">2</span> | li <span class="hljs-built_in">si</span>     | linux        |    <span class="hljs-number">70</span> |<br>|  <span class="hljs-number">2</span> | li <span class="hljs-built_in">si</span>     | golang       |    <span class="hljs-number">75</span> |<br>|  <span class="hljs-number">2</span> | li <span class="hljs-built_in">si</span>     | python       |    <span class="hljs-number">65</span> |<br>|  <span class="hljs-number">3</span> | wang wu   | linux        |    <span class="hljs-number">90</span> |<br>|  <span class="hljs-number">3</span> | wang wu   | golang       |    <span class="hljs-number">85</span> |<br>|  <span class="hljs-number">3</span> | wang wu   | python       |    <span class="hljs-number">65</span> |<br>+<span class="hljs-literal">----</span>+<span class="hljs-literal">-----------</span>+<span class="hljs-literal">--------------</span>+<span class="hljs-literal">-------</span>+<br><span class="hljs-number">9</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br></code></pre></td></tr></table></figure><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SQL 注入是指应用程序对用户输入的数据没有严格校验，没有做合法性判断或者过滤不严格，让攻击者可以通过传参的形式构建特殊的SQL语句并执行，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息，并非法获取系统权限。<br></code></pre></td></tr></table></figure><p><strong>SELECT</strong> <strong>语句处理的顺序</strong></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">查询执行路径中的组件：查询缓存、解析器、预处理器、优化器、查询执行引擎、存储引擎<br><br><span class="hljs-built_in">SELECT</span>语句的执行流程：<br>FROM Clause <span class="hljs-literal">--</span>&gt; <span class="hljs-built_in">WHERE</span> Clause <span class="hljs-literal">--</span>&gt; <span class="hljs-built_in">GROUP</span> BY <span class="hljs-literal">--</span>&gt; HAVING Clause <span class="hljs-literal">--</span>&gt;<span class="hljs-built_in">SELECT</span> <span class="hljs-literal">--</span>&gt; ORDER BY <span class="hljs-literal">--</span>&gt; LIMIT<br></code></pre></td></tr></table></figure><pre><code class=" mermaid">flowchart TB    A((SQL 解析)) --&gt; B(FROM: 笛卡尔积)    B --&gt; C(JOIN: 不符合 ON 也添加)    C --&gt; D(ON: 主表保留)    D --&gt; E(WHERE: 非聚合, 非 SELECT 别名)    E --&gt; F(GROUP BY: 改变对表引用)    F --&gt; G(HAVING: 只作用分组后)    G --&gt; H(SELECT: DISTINCT)    H --&gt; I(ORDER BY: 可使用 SELECT 别名)    I --&gt; J(LIMIT: rows, offset)</code></pre><h2 id="SQL高阶语法"><a href="#SQL高阶语法" class="headerlink" title="SQL高阶语法"></a>SQL高阶语法</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs powershell">视图：虚拟表，保存有实表的查询结果，相当于别名。<br>  利用视图，可以隐藏表真实结构，在程序中利用视图进行查询，可以避免表结构的变化，而修改程序，降低程序和数据库之间的耦合度。<br>  视图中的数据，实际上是存在于相对应的表中，视图本身没有数据，因此，修改视图中的数据，本质上是修改了表中的数据。<br>  视图是一种虚拟表，它基于SQL查询的结果集。<br>  <br>创建视图<br>CREATE<br>    [<span class="hljs-type">OR</span> <span class="hljs-type">REPLACE</span>]<br>    [<span class="hljs-type">ALGORITHM</span> = &#123;<span class="hljs-type">UNDEFINED</span> | <span class="hljs-type">MERGE</span> | <span class="hljs-type">TEMPTABLE</span>&#125;]<br>    [<span class="hljs-type">DEFINER</span> = &#123; <span class="hljs-type">user</span> | <span class="hljs-type">CURRENT_USER</span> &#125;]<br>    [<span class="hljs-type">SQL</span> <span class="hljs-type">SECURITY</span> &#123; <span class="hljs-type">DEFINER</span> | <span class="hljs-type">INVOKER</span> &#125;]<br>    VIEW view_name [(<span class="hljs-type">column_list</span>)]<br>    AS select_statement<br>    [<span class="hljs-type">WITH</span> [<span class="hljs-type">CASCADED</span> | <span class="hljs-type">LOCAL</span>] <span class="hljs-type">CHECK</span> <span class="hljs-type">OPTION</span>]  <br><br>查看视图<br>SHOW CREATE VIEW view_name <span class="hljs-comment">#只能看视图定义</span><br>SHOW CREATE TABLE view_name <span class="hljs-comment"># 可以查看表和视图</span><br><br>删除视图<br>DROP VIEW [<span class="hljs-type">IF</span> <span class="hljs-type">EXISTS</span>]<br>    view_name [, <span class="hljs-type">view_name</span>] ...<br>    [<span class="hljs-type">RESTRICT</span> | <span class="hljs-type">CASCADE</span>]<br></code></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL 中的变量分为系统内置变量和用户自定义变量<br>系统变量：MySQL数据库中内置的变量，可用 <span class="hljs-selector-tag">@</span>@var_name 引用。<br><br>用户自定义变量分为以下两种：<br>普通变量：在当前会话中有效，可用 @var_name 引用<br>局部变量：在函数或存储过程内才有效，需要用 DECLARE 声明，之后直接用 var_name 引用<br><br>自定义函数中定义局部变量语法<br>局部变量的作用范围是在 BEGIN...END 程序中，而且定义局部变量语句必须在 BEGIN...END 的第一行定义。<br>DECLARE 变量<span class="hljs-number">1</span>[,变量<span class="hljs-number">2</span>,<span class="hljs-type">...</span> ]变量类型 [<span class="hljs-type">DEFAULT</span> 默认值]<br><br>为变量赋值<br><span class="hljs-built_in">SET</span> parameter_name = value[,<span class="hljs-type">parameter_name</span> = <span class="hljs-type">value...</span>]<br><span class="hljs-built_in">SELECT</span> INTO parameter_name<br></code></pre></td></tr></table></figure><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL的存储过程是一组为了完成特定功能的SQL语句集，它存储在数据库中，可以被用户调用。<br>MySQL中的存储过程指的是存储在数据库中的SQL语句集合。当创建好存储过程后，在运行时提供所需参数，存储过程就可以以代码指定的方式使用参数执行并返回值。<br>  它可以独立执行，存储过程保存在 mysql.proc 表中<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">封装与复用：<br> 存储过程将复杂的SQL逻辑封装在一起，形成一个独立的执行单元。<br> 用户可以通过调用存储过程来执行这些逻辑，而无需每次都编写重复的SQL语句。<br> 这有助于提高代码的复用性和可维护性。<br> <br>接收参数与返回数据：<br> 存储过程可以接受输入参数，并根据这些参数执行相应的逻辑。<br> 同时，存储过程也可以返回数据，包括状态码、结果集等。<br> <br>编译与执行效率：<br> 存储过程在创建时会被编译成二进制代码，并存储在数据库中。<br> 当存储过程被调用时，数据库可以直接执行这些预编译的代码，而无需每次都重新编译SQL语句。<br> 这有助于提高数据库的执行效率。<br></code></pre></td></tr></table></figure><h4 id="存储过程与自定义函数的区别"><a href="#存储过程与自定义函数的区别" class="headerlink" title="存储过程与自定义函数的区别"></a>存储过程与自定义函数的区别</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">- 存储过程实现的过程要复杂一些，而函数的针对性较强。<br>- 存储过程可以有多个返回值，而自定义函数只有一个返回值。<br>- 存储过程一般可独立执行，而函数往往是作为其他SQL语句的一部分来使用。<br>- 无参数的存储过程执行过程中可以不加()，函数必须加 ()。<br></code></pre></td></tr></table></figure><h4 id="存储过程语法"><a href="#存储过程语法" class="headerlink" title="存储过程语法"></a>存储过程语法</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs powershell">创建存储过程<br>CREATE PROCEDURE 存储过程名 (参数列表)<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-literal">--</span> SQL语句<br><span class="hljs-keyword">END</span>;<br>其中，参数列表可以包含输入参数（<span class="hljs-keyword">IN</span>）、输出参数（OUT）或输入输出参数（INOUT）。<br><br>调用存储过程：<br>CALL 存储过程名(参数值);<br><br>查看存储过程：<br>查看存储过程列表<br>SHOW PROCEDURE STATUS<br>查看存储过程定义<br>SHOW CREATE PROCEDURE sp_name<br><br>修改存储过程<br>ALTER语句修改存储过程只能修改存储过程的注释等无关紧要的东西,不能修改存储过程体.<br>   所以要修改存储过程,方法就是删除重建<br>   <br>删除存储过程：<br>DROP PROCEDURE <span class="hljs-keyword">IF</span> EXISTS 存储过程名;<br></code></pre></td></tr></table></figure><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs powershell">存储过程中的流程控制，可以使用流程控制来控制语句的执行<br><br>条件控制语句：如<span class="hljs-keyword">IF</span>、CASE等，用于根据条件执行不同的SQL语句。<br>- <span class="hljs-keyword">IF</span>：用来进行条件判断。根据是否满足条件，执行不同语句<br>- CASE：用来进行条件判断，可实现比<span class="hljs-keyword">IF</span>语句更复杂的条件判断<br><br>循环控制语句：如<span class="hljs-keyword">WHILE</span>、REPEAT、LOOP等，用于重复执行一组SQL语句直到满足特定条件为止。<br>- LOOP：重复执行特定的语句，实现一个简单的循环<br>- LEAVE：用于跳出循环控制，相当于SHELL中<span class="hljs-keyword">break</span><br>- ITERATE：跳出本次循环，然后直接进入下一次循环，相当于SHELL中<span class="hljs-keyword">continue</span><br>- REPEAT：有条件控制的循环语句。当满足特定条件时，就会跳出循环语句<br>- <span class="hljs-keyword">WHILE</span>：有条件控制的循环语句<br><br>应用场景<br>数据转换与迁移：<br> 存储过程可以用于数据转换和迁移任务，<br> 如将一种数据格式转换为另一种数据格式，或将数据从一个表迁移到另一个表。<br> <br>复杂逻辑处理：<br> 存储过程可以封装复杂的SQL逻辑，如多表关联查询、条件判断、循环处理等。<br> <br>报表生成：<br> 存储过程可以用于生成报表数据，如根据特定条件查询数据并返回结果集供报表工具使用。<br> <br> <br></code></pre></td></tr></table></figure><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL触发器是一种数据库管理系统（DBMS）中的功能，它允许用户定义在指定表上的某些操作（如INSERT、UPDATE或DELETE）发生之前或之后自动执行的SQL语句或语句集。<br>触发器是与表事件（例如表的INSERT、UPDATE或DELETE操作）相关联的命名数据库对象。当在指定表上发生特定事件时，触发器会自动激活，并执行相应的SQL语句。<br><br>特点<br>触发器是数据库层面上的自动化工具，当特定的数据库操作发生时自动执行，无需手动调用。<br>触发器在事件发生时立即执行，适用于需要实时处理数据变化的场景。<br>触发器可以帮助维护数据的完整性和一致性，无需依赖应用程序代码来实现这些功能。<br><br>应用场景<br>触发器在实际开发中有广泛的应用，以下是几个常见的应用场景：<br>自动化任务：<br> 触发器可以自动记录表数据变化的日志、生成统计信息等。例如，在用户表中添加一条记录时，同时在日志表中记录这条记录的信息。<br> <br>数据验证：<br> 可以在数据更新时验证数据的完整性和正确性。例如，确保账户余额始终非负。<br> <br>实时同步：<br> 保持多个表之间的一致性。例如，当主表的数据发生变化时，相应的变更也会反映到备份表中。<br> <br>复杂业务逻辑：<br> 实现比简单约束更复杂的规则。例如，每当有新的员工加入公司时，自动更新部门中的人数。<br> <br>使用语法<br>创建触发器：使用CREATE TRIGGER语句来创建触发器。<br>CREATE TRIGGER trigger_name<br>&#123;BEFORE|AFTER&#125; &#123;INSERT|UPDATE|DELETE&#125;<br>ON table_name<br><span class="hljs-keyword">FOR</span> EACH ROW<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-literal">--</span> 触发器逻辑<br><span class="hljs-keyword">END</span>;<br>    trigger_name是触发器的名称；<br>    BEFORE或AFTER指定触发器是在操作之前还是之后执行；<br>    INSERT、UPDATE或DELETE指定触发器响应的操作类型；<br>    table_name是触发器绑定的表；<br>    <span class="hljs-keyword">FOR</span> EACH ROW表示触发器针对表中的每一行进行操作。<br><br>查看触发器：可以使用SHOW TRIGGERS命令来查看系统中存在的所有触发器。<br>样式<span class="hljs-number">1</span>：<br>SHOW TRIGGERS;<br>样式<span class="hljs-number">2</span>：<br>USE information_schema;<br><span class="hljs-built_in">SELECT</span> * FROM triggers <span class="hljs-built_in">WHERE</span> trigger_name=<span class="hljs-string">&#x27;trigger_name&#x27;</span>;<br><br>删除触发器：如果需要删除某个触发器，可以使用DROP TRIGGER语句。<br>DROP TRIGGER <span class="hljs-keyword">IF</span> EXISTS trigger_name;<br></code></pre></td></tr></table></figure><h3 id="事件调度器"><a href="#事件调度器" class="headerlink" title="事件调度器"></a>事件调度器</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">事件调度器是MySQL数据库服务器的一部分，负责事件的调度，不断监视某个事件是否被调用。<br>可以通过SHOW VARIABLES LIKE <span class="hljs-string">&#x27;event_scheduler&#x27;</span>或<span class="hljs-built_in">SELECT</span> <span class="hljs-selector-tag">@</span>@event_scheduler命令查看事件调度器的状态。<br><br>通过命令开启：<br> 使用<span class="hljs-built_in">SET</span> GLOBAL event_scheduler = ON命令可以开启事件调度器。<br>通过命令关闭：<br> 使用<span class="hljs-built_in">SET</span> GLOBAL event_scheduler = OFF命令可以关闭事件调度器。<br>通过配置文件开启：<br> 在MySQL配置文件中找到[<span class="hljs-type">mysqld</span>]选项，然后添加event_scheduler = ON代码并保存，之后重启MySQL服务即可生效。<br> <br>注意事项：<br> 通过<span class="hljs-built_in">SET</span> GLOBAL命令开启或关闭事件后，MySQL重启服务后事件又会回到原来的状态（默认为OFF）。如果想要始终开启或关闭事件，需要修改MySQL配置文件。<br></code></pre></td></tr></table></figure><h2 id="事件管理"><a href="#事件管理" class="headerlink" title="事件管理"></a>事件管理</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">创建事件<br>create event 语句创建一个事件。每个事件由两个主要部分组成，<br> 第一部分是事件调度（event schedule），表示事件何时启动以及按什么频率启动，<br> 第二部分是事件动作（event action ），这是事件启动时执行的代码，事件的动作包含一条SQL语句，<br> 它可能是一个简单地insert 或者 update语句，<br> 也可以是一个存储过程或者 benin...end 语句块，<br> 这两种情况允许我们执行多条SQL。<br></code></pre></td></tr></table></figure><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">创建用户;CREATE USER<br>格式<br> CREATE USER <span class="hljs-string">&#x27;USERNAME&#x27;</span><span class="hljs-string">@&#x27;HOST&#x27; [IDENTIFIED BY &#x27;password&#x27;]；</span><br><span class="hljs-string">范例</span><br><span class="hljs-string">    create user test@&#x27;10.0.0.0/255.255.255.0&#x27; identified by &#x27;123456&#x27;;</span><br><span class="hljs-string">    create user test2@&#x27;10.0.0.%&#x27; identified by &#x27;123456&#x27;; </span><br><span class="hljs-string"></span><br><span class="hljs-string">重命名用户：RENAME USER</span><br><span class="hljs-string">格式</span><br><span class="hljs-string"> RENAME USER &#x27;USERNAME&#x27;@&#x27;HOST&#x27; TO &#x27;USERNAME&#x27;@&#x27;HOST&#x27;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">删除用户：DROP USER</span><br><span class="hljs-string">格式</span><br><span class="hljs-string"> DROP USER &#x27;USERNAME&#x27;@&#x27;HOST&#x27;</span><br><span class="hljs-string">范例，删除默认的空用户</span><br><span class="hljs-string"> DROP USER &#x27;&#x27;@&#x27;localhost&#x27;;</span><br></code></pre></td></tr></table></figure><h3 id="密码信息"><a href="#密码信息" class="headerlink" title="密码信息"></a>密码信息</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL8.<span class="hljs-number">0</span>中的密码是放在 mysql.user 表中 authentication_string 字段中，但MariaDB中还保留了Password字段<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 数据库-1</title>
    <link href="/2024/08/18/MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93-1/"/>
    <url>/2024/08/18/MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93-1/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-数据库-1"><a href="#MySQL-数据库-1" class="headerlink" title="MySQL 数据库-1"></a><strong>MySQL</strong> <strong>数据库</strong>-1</h1><h2 id="MySQL-架构和性能优化"><a href="#MySQL-架构和性能优化" class="headerlink" title="MySQL 架构和性能优化"></a><strong>MySQL</strong> <strong>架构和性能优化</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mysql的查询过程<br><span class="hljs-number">1</span> 客户端发送查询请求：<br>  用户通过客户端（如命令行工具、数据库管理工具等）发送SQL查询语句到MySQL服务器。<br><br><span class="hljs-number">2</span> 服务器接收并处理连接：<br>  MySQL服务器通过连接器接收客户端的连接请求，并进行身份认证和权限验证。<br>  如果验证成功，服务器为客户端分配一个独立的线程来处理后续的查询请求。<br><br><span class="hljs-number">3</span> 查询缓存（MySQL <span class="hljs-number">8.0</span>后已移除该功能）：<br>  在早期版本的MySQL中，服务器会检查查询缓存，看是否存在已经执行过且结果未过期的相同查询。<br>  如果缓存命中，则直接返回缓存的结果，跳过后续的解析和执行步骤。<br>注意：<br>  由于查询缓存的局限性（如更新操作会导致缓存失效），在MySQL <span class="hljs-number">8.0</span>及以后版本中，查询缓存功能已被移除。<br> 原因：<br>  维护成本高：在早期版本中，每当数据发生变化，如执行插入、更新或删除操作时，相关的查询缓存就可能会失效，需要进行清理或更新。随着数据量和更新频率的增加，这种维护操作的开销会变得非常大，甚至可能超过查询缓存带来的性能提升。<br>  缓存命中率不稳定：查询缓存的效果依赖于查询的重复性和数据的稳定性。在实际应用中，如果查询语句变化多样，或者数据更新频繁，查询缓存的命中率可能会很低，导致查询缓存占用了内存资源却不能有效提高性能。<br>  内存管理复杂：管理查询缓存需要额外的内存空间，并且要解决内存碎片等问题。在高并发环境下，内存管理的复杂性会进一步增加，可能导致性能问题和内存泄漏等风险。<br><br><span class="hljs-number">4</span> SQL解析：<br>    服务器对接收到的SQL查询语句进行解析，生成解析树（或称为语法树）。<br>    解析过程包括词法分析和语法分析，确保SQL语句的语法正确，并识别出SQL语句中的关键字、表名、列名等。<br>    随后进行语义分析，检查表名、列名是否存在，以及用户是否有相应的权限。<br><br><span class="hljs-number">5</span> 查询优化optimizer：<br>    优化器对解析后的查询语句进行优化，生成最优的执行计划。<br>    优化过程包括选择最佳的索引、确定表的连接顺序、重写查询等，以提高查询效率。<br>    优化器会计算不同执行计划的预测成本值，并选择成本最小的计划作为最终执行计划。<br><br><span class="hljs-number">6</span> 执行计划生成：<br>    根据优化器生成的执行计划，服务器确定具体的查询执行步骤。<br>    执行计划包括选择索引、读取顺序、数据过滤、排序、聚合等操作。<br><br><span class="hljs-number">7</span> 执行查询并返回结果：<br>    执行器根据执行计划调用存储引擎的API来执行查询操作。<br>    存储引擎负责具体的数据存储和读取操作，根据执行计划读取数据并返回给执行器。<br>    执行器对读取到的数据进行处理（如过滤、排序、聚合等），然后生成结果集。<br><br>最终，服务器将处理后的结果集返回给客户端。<br><br></code></pre></td></tr></table></figure><h2 id="mysql组件"><a href="#mysql组件" class="headerlink" title="mysql组件"></a>mysql组件</h2><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">连接器对  Native，JDBC，ODBC，NET，PHP，Perl，Python，Ruby，Cobol 等客户端工具或编程语言的 API 对MySQL 的连接功能进行管理。连接器是 Server 端的第一个模块。<br> 每种编程语言软件几乎都有适合自己的连接器软件插件。<br></code></pre></td></tr></table></figure><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL的线程池是一种重要的技术，旨在提高数据库的性能和资源利用效率。<br>作用<br>MySQL的线程池在提高资源利用效率、减少线程创建和销毁的开销、实现负载均衡以及提高并发处理能力等方面发挥着重要作用。它是数据库性能优化的重要手段之一，特别适用于高并发环境下的数据库访问。同时，线程池还可以与连接池结合使用，以进一步提高数据库性能。<br><span class="hljs-number">1</span> 资源复用：<br>    线程池复用线程，减少了线程的创建和销毁开销。<br>    连接池复用连接，减少了连接的创建和销毁开销。<br><span class="hljs-number">2</span> 提高并发处理能力：<br>    线程池可以处理多个并发请求，而不需要为每个请求创建新的线程。<br>    连接池可以管理多个数据库连接，确保在高并发情况下，应用程序能够迅速获取到数据库连接。<br><span class="hljs-number">3</span> 优化资源分配：<br> 通过线程池和连接池的结合使用，可以更合理地分配系统资源。例如，可以根据系统的负载情况动态调整线程池和连接池的大小，以平衡性能和资源利用率。<br><span class="hljs-number">4</span> 简化管理：<br> 线程池和连接池都提供了对资源和连接的管理功能，使得开发人员可以更加专注于业务逻辑的实现，而不需要过多关注底层资源的管理。<br></code></pre></td></tr></table></figure><h4 id="SQL语句解析"><a href="#SQL语句解析" class="headerlink" title="SQL语句解析"></a>SQL语句解析</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SQL Interface：SQL 语句接口<br>  完整的 sql 命令的解释器，对 SQL 语句进行检查，是否有错误，并且进行词法分析，语法分析，识别出具体操作，对象，参数等。 <br><br>Parser：查询解析器 <br>  解析器会根据己经检查过的SQL语句生成一个数据结构，一般是树形结构，我们称其为解析树。在这个过程中也会校验当前连接的客户端是否有权限操作库和表等。<br>  在 MySQL 中，语法树（Syntax Tree），更准确地说是抽象语法树（Abstract Syntax Tree，AST），是对 SQL 语句进行解析后得到的一种树形结构表示.<br>  当你向 MySQL 服务器发送一条 SQL 语句时，服务器首先会对该语句进行词法分析和语法分析。词法分析将 SQL 语句拆分成一个个的词法单元（Token），例如关键字、标识符、操作符等；语法分析则根据 SQL 的语法规则，将这些词法单元组织成一个树形结构，即抽象语法树。<br><br>Optimizer：查询优化器<br>  优化器可以通过分析抽象语法树来理解 SQL 语句的逻辑结构和语义，从而确定如何以最有效的方式执行查询。例如，它可以识别出哪些条件可以提前过滤数据，哪些表连接可以采用更高效的算法<br>  根据解析器生成的解析树中的各个节点，生成不同的执行计划，然后决定一个最优的执行顺序路径，Mysql里面使用基于开销的优化器，哪种计划开销最小，就用哪种，从而保证在使用最少的开销的情况下返回正确的结果。<br>  SQL语句在执行的时候，会先判断一下连接用户是否对特定表具有查询的权限，然后根据表的引擎定义，去使用这个引擎提供的接口。  <br></code></pre></td></tr></table></figure><h4 id="其它组件"><a href="#其它组件" class="headerlink" title="其它组件"></a>其它组件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">存储引擎<br>  存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据，如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法。<br>  MySQL 数据库中的数据，本质上来讲，是存在于硬盘上的物理文件，不同的存储引擎有不同的特性，实际上就是使用不同的技术和方式来管理文件中的数据。<br>  存储引擎将存于硬盘上的物理文件，加载到内存中，然后再有上面的语句对内存中的数据，进行各种各样<br>的操作。  <br></code></pre></td></tr></table></figure><h2 id="存储引擎-默认是InnoDB"><a href="#存储引擎-默认是InnoDB" class="headerlink" title="存储引擎(默认是InnoDB)"></a>存储引擎(默认是InnoDB)</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力，此种技术称为存储引擎，MySQL 支持多种存储引擎，其中目前应用最广泛的是 InnoDB 和 MyISAM 两种。<br><br>存储引擎决定了数据如何存储在磁盘上，以及如何被访问。它提供了数据的存储机制、索引技巧、锁定水平，并最终提供不同的功能和能力。具体的数据库里面的输入，如何存储到物理的数据文件里面，是由存储引擎来实现的。<br><br>在 MySQL5.<span class="hljs-number">5</span> 之后默认存储引擎是 InnoDB，在之前是 MyISAM。<br><br>Mysql<span class="hljs-literal">-server</span> <span class="hljs-number">8.0</span> 默认情况下存储引擎有 <span class="hljs-number">9</span>个，Mariadb <span class="hljs-number">10</span> 默认情况下存储引擎数量有 <span class="hljs-number">11</span>个。<br></code></pre></td></tr></table></figure><h4 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a><strong>MyISAM</strong> <strong>存储引擎</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MyISAM 存储引擎特点<br>- 不支持事务<br>- 表级锁定<br>- 读写相互阻塞，写入不能读，读时不能写<br>- 只缓存索引<br>- 不支持外键约束<br>- 不支持聚簇索引<br>- 支持全文索引<br>- 读取数据较快，占用资源较少<br>- 不支持MVCC（多版本并发控制机制）高并发<br>- 崩溃恢复性较差<br>- MySQL5.<span class="hljs-number">5.5</span> 前默认的数据库引擎<br><br>MyISAM 存储引擎适用场景<br>- 读多写少的业务（或者只读的业务）<br>- 不需要事务支持的业务（比如转账，充值这种业务就不行）<br>- 并发访问低的业务<br>- 对数据一致性要求不高的业务<br>- 表较小（可以接受长时间进行修复操作）<br><br>MyISAM 存储引擎相关文件<br>- tbl_name.frm 表格式定义<br>- tbl_name.sdi 表格式定义（mysql8.<span class="hljs-number">0</span>开始，但是MariaDB目前依然在使用frm）<br>- tbl_name.MYD 数据文件<br>- tbl_name.MYI 索引文件<br></code></pre></td></tr></table></figure><h4 id="InnoDB-存储引擎"><a href="#InnoDB-存储引擎" class="headerlink" title="InnoDB 存储引擎"></a><strong>InnoDB</strong> <strong>存储引擎</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs powershell">InnoDB 存储引擎特点<br>- 支持事务，适合处理大量短期事务<br>- 行级锁定<br>- 读写阻塞与事务隔离级别相关<br>- 可缓存数据和索引<br>- 支持聚簇索引<br>- 崩溃恢复性更好<br>- 支持MVCC高并发<br>- 支持表分区，支持表空间<br>- 从MySQL5.<span class="hljs-number">5</span> 后支持全文索引<br>- 从MySQL5.<span class="hljs-number">5.5</span> 开始为默认的数据库引擎<br><br>InnoDB 存储引擎适用场景<br>- 数据读写都较为频繁的业务<br>- 需要事务支持的业务<br>- 对并发要求较高的业务<br>- 对数据一致性要求较高的业务<br><br>InnoDB 存储引擎相关文件<br>- tbl_name.frm 表格式定义<br>- tbl_name.ibd 数据和索引文件<br></code></pre></td></tr></table></figure><p><strong>MySQL****中常见的存储引擎特性说明</strong></p><table><thead><tr><th>特性（Feature）</th><th>MyISAM 存储引擎</th><th>Memory 存储引擎</th><th>InnoDB 存储引擎</th><th>Archive 存储引擎</th><th>NDB 存储引擎</th></tr></thead><tbody><tr><td>B 树索引（B - tree indexes）</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>备份时间点恢复（Backup&#x2F;point - in - time recovery）</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>集群模式（Cluster database support）</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>聚集索引（Clustered indexes）</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>数据压缩（Compressed data）</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>数据缓存（Data caches）</td><td>No</td><td>N&#x2F;A</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>数据加密（Encrypted data）</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>外键（Foreign key support）</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>全文检索（Full - text search indexes）</td><td>Yes</td><td>No</td><td>No</td><td>No</td><td>No</td></tr><tr><td>地理空间数据类型（Geospatial data type support）</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>地理空间数据索引（Geospatial indexing support）</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>HASH 索引（Hash indexes）</td><td>No</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>索引缓存（Index caches）</td><td>Yes</td><td>N&#x2F;A</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>锁颗粒度（Locking granularity）</td><td>Table</td><td>Table</td><td>Row</td><td>Row</td><td>Row</td></tr><tr><td>多版本并发控制（MVCC）</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>数据同步（Replication support）</td><td>Yes</td><td>Limited</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>表空间上限（Storage limits）</td><td>256TB</td><td>RAM</td><td>64TB</td><td>None</td><td>384EB</td></tr><tr><td>T 树索引（T - tree indexes）</td><td>No</td><td>No</td><td>No</td><td>No</td><td>Yes</td></tr><tr><td>事务（Transactions）</td><td>No</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td></tr><tr><td>元数据静态更新（Update statistics for data dictionary）</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table><h4 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">锁是计算机协调多个进程或线程并发访问某一资源的机制。<br>在关系型数据库中，按数据操作的颗粒度划分，分为表锁，行锁和页锁<br><br>表锁：<br>  表锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁（哪怕只操作表里面的一行数据），它实现简单，消耗资源少，被大部份 MySQL 存储引擎支持，MyISAM 存储引擎使用表锁，表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。<br>  表锁的特点是开销小，加锁快，不会出现死锁，锁定颗粒度大，发生锁冲突的概率高，并发性差。<br><br>行锁：<br>  行锁是 MySQL 中锁定粒度最小的一种锁，表示只对当前操作的行加锁，行锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。InnoDB存储引擎默认采用行锁。<br>  行锁的特点是开销大，加锁慢，会出现死锁，锁定颗粒度最小，发生锁冲突的概率最低，并发性好。<br></code></pre></td></tr></table></figure><h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">共享表空间<br>  共享表空间是指表结构文件单独放在以数据命名的文件夹中，格式为 tbl_name.frm，所有 InnoDB 引擎表的数据都放在一个文件中 (ibdata1,ibdata2,...)。<br>  <br>独立表空间<br>  独立表空间是指用独立文件存放每个表的表结构 tbl_name.frm 和数据及索引  tbl_name.ibd，在独立表空间的前提下，共享表空间中的 ibdata 文件还是存在，独立表空间文件只存储该表的数据，索引和插入缓冲的BITMAP等信息，其它信息还是存放在共享表空间中。<br></code></pre></td></tr></table></figure><h4 id="表结构与数据存储的分离"><a href="#表结构与数据存储的分离" class="headerlink" title="表结构与数据存储的分离"></a>表结构与数据存储的分离</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">表结构存储：<br>   在 MySQL 数据库中，对于使用 InnoDB 引擎的表，其表结构文件是以.frm为后缀的，并且单独存放在以数据库名命名的文件夹中。比如有一个数据库叫mydb，里面有一张表mytable，那么mytable的表结构文件mytable.frm就会存放在mydb这个文件夹下。这种存储方式使得表结构的管理和维护相对独立，便于数据库系统快速定位和读取表的定义信息，比如表的列结构、索引结构等。<br>数据存储：<br>   所有 InnoDB 引擎表的数据并没有跟随各自的表结构文件分散存储，而是集中存放在ibdata1、ibdata2等这样的文件中。这意味着不同表的数据在物理存储上是聚合在一起的，形成了一个共享的空间来存储所有相关表的数据。<br></code></pre></td></tr></table></figure><h4 id="InnoDB-存储引擎中的-MVCC"><a href="#InnoDB-存储引擎中的-MVCC" class="headerlink" title="InnoDB 存储引擎中的 MVCC"></a><strong>InnoDB</strong> <strong>存储引擎中的</strong> <strong>MVCC</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MVCC（Multi<span class="hljs-literal">-Version</span> Concurrency Control）：多版本并发控制<br>MVCC 是一种实现并发控制的方法，一般用在数据库管理系统中，实现对数据库的并发访问。<br>    MVCC 使得大部份支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，而是把数据库的行锁与数据版本结合起来，只需要很小的开销，就可以实现非锁定读，从而大大提高了数据库系统的并发性能。<br></code></pre></td></tr></table></figure><h5 id="InnoDB-中的-MVCC"><a href="#InnoDB-中的-MVCC" class="headerlink" title="InnoDB 中的 MVCC"></a>InnoDB 中的 MVCC</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">在MySQL中，使用 InnoDB 存储引擎的表，在创建时，系统会自动给表加上两个版本控制字段，这是两个隐藏列，这两个字段不显示在表结构中。<br>其中一个字段保存了行的创建时间，一个保存了行的过期时间（或删除时间），（实际上存储的并不是时间，而是版本号，为了方便理解，我们认为记录的是时间）。<br>当客户端要执行SQL语句时，会根据当前的时间与数据表中记录的时间进行比较，确保不会让客户端得到非法数据。<br></code></pre></td></tr></table></figure><h2 id="数据库服务配置"><a href="#数据库服务配置" class="headerlink" title="数据库服务配置"></a>数据库服务配置</h2><h3 id="数据库基本信息"><a href="#数据库基本信息" class="headerlink" title="数据库基本信息"></a>数据库基本信息</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mysql 数据库<br>类似于Sql Server中的master库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。<br><br>information_schema 数据库<br><br>performance_schema 数据库<br>主要用于收集数据库服务器性能参数，库里表的存储引擎均为PERFORMANCE_SCHEMA，用户不能创建存储引擎为 PERFORMANCE_SCHEMA 的表<br></code></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="1-服务器系统变量"><a href="#1-服务器系统变量" class="headerlink" title="1 服务器系统变量"></a><strong>1</strong> <strong>服务器系统变量</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">服务器系统变量分为全局变量和会话变量两种，全局变量表示可以影响到所有连接终端，所有会话，会话变量只影响当前会话。<br><br>全局变量在MySQL服务器启动时被初始化，并且对所有会话都有效。全局变量的值可以被所有会话共享，并且可以通过<span class="hljs-built_in">SET</span> GLOBAL语句进行修改（需要适当的权限）。一些全局变量定义了服务器的属性、特征，例如max_connections用于限制服务器的最大连接数。<br><br>会话变量是特定于当前会话（连接）的变量。每个会话都有自己的一组会话变量，这些变量的值在会话期间是有效的，并且对其他会话是不可见的。会话变量可以通过<span class="hljs-built_in">SET</span> SESSION语句或<span class="hljs-built_in">SET</span>（不带GLOBAL或SESSION关键字，默认为会话级别）语句进行修改。一些会话变量可以复制全局变量的值作为其初始值，但之后可以在会话中独立修改。<br><br>全局变量：数量相对较少，因为它们定义了服务器的整体行为和属性。<br>会话变量：数量可能更多，因为每个会话都可以有自己的会话变量集合，并且这些变量可以在会话期间被动态创建和修改。<br></code></pre></td></tr></table></figure><h4 id="查看变量"><a href="#查看变量" class="headerlink" title="查看变量"></a>查看变量</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">查看全局所有变量<br>show global status\G<br><br>查看指定变量<br>show status like <span class="hljs-string">&#x27;Com_select&#x27;</span>;<br><br>查看全局变量<br>show global status like <span class="hljs-string">&#x27;Com_select&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="会话变量修改"><a href="#会话变量修改" class="headerlink" title="会话变量修改"></a><strong>会话变量修改</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">修改会话变量：仅对当前会话有影响<br><span class="hljs-built_in">SET</span> [<span class="hljs-type">SESSION</span>] system_var_name=value;<br><span class="hljs-built_in">SET</span> <span class="hljs-selector-tag">@</span><span class="hljs-selector-tag">@</span>[<span class="hljs-type">session.</span>]system_var_name=value;<br><br>只读变量无法修改<br>变量无法实现永久保存，重启服务后会被重置<br></code></pre></td></tr></table></figure><h3 id="服务器状态变量"><a href="#服务器状态变量" class="headerlink" title="服务器状态变量"></a>服务器状态变量</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">服务器状态变量：分全局和会话两种，其中许多变量有双重域，既是全局变量，也是会话变量，有相同的名字<br>状态变量用于保存 MySQL 运行中的统计数据的变量，只读，不可修改。<br></code></pre></td></tr></table></figure><h4 id="服务器变量-sql-mode"><a href="#服务器变量-sql-mode" class="headerlink" title="服务器变量 sql_mode"></a><strong>服务器变量</strong> <strong>sql_mode</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sql_mode 是服务器选项，也是变量，其值会影响 SQL 语句执行的工作模式。<br><br>服务器变量 sql_mode 是 MySQL 数据库中的一个重要系统变量，它用于控制 MySQL 如何处理 SQL 语句和数据校验。sql_mode 可以看作是一组约束和规范，用于确保数据的准确性、完整性和一致性。<br>通过设置不同的 sql_mode 选项，可以改变 MySQL 的执行和处理方式，以适应不同的需求或标准。<br><br>作用<br>控制数据的插入、更新和删除操作，确保数据符合表的定义。<br>对插入数据进行校验，如日期格式、数据类型长度等。<br>改变 MySQL 对于字符串和数字之间的隐式转换规则。<br>使 MySQL 的语法更加严格，符合 ANSI SQL 标准。<br>提高 MySQL 的安全性，避免一些潜在的安全漏洞。<br><br></code></pre></td></tr></table></figure><h2 id="INDEX-索引"><a href="#INDEX-索引" class="headerlink" title="INDEX 索引"></a><strong>INDEX</strong> <strong>索引</strong></h2><h3 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">索引是 帮助 MySQL高效获取数据的 数据结构<br>MySQL索引是一种特殊的数据库结构，由数据库表中一列或多列组合而成，主要用于加快数据的查询和检索速度。它类似于书籍的目录或字典的音序表，可以帮助数据库系统快速定位和获取所需的数据，从而提高查询性能。<br><br>优点<br>- 大大加快数据的检索速度;<br>- 创建唯一性索引，保证数据库表中每一行数据的唯一性;<br>- 加速表和表之间的连接;<br>- 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。<br><br>缺点<br>- 索引需要占物理空间。<br>- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度<br><br></code></pre></td></tr></table></figure><h4 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a><strong>索引数据结构</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL索引的算法和结构主要取决于存储引擎。对于InnoDB存储引擎，最常用的索引结构是B+树索引。<br>B+树索引具有以下特点：<br>    所有数据都会出现在叶子节点：叶子节点形成一个单向链表，便于范围搜索和排序。<br>    非叶子节点仅起到索引数据作用：不存储实际数据，只存储索引，使得树的层级更低，性能更高。<br><br>索引结构-树<br>树的分类<br>- 无序树：树中任意节点的子结点之间没有顺序关系<br>- 有序树：树中任意节点的子结点之间有顺序关系<br><br>- 二叉树：每个节点最多含有两个子树的树称为二叉树<br>- 二叉查找树：<br> 首先它是一颗二叉树，<br> - 若左子树不空，则左子树上所有结点的值均小于它的根结点的值，<br> - 若右子树不空，则右子树上所有结点的值均大于它的根结点的值，<br> - 左、右子树也分别为二叉排序树<br>- 满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树<br>- 完全二叉树：如果一颗二叉树除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布<br>- 霍夫曼树：带权路径最短的二叉树<br>- 红黑树：<br> 红黑树是一颗特殊的二叉查找树，<br> - 每个节点都是黑色或者红色，根节点、叶子节点是黑色。<br> - 如果一个节点是红色的，则它的子节点必须是黑色的<br>- 平衡二叉树(AVL)：一 棵空树或它的左右两个子树的高度差的绝对值不超过<span class="hljs-number">1</span>，并且左右两个子树都是一棵平衡二叉树<br></code></pre></td></tr></table></figure><h4 id="B-树"><a href="#B-树" class="headerlink" title="**B-**树"></a>**B-**树</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">B-树，读作B树，中间的横线是连字符，不是减号，B树将一个节点的大小设置为每个数据页(Page，也可以称为块，block)的大小，一般是<span class="hljs-number">16</span>KB，并且，B树中是将数据和索引放在一起的，以减少IO次数，加快查询速度，一个节点能放多少数据，通常取决于一条数据占用的空间大小。<br></code></pre></td></tr></table></figure><h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="**B+**树索引"></a>**B+**树索引</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">B+树是B-树的变体，也是一棵多路搜索树，MySQL普遍使用B+树来实现索引。<br><br>B+树和B-树的主要区别：<br>B-树内部节点是保存数据的，而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。<br>B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。<br>查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束<br>B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。<br></code></pre></td></tr></table></figure><h4 id="B-树和B-树的主要区别"><a href="#B-树和B-树的主要区别" class="headerlink" title="B+树和B-树的主要区别"></a>B+树和B-树的主要区别</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">B-树内部节点是保存数据的，而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保<br>存数据。<br>B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。<br>查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束<br>B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。<br></code></pre></td></tr></table></figure><h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a><strong>查看索引</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SHOW INDEX FROM [<span class="hljs-type">db_name.</span>]tbl_name;<br></code></pre></td></tr></table></figure><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">CREATE [<span class="hljs-type">UNIQUE</span>] INDEX index_name ON tbl_name (index_col_name[(<span class="hljs-type">length</span>)],...);<br>ALTER TABLE tbl_name ADD INDEX index_name(index_col_name[(<span class="hljs-type">length</span>)]);<br><br>语法示例：<br> CREATE INDEX idx_name ON student(name); <br> 创建一个索引，该索引包含 name 列的完整值。<br> 这意味着，无论 name 列中的字符串有多长，整个字符串都会被包含在索引中。<br> <br> CREATE INDEX idx_name ON student(name(<span class="hljs-number">10</span>)); <br> 创建一个前缀索引，该索引仅包含 name 列的前 <span class="hljs-number">10</span> 个字符。<br> 这意味着，索引是基于 name 列值的前 <span class="hljs-number">10</span> 个字符创建的<br></code></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">DROP INDEX index_name ON tbl_name;<br>ALTER TABLE tbl_name DROP INDEX index_name(index_col_name);<br></code></pre></td></tr></table></figure><h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">所谓并发控制：是指多个进程同时读写一条数据的时候数据库对此情况的处理方式。<br><br>锁机制<br>读锁   共享锁，也称为 S 锁，只读不可写（包括当前事务），多个读互不阻塞<br>写锁   独占锁，排它锁，也称为 X 锁，写锁会阻塞其它事务（不包括当前事务）的读和写<br><br></code></pre></td></tr></table></figure><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">锁是加在索引上的,不是加在数据上的.<br><br></code></pre></td></tr></table></figure><table><thead><tr><th>类别</th><th>详情</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>存储引擎</td><td>锁粒度</td><td>锁的实现</td><td>锁类型</td><td>说明</td></tr><tr><td>MyISAM</td><td>表级锁</td><td>存储引擎自行实现该引擎的锁策略和锁粒度</td><td>隐式锁</td><td>由存储引擎自动施加锁</td></tr><tr><td>MyISAM</td><td>表级锁</td><td>自行实现（在程序中或命令行下用命令显式实现）</td><td>显式锁</td><td>用户手动请求</td></tr><tr><td>InnoDB</td><td>行级锁</td><td>存储引擎自行实现该引擎的锁策略和锁粒度</td><td>隐式锁</td><td>由存储引擎自动施加锁</td></tr><tr><td>InnoDB</td><td>行级锁</td><td>自行实现（在程序中或命令行下用命令显式实现）</td><td>显式锁</td><td>用户手动请求</td></tr></tbody></table><h4 id="锁命令"><a href="#锁命令" class="headerlink" title="锁命令"></a>锁命令</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs powershell">加读锁<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; lock tables student read;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.000</span> sec)<br><br>释放读锁<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; unlock tables;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.001</span> sec)<br><br>加写锁<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; lock table student <span class="hljs-built_in">write</span>;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.000</span> sec)<br><br>释放写锁<br>连接或进程只能释放其自身施加的锁。一个session只能为自己获取锁和释放锁，不能为其他session获取锁，也不能释放由其他session保持的锁。<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; unlock tables ;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.000</span> sec)<br><br><br></code></pre></td></tr></table></figure><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">关闭正在打开的表（清除查询缓存），通常在备份前加全局读锁<br>FLUSH TABLES [<span class="hljs-type">tb_name</span>[,<span class="hljs-type">...</span>]] [<span class="hljs-type">WITH</span> <span class="hljs-type">READ</span> <span class="hljs-type">LOCK</span>]<br><br>关闭所有打开的表，强制关闭所有正在使用的表，并刷新查询缓存和预准备语句缓存，不会刷新脏块<br>FLUSH TABLES<br><br>关闭所有打开的表并使用全局读锁锁定所有数据库的所有表，不会刷新脏块,也不阻塞日志表写入，例如查询日志，慢日志等<br>FLUSH TABLES WITH READ LOCK<br><br>操作指定表<br>FLUSH TABLES tbl_name tb_name[,<span class="hljs-type">...</span>] WITH READ LOCK<br><br>刷新脏块, 脏块也称为脏页，当内存数据页和磁盘数据页上的内容不一致时，我们称这个内存页为脏页<br>FLUSH TABLES tbl_name [<span class="hljs-type">tb_name</span>[,<span class="hljs-type">...</span>]] <span class="hljs-keyword">FOR</span> EXPORT<br></code></pre></td></tr></table></figure><h4 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">事务<br>事务是一组具有原子性的 SQL 语句，或者说一个独立单元。可以理解为一个事务对应的是一组完整的业务，这个业务有一条或多条 SQL 语句组成。所谓原子性是指，这一组业务中的 SQL 语句不可分割，所以，要么全部 SQL 语句都执行成功，事务也就执行成功；只要有一条 SQL 语句执行失败，则整个事务都要回滚到事务开始前。<br><br>事务特性<br>原子性( Atomicity )<br>  原子性又称不可分割性。一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br><br>一致性( Consistency )<br>   事务的执行结果，必须是符合预期的，这表示在事务中进行的数据读写，完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。<br><br>隔离性( Isolation )<br>  隔离性又称独立性。MySQL 允许多个事务并发，同时进行写操作，隔离性用于实现事务的并发控制，防止多个事务并发执行时的交叉执行而导致的数据不一致。<br>  事务的隔离分为不同的级别，包括读未提交( Read uncommitted )，读提交( read committed )，可重复读( repeatable read )，串行化( Serializable )。<br>  <br>持久性( Durability )<br>事务执行成功后，其对于数据的修改会永久保存于数据库中。<br><br></code></pre></td></tr></table></figure><h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">显式启动事务 语法解读<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">BEGIN</span> WORK<br><span class="hljs-built_in">START</span> TRANSACTION<br><br>结束事务<br><span class="hljs-comment">#提交执行</span><br>COMMIT<br><span class="hljs-comment">#回滚</span><br>ROLLBACK<br></code></pre></td></tr></table></figure><h4 id="自动提交能力"><a href="#自动提交能力" class="headerlink" title="自动提交能力"></a><strong>自动提交能力</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell">对于mysql来说，每一个对于数据的增删改的动作，都是一个事务，为什么我们操作过数据之后，另外的终端可以立刻生效呢？<br>原因是，mysql对于这种操作，启用了 自动提交的能力。<br><br>默认开始自动提交<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; <span class="hljs-built_in">select</span> <span class="hljs-selector-tag">@</span>@autocommit;<br>+<span class="hljs-literal">--------------</span>+<br>| <span class="hljs-selector-tag">@</span>@autocommit |<br>+<span class="hljs-literal">--------------</span>+<br>|            <span class="hljs-number">1</span> |<br>+<span class="hljs-literal">--------------</span>+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br>关闭自动提交<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; <span class="hljs-built_in">set</span> autocommit=<span class="hljs-number">0</span>;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.000</span> sec)<br><br>MariaDB [<span class="hljs-type">testdb</span>]&gt; <span class="hljs-built_in">select</span> <span class="hljs-selector-tag">@</span>@autocommit;<br>+<span class="hljs-literal">--------------</span>+<br>| <span class="hljs-selector-tag">@</span>@autocommit |<br>+<span class="hljs-literal">--------------</span>+<br>|            <span class="hljs-number">0</span> |<br>+<span class="hljs-literal">--------------</span>+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br></code></pre></td></tr></table></figure><h4 id="查看事务"><a href="#查看事务" class="headerlink" title="查看事务"></a>查看事务</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#查看当前正在进行的事务</span><br><span class="hljs-built_in">SELECT</span> * FROM INFORMATION_SCHEMA.INNODB_TRX;<br></code></pre></td></tr></table></figure><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell">死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等的进程称为死锁进程。<br><br>死锁语法解析<br>查看innodb状态，可以查看锁信息<br>show engine innodb status;<br>查看正在进行中的事务<br><span class="hljs-built_in">SELECT</span> * FROM information_schema.INNODB_TRX;<br>查看锁<br><span class="hljs-built_in">SELECT</span> * FROM information_schema.INNODB_LOCKS;<br>MySQL8.<span class="hljs-number">0.13</span> 及以后使用此语句查看锁<br><span class="hljs-built_in">SELECT</span> * FROM performance_schema.data_locks;<br>查看锁等待<br><span class="hljs-built_in">SELECT</span> * FROM information_schema.INNODB_LOCK_WAITS;<br>MySQL8.<span class="hljs-number">0.13</span>及以后使用此语句查看锁等待<br><span class="hljs-built_in">SELECT</span> * FROM performance_schema.data_lock_waits;<br></code></pre></td></tr></table></figure><h4 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL 的事务隔离级别一共有四个，分别是 读未提交、读已提交、可重复读 以及 可串行化。MySQL 的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。<br><br>读未提交（READ UNCOMMITTED）<br>  在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。可能发生 脏读、不可重复读和 幻读问题，一般很少使用此隔离级别。<br>  简单来说：你没有提交的时候，我就看到你修改的数据<br><br>读已提交（READ COMMITTED）<br>  在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。<br>  简单来说：你提交后，我才可以看到你修改的数据。<br><br>可重复读（REPEATABLE READ）<br>  在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。<br>  简单来说，你提交了，我也提交了，我才有能力读自己的数据。<br><br>可串行化（SERIALIZABLE）<br>  可串行化，又称序列化。各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。<br>  简单来说；咱们俩，谁先开始【另外一个人处于等待状态】，谁后开始的问题。<br>  <br>以上四种隔离级别，从上往下，隔离强度逐渐增强，性能逐渐变差，需要消耗的 MySQL 的资源越多，<br>所以并不是隔离强度越高越好，采用哪种隔离级别要根据系统需求权衡决定，MySQL 中默认的隔离级<br>别是可重复读。<br></code></pre></td></tr></table></figure><h4 id="事务并发中可能出现的问题"><a href="#事务并发中可能出现的问题" class="headerlink" title="事务并发中可能出现的问题"></a><strong>事务并发中可能出现的问题</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">脏读（Dirty Read） - 只在 读未提交 隔离级别才会出现<br>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并不一定最终存在的数据，这就是脏读。<br><br>不可重复读（Non<span class="hljs-literal">-Repeatable</span> Read） - 在 读未提交 和 读已提交 隔离级别都可能会出现<br>不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。<br><br>幻读（Phantom）-在 读未提交、读已提交、可重复读 隔离级别都可能会出现<br>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。<br></code></pre></td></tr></table></figure><h4 id="MVCC和事务的隔离级别"><a href="#MVCC和事务的隔离级别" class="headerlink" title="MVCC和事务的隔离级别"></a><strong>MVCC</strong>和事务的隔离级别</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MVCC（多版本并发控制机制）只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。<br><br></code></pre></td></tr></table></figure><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><h4 id="MySQL的日志类型"><a href="#MySQL的日志类型" class="headerlink" title="MySQL的日志类型"></a><strong>MySQL</strong>的日志类型</h4><p>MySQL 支持丰富的日志类型，主要有以下六种：</p><table><thead><tr><th>日志类型</th><th>说明</th></tr></thead><tbody><tr><td>事务日志</td><td>记录 InnoDB 等支持事务的存储引擎执行事务时产生的日志，其写入类型为顺序 IO</td></tr><tr><td>错误日志</td><td>记录 MySQL 服务的启动、运行或停止 MySQL 服务时出现的问题，通常也会记录 Warning</td></tr><tr><td>通用日志</td><td>又称查询日志，记录建立的客户端连接和执行的语句</td></tr><tr><td>慢查询日志</td><td>记录所有执行时间超过 long_query_time 的所有查询或不使用索引的查询，有助于定位性能问题</td></tr><tr><td>二进制日志</td><td>记录所有更改数据的语句，主要用于复制和即时点恢复</td></tr><tr><td>中继日志</td><td>从主服务器的二进制日志文件中复制而来的事件，并保存为的日志文件，与二进制日志几乎相同</td></tr></tbody></table><h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Mariadb 查看日志信息<br><span class="hljs-comment">#MariaDB中的相关变量</span><br>MariaDB [<span class="hljs-type">testdb</span>]&gt; show variables like <span class="hljs-string">&#x27;%innodb_log%&#x27;</span>;<br>+<span class="hljs-literal">-----------------------------</span>+<span class="hljs-literal">-----------</span>+<br>| Variable_name               | Value     |<br>+<span class="hljs-literal">-----------------------------</span>+<span class="hljs-literal">-----------</span>+<br>| innodb_log_buffer_size      | <span class="hljs-number">16777216</span>  |<br>| innodb_log_checksums        | ON        |<br>| innodb_log_compressed_pages | ON        |<br>| innodb_log_file_size        | <span class="hljs-number">100663296</span> |<br>| innodb_log_files_in_group   | <span class="hljs-number">1</span>         |<br>| innodb_log_group_home_dir   | ./        |<br>| innodb_log_optimize_ddl     | OFF       |<br>| innodb_log_write_ahead_size | <span class="hljs-number">8192</span>      |<br>+<span class="hljs-literal">-----------------------------</span>+<span class="hljs-literal">-----------</span>+<br><span class="hljs-number">8</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br>确认日志所处的位置<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; show variables like <span class="hljs-string">&#x27;%datadir%&#x27;</span>;<br>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">-------------------</span>+<br>| Variable_name | Value             |<br>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">-------------------</span>+<br>| datadir       | /mysql/<span class="hljs-number">3306</span>/<span class="hljs-keyword">data</span>/ |<br>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">-------------------</span>+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br></code></pre></td></tr></table></figure><h4 id="事务日志性能优化"><a href="#事务日志性能优化" class="headerlink" title="事务日志性能优化"></a>事务日志性能优化</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">redo log 包含日志缓冲（redo log buffer）和磁盘上的日志文件（redo logfile）两部分。<br>MySQL 每执行新一条 DML 语句都会先将日志记录在 redo log buffer 中，然后再根据不同的配置项，使用不同的规则将 redo log buffer 中的数据落盘（写入到 redo log file）。<br>但是，redo log buffer 是用户空间的数据，无法直接写入磁盘，中间必须经过操作系统缓冲区（OS Buffer），因此，从 redo log buffer 到 redo log file，实际上会先写 OS Buffer，再调用fsync() 将其刷人入到 redo log file 中。<br></code></pre></td></tr></table></figure><h4 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL 中错误日志中记录的主要内容<br>- mysqld 启动和关闭过程中输出的事件信息<br>- mysqld 运行中产生的错误信息<br>- event scheduler 运行一个 event 时产生的日志信息<br>- 在主从复制架构中的从服务器上启动从服务器线程时产生的信息<br></code></pre></td></tr></table></figure><h4 id="通用日志"><a href="#通用日志" class="headerlink" title="通用日志"></a>通用日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">通用日志<br>  通用日志，又称通用查询日志（General Query Log），用来记录对数据库的所有操作，包括启动和关闭 MySQL 服务、更新语句和查询语句等。默认情况下，通用查询日志功能是关闭的。<br>  可以通过配置开启此日志，并决定将日志存储到文件或数据表中。如果选择记录到数据表中，则具体的表是 mysql.general_log<br></code></pre></td></tr></table></figure><h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">  慢查询日志用来记录在 MySQL 中执行时间超过指定时间的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率低，以便进行优化。<br>  慢查询日志默认不开启。<br><br>Mariadb环境查看<br>MariaDB [<span class="hljs-type">mysql</span>]&gt; <span class="hljs-built_in">select</span> <span class="hljs-selector-tag">@</span>@slow_query_log,<span class="hljs-selector-tag">@</span>@slow_query_log_file,<span class="hljs-selector-tag">@</span>@long_query_time;<br>+<span class="hljs-literal">------------------</span>+<span class="hljs-literal">-----------------------</span>+<span class="hljs-literal">-------------------</span>+<br>| <span class="hljs-selector-tag">@</span>@slow_query_log | <span class="hljs-selector-tag">@</span>@slow_query_log_file | <span class="hljs-selector-tag">@</span>@long_query_time |<br>+<span class="hljs-literal">------------------</span>+<span class="hljs-literal">-----------------------</span>+<span class="hljs-literal">-------------------</span>+<br>|                <span class="hljs-number">0</span> | bogon<span class="hljs-literal">-slow</span>.log        |         <span class="hljs-number">10.000000</span> |<br>+<span class="hljs-literal">------------------</span>+<span class="hljs-literal">-----------------------</span>+<span class="hljs-literal">-------------------</span>+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br>开启慢查询日志<br><br></code></pre></td></tr></table></figure><h4 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">   二进制日志（Binary Log）也可叫作变更日志（Update Log），是 MySQL 中非常重要的日志。主要用于记录数据库的变化情况，即 SQL 语句的 DDL 和 DML 语句，但不包含查询操作语句，因为查询语句并不会改变数据库中的数据。<br>   如果 MySQL 数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。<br>   <br>事务日志和二进制区别<br>- 事务日志可以看作是在线日志，二进制日志可以看作是离线日志<br>- 事务日志记录事务执行的过程，包括提交和未提交，二进制日志记录只记提交的过程<br>- 事务日志只支持 InnoDB 存储引擎，二进制支持 InnoDB 和 MyISAM 存储引擎<br>- 事务日志的容量是<span class="hljs-number">100</span>M的大小，会滚动覆盖式更新，二进制的容量大小没有限制。<br><br>二进制日志记录三种格式<br>- Statement：基于语句的记录模式，日志中会记录原生执行的 SQL 语句，对于某些函数或变量，不会替换。<br>- Row：基于行的记录模式，会将 SQL 语句中的变量和函数进行替换后再记录。<br>- Mixed：混合记录模式，在此模式下，MySQL 会根据具体的 SQL 语句来分析采用哪种模式记录日志。<br></code></pre></td></tr></table></figure><h4 id="查看二进制文件"><a href="#查看二进制文件" class="headerlink" title="查看二进制文件"></a>查看二进制文件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MariaDB [<span class="hljs-type">db2</span>]&gt; <span class="hljs-built_in">select</span> <span class="hljs-selector-tag">@</span>@binlog_format;<br>+<span class="hljs-literal">-----------------</span>+<br>| <span class="hljs-selector-tag">@</span>@binlog_format |<br>+<span class="hljs-literal">-----------------</span>+<br>| MIXED           |<br>+<span class="hljs-literal">-----------------</span>+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br>查看当前服务的二进制文件列表<br>SHOW &#123;BINARY | MASTER&#125; LOGS<br>查看正在使用的二进制文件<br>SHOW MASTER STATUS<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux防火墙</title>
    <link href="/2024/06/30/Linux%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <url>/2024/06/30/Linux%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux防火墙"><a href="#Linux防火墙" class="headerlink" title="Linux防火墙"></a>Linux防火墙</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs ada">网络安全技术基础:<br>  IDS：Intrusion Detection Systems （入侵检测系统） <br>    其特点是不阻断任何网络访问，而是依照一定的安全策略，通过软，硬件，对网络，系统的运行状况进行监控，尽可能发现各种攻击企图，攻击行为或攻击结果，以保证网络系统资源的机密性，完整性和可用性。<br>  IPS： Intrusion Prevention System （入侵防御系统）<br>    IPS 以串行的方式接入系统，IPS系统可以深度感知并检测经流的数据报文，可以根据预先设定的安全策<br>略，对流经的每个报文进行深度检测（包括协议分析跟踪、特征匹配、流量统计分析、事件关联分析等），如<br>果发现藏匿于其中的网络攻击，可以根据该攻击的威胁级别立即采取措施，这些措施包括中断连接，丢弃报<br>文，隔离文件，向管理员告警等。  <br>  FW：Firewall防火墙<br>    防火墙系统是在内部网络和外部网络之间，专用网络与公共网络之间，可信网络和不可信网络之间建立屏障。它是一种 <span class="hljs-string">&quot;隔离&quot;</span>  技术，是在两个网络通讯时执行的一种访问控制尺度，它能允许经你 “同意”的个人和数据进入你的网络，同时将你 “不同意” 的个人和数据拒之门外，最大限度的阻止非法的流量和数据进入系统或网络。同时防火墙也可以根据规则禁止本地网络向外发送数据报文，以及根据规则转发网络流量等。  <br>  WW：Waterwall 防水墙<br>    防水墙是一种防止内部信息泄漏的安全产品。它利用透明加解密，身份认证，访问控制和审计跟踪等技术手段，对涉密信息，重要业务数据和技术专利等敏感信息的存储，传播和处理过程，实施安全保护；最大限度地防止敏感信息泄漏、被破坏和违规外传，并完整记录涉及敏感信息的操作日志，以便日后审计。    <br>  网络解决方案的常见样式:<br>    <span class="hljs-number">1</span> 两层防火墙，内层防火墙的限制极高，只能特定网络可以访问。<br>    <span class="hljs-number">2</span> 单层防火墙，一套防火墙三个网卡接口，但是还是有安全隐患。<br>    <span class="hljs-number">3</span> 多层防火墙，在靠近互联网的外部再多来一些防火墙。<br>    <span class="hljs-number">4</span> 禁止网络访问。  <br><br>防火墙的分类:<br>  按照保护范围来划分:<br>    主机防火墙:      <br>      主机防火墙对单个主机进行防护，运行在终端主机上，主机防火墙可以阻止未授权的程序和数据出入计算机，Windows和Linux 系统都有自带的主机防火墙。<br>    网络防火墙:<br>      网络防火墙部署在整个系统的主线网路上，对整个系统的出入数据进行过滤。  <br>  按实现方式划分:<br>    硬件防火墙:<br>      硬件防火墙以独立硬件设备的形式提供服务，独立供电，独立部署，其软件是单独运行在硬件里面的，所有硬件资源都只给防火墙这一个程序使用。而且硬件防火墙，很多都是基于linux内核系统做了二次开发，尤其是针对特定的场景做了相当的优化，所以不论是在功能层面，还是在性能层面都是非常强大的。      <br>    软件防火墙:<br>      防火墙往往以应用程序的形式提供，运行于通用硬件平台，寄生于操作系统中，是通过纯软件的方式提供服务。      <br>  按网络协议划分:<br>    网络层防火墙:<br>      网络层防火墙对流经的数据包中的源地址，目标地址，端口号及协议等内容做出分析，依据事先设定好的过滤规则，对数据包作出不同的处理（包括拒绝，丢弃，放行，转发等）。这些过滤规则，被称为访问控制列表（ACL)。网络层防火墙只能根据数据包头部的协议端口号等进行过滤，无法过滤应用层的具体数据。    <br>    应用层防火墙:<br>      应用层只针对特别的网络应用服务协议来确定数据过滤逻辑。应用层网关防火墙是内部网和外部网的隔离点，它部署在主链路上，将系统分为两部份，起到内外部网络通讯时的中间转接作用。        <br>  按实现细节角度划分:<br>    包过滤防火墙，<br>      根据用户定制的关键字，检查数据包的网络信息，不检查具体数据，应用层控制比较弱。<br>    应用网关防火墙：<br>      根据用户定制的关键字，检查数据包的数据信息，检查IP、TCP报头，网络层控制比较弱。<br>    状态检测防火墙：<br>      基于简单包过滤防火墙，增强数据包的网络状态信息检测，应用层控制比较弱。<br>    复合型防火墙：<br>      综合性的防火墙，可以检查整个数据包内容，具备网络层和应用层控制，兼有会话层控制措施。  <br><br>Linux 防火墙基础知识:<br>  封装数据:<br>    真实应用数据从上层进入到传输层，加上源端口和目标端口成为数据段(TCP|UDP首部)，接着进入网络层，加上源IP和目标IP成为数据包，再进入链路层，加上源MAC地址和目标MAC地址成为数据帧，形成一个完整的数据包。    <br>  解封装数据:<br>    数据经过网络传输到达目标主机后，按照封装的反顺序逐层解包，最终得到真正的应用内容.  <br>  数据包过滤:<br><br>防火墙工具:<br>  iptables:<br>    由软件包iptables提供的命令行工具，工作在用户空间，用来编写规则，写好的规则被送往netfilter，告诉内核如何去处理信息包。iptables的包软件，默认情况下，已经被安装到操作系统里面了，如果我们希望去扩展对应的功能，开发相应的模块即可。          <br>  xtables-nft-multi:(xtables - nft - multi 是一个过渡工具，其目的是为了帮助用户从传统的 iptables 平滑迁移到 nftables 体系)<br>    xtables-nft-multi 是一个用于在 Linux 系统中管理 iptables、arptables 和 ebtables 规则的工具集，它基于 nftables 的后端来实现。nftables 是 Linux 内核中的一个新的防火墙框架，旨在替代旧的 iptables 框架，提供更强大、更灵活和更易于管理的防火墙规则。  <br>  firewalld:<br>    Firewalld是Linux系统中一款用于管理网络防火墙的动态守护程序，并不是做了什么革命性的功能扩展，仅仅是功能的整合而已。Firewalld提供了支持网络区域（zone）定义网络连接以及接口安全等级的动态防火墙管理工具。它允许系统管理员在不需要重启防火墙或停止网络服务的情况下，实时更改防火墙规则。  <br>  nftables:<br>    nft（nftables）是新一代的 Linux 防火墙技术，旨在取代传统的 iptables，它在性能、功能和易用性等方面都有显著的提升。  <br>  ufw:<br>    UFW（Uncomplicated Firewall）是一款基于iptables的主机级防火墙配置工具。UFW是Ubuntu系统上默认的防火墙组件，为了轻量化配置iptables而开发的一款工具。让配置防火墙变得更加简单，同时保持足够的灵活性以满足一般用户和管理员的需求。  <br>    核心原理:<br>      UFW在底层仍然使用iptables，但通过提供更简单的语法和默认配置，使得配置过程更加友好。<br>      iptables是Linux内核中用于配置防火墙规则的工具，通过定义规则集来控制网络数据包的流动。规则集包括允许或拒绝特定源、目标、端口和协议的数据包。<br>      UFW提供了简单的命令行接口，使用户能够轻松地添加、删除和管理这些规则。<br><br>iptables命令格式:<br>  iptables -子命令 &lt;链&gt; &lt;规则策略&gt;         <br>  匹配条件:(当一条 iptables 规则中有多个匹配条件时，默认是 “与” ，即要同时满足。)<br>    普通匹配条件:<br>      基本的匹配条件，就是我们基于man iptables或者 iptables -h方式查看到的options中的匹配样式内容，常见的有 -p,-s,-d,-j,-n等等，这些都是一个防火墙规则最基本最常用的一些匹配条件。    <br>     基本匹配的选项参数<br>     [!] -s|<span class="hljs-comment">--source address[/mask][,...] #匹配源IP地址或网段，多个IP地址使用逗号隔开</span><br>     [!] -d|<span class="hljs-comment">--destination address[/mask][,...] #匹配目标IP地址或网段，多个IP地址使用逗号隔开</span><br>     [!] -p|<span class="hljs-comment">--protocol protocol #匹配具体协议，可以使用协议号或协议名，0代表所有协议</span><br>     [!] -i|<span class="hljs-comment">--in-interface name #匹配报文流入接口，只用于数据流入 #只用于INPUT/FORWARD/PREROUTING链</span><br>     [!] -o|<span class="hljs-comment">--out-interface name #匹配报文流出接口，只用于数据流出#只用于OUTPUT/FORWARD/POSTROUTING链</span><br>     注意：<br>        ! 代表规则取反<br>     基本匹配:<br>网络防火墙:<br>  NAT原理解析;<br>    虚拟机是怎么能够访问互联网的:<br>  NAT：(Network Address Translation) 网络地址转换:<br>    局域网中的主机都是分配的私有IP地址，这些IP地址在互联网上是不可达的，局域网中的主机，在与互联网通讯时，要经过网络地址转换，去到互联网时，变成公网IP地址对外发送数据。服务器返回数据时，也是返回到这个公网地址，再经由网络地址转换返回给局域网中的主机。             <br>    也就是说，局域网中的主机，想要访问互联网，在出口处，应该有一个公网可达的IP地址，应该能将局域网中的IP地址通过NAT转换成公网IP。<br> 数据包出去的时候，做了一次源地址转换，数据包回来的时候，做了一次目标地址转换。<br><br>SNAT 实现源IP地址转换:<br>  SNAT：Source NAT，源地址转换，基于nat表，工作在 POSTROUTING 链上。<br>     具体是指将经过当前主机转发的请求报文的源IP地址转换成根据防火墙规则指定的IP地址。      <br>     配置格式:<br>     iptables -t nat -A POSTROUTING -s LocalNet ! -d LocalNet -j SNAT <span class="hljs-comment">--to-soure       ExtIP [--random]</span><br>      <span class="hljs-comment">--to-source [ipaddr[-ipaddr]][:port[-port]] #转换成指定IP，或指定范围内的IP，端口可选</span><br>      <span class="hljs-comment">--random #端口映射基于hash算法随机化</span><br><br>MASQUERADE 实现源IP地址转换:<br>  如果我们内网的出口设备上有固定IP，则直接指定 <span class="hljs-comment">--to-source IP 没有任何问题，但是如果是使用拨号上网，出口网络设备上的IP地址会发生变化，这种情况下，我们的出口IP不能写成固定的。</span><br>  我们需要使用 MASQUERADE 进行地址转换，MASOUERADE 可以从主机网卡上自动获取IP地址当作出口IP地址。  <br>  配置格式:<br>    iptables -t nat -A POSTROUTING -s LocalNET ! -d LocalNet -j MASQUERADE [<span class="hljs-comment">--to-ports port[-port]] [--random]</span><br>    <span class="hljs-comment">--to-ports port[-port] #指定端口</span><br>    <span class="hljs-comment">--random #端口映射基于hash算法随机化  </span><br><br>DNAT实现目标IP地址转换:<br>  在内网环境中，使用私有IP地址的设备要与互联网进行通讯时，需要借助出口设备将原内网IP地址转换成公网可达的IP地址再进行通讯。  <br>  在内网环境中，只有在出口设备上才有一个(或数个)公网可达的IP，所以在互联网上，是不能路由至内网主机的。如果要让内网主机上的服务在公网上可见，我们需要使用 DNAT 实现目标IP地址转换。  <br>  DNAT：Destination NAT，目标地址转换，基于nat表，工作在 PREROUTING 链上。<br>  配置格式:<br>    iptables -t nat -A PREROUTING -d ExtIP -p tcp|udp|icmp <span class="hljs-comment">--dport PORT -j DNAT --todestination InterSeverIP[:PORT]</span><br>    -d ExtIP #指公网可达的IP地址，必须是固定IP<br>    <span class="hljs-comment">--to-destination [ipaddr[-ipaddr]][:port[-port]] #转换成指定IP，或指定范围内的IP，端口可选 </span><br>    DNAT 只能将一条请求规则重定向到一台后端主机，无法实现负载均衡功能。如果后端主机存在多个端口服务的话，那么就需要多来一条规则。 <br>  总结:<br>    <span class="hljs-number">1</span> DNAT 只能将一条请求规则重定向到一台后端主机，无法实现负载均衡功能。<br>    <span class="hljs-number">2</span> 防火墙主机上看不到<span class="hljs-number">80</span>和<span class="hljs-number">8080</span>的端口监听，防火墙是在内核中实现的,无法通过 netstat 或 ss 来查看  <br><br>REDIRECT 实现本机端口转换:<br>  REDIRECT:重定向，通过定义规则，将收到的数据包转发至同一主机的不同端口。<br>  REDIRECT:功能无需开启内核 ip_forward 转发。  <br>  配置格式:<br>    iptables -t nat -A PREROUTING -d ExtIP -p tcp|udp <span class="hljs-comment">--dport PORT -j REDIRECT --to-ports PORT</span><br>   <span class="hljs-comment">--to-ports #新的端口  </span><br><br>FORWARD转发:<br> iptables是Linux系统内嵌的防火墙，由规则、链和表组成，用于管理和过滤网络数据包。其中，FORWARD链是iptables中定义的一个重要部分，它专门处理经过本机路由转发到其他主机的数据包。 <br>  FORWARD作用:<br>    当数据包通过路由表后，如果目的地不是本机，而是需要转发到其他主机，那么这些数据包就会经过FORWARD链。<br>在FORWARD链中，可以定义一系列规则来决定这些数据包是否应该被放行、拒绝或丢弃。  <br>应用场景:<br>  路由器或网关设备：<br>   在这些设备上，经常需要配置FORWARD链的规则来转发不同网络之间的数据包。<br>   例如，可以将来自内部网络的数据包转发到外部网络，或将来自外部网络的数据包转发到内部网络的特定主机。<br> <br>防火墙：<br> 在某些情况下，防火墙需要配置FORWARD链的规则来允许或拒绝经过本机的数据包。<br> 例如，可以配置规则来允许特定的IP地址或端口范围的数据包通过防火墙，或拒绝来自不受信任网络的数据包。  <br><br>iptables 中的自定义链;<br>  iptables 中除了系统自带的五个链之外，还可以自定义链，来实现将规则进行分组，重复调用的目的。<br>  自定义链添加规则之后，要作为系统链的 target 与之关联，才能起到作用。  <br><br>firewalld:<br>  firewalld 是 CentOS <span class="hljs-number">7.0</span> 新推出的管理 netfilter 的用户空间软件工具，也被 ubuntu18.<span class="hljs-number">04</span>版以上所支持 (apt install firewalld)。但是ubuntu有自己的服务 ufw.service<br> firewalld 是配置和监控防火墙规则的系统守护进程，可以实现 iptables，ip6tables，ebtables 的功能。firewalld 服务由 firewalld 包提供。  <br>  firewalld 中有多个系统自带的 Zone，每个zone都对应不同的防火墙规则，使用不同的 Zone，就表示使用不同的防火墙规则，每个Zone的具体规则可以进行修改，也可以自定义Zone。<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/Linux%E9%98%B2%E7%81%AB%E5%A2%99/image_PBS1KrdMDH.png"></p><p>!!!!<img src="/../image/Linux%E9%98%B2%E7%81%AB%E5%A2%99/image_9-64pt_QHf.png"></p><p>!!!!<img src="/../image/Linux%E9%98%B2%E7%81%AB%E5%A2%99/image_iswZ5y8J-J.png"></p><p>!!!!<img src="/../image/Linux%E9%98%B2%E7%81%AB%E5%A2%99/image_QaQdjqmlVk.png"></p><p>!!!!<img src="/../image/Linux%E9%98%B2%E7%81%AB%E5%A2%99/image_7ZPwq0JYIC.png"></p><p>!!!!<img src="/../image/Linux%E9%98%B2%E7%81%AB%E5%A2%99/image__gGZG8m416.png"></p><p>!!!!<img src="/../image/Linux%E9%98%B2%E7%81%AB%E5%A2%99/image_LIMO2IhCBq.png"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议和Apache服务</title>
    <link href="/2024/05/04/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CApache%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/05/04/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CApache%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP协议和Apache服务"><a href="#HTTP协议和Apache服务" class="headerlink" title="HTTP协议和Apache服务"></a>HTTP协议和Apache服务</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs ada">WEB 协议<br> Internet 因特网 | WWW 万维网 <br>HTTP 协议 <br>  核心特点：   <br>    请求-响应模型：客户端发送一个请求到服务器，服务器接收请求后返回一个响应。<br>    无状态协议：服务器不会保留任何关于之前客户端请求的信息。每个请求都是独立的。<br>    资源标识符：HTTP使用统一资源标识符（URI）来定位互联网上的资源。<br>    方法（动作）：HTTP定义了几种请求方法，对互联网的资源进行各种操作。<br>    状态码：服务器在响应中包含一个状态码，用于指示请求是否成功，以及请求失败的原因。<br>    消息头：HTTP请求和响应都包含头部字段，用于传递额外的信息<br>资源: (URL)<br>  第<span class="hljs-number">1</span>部分:(协议部分)http://  https://   <br>  第<span class="hljs-number">2</span>部分:(地址部分)域名  <br>  第<span class="hljs-number">3</span>部分:(文件部分) <br>  第<span class="hljs-number">4</span>部分:(选项参数部分) <br>URI&amp; URL<br>  URI:统一资源标识符，是一个用来唯一标识互联网上某一特定资源的字符串<br>  URL:统一资源定位符   <br>协议:<br>http/<span class="hljs-number">0.9</span> http/<span class="hljs-number">1.0</span> http/<span class="hljs-number">1.1</span> http/<span class="hljs-number">2</span> http/<span class="hljs-number">3</span>  <br>web技术:<br>  web前端页面:<br>  前端页面技术：HTML + CSS + JAVASCRIPT      <br> <br>静态资源和动态资源:<br>  动静资源的区别:<br>    客户端通过 URI 锚定服务端的一个唯一资源，WEB SERVER 服务将该资源返回给客户端，资源可以分为静态资源和动态资源两类，在 Web 服务中，静态资源和动态资源是根据其内容和 <span class="hljs-string">&quot;生成方式&quot;</span> 来定义的，它们在处理和提供方式上有一些显著的区别。<br>    在实际的 Web 应用中，通常会同时使用静态资源和动态资源，以充分利用它们各自的优势，例如，静态资源可以用于提供页面的基本框架、样式和脚本，而动态资源可以用于提供个性化的、与用户交互的内容。  <br>     <br>http的工作机制:<br>  浏览器访问网站的过程:<br>    <span class="hljs-number">1</span>. 在浏览器地址栏中输入网址<br>    <span class="hljs-number">2</span>. DNS 服务解析域名，客户端获得服务器 IP 地址<br>    <span class="hljs-number">3</span>. 浏览器用 TCP 的三次握手与服务器建立连接<br>    <span class="hljs-number">4</span>. 浏览器向服务器发送拼好的报文<br>    <span class="hljs-number">5</span>. 服务器收到报文后处理请求，同样拼好报文再发给浏览器<br>    <span class="hljs-number">6</span>. 浏览器解析报文，渲染输出页面     <br>  http的工作机制:<br>    HTTP 是一种允许浏览器向服务器获取资源的协议，是 WEB 的基础，通常由浏览器发起请求，用来获取不同类型的资源，比如 HTML 文件，CSS 文件，Javascript 文件，图片，视频，压缩包等。<br>    一次完整的 HTTP 事务包括 客户端发起 HTTP 请求，服务端响应请求两部份组成。一个页面通常有多个资源组成，浏览器打开一个页面，通常要发起多次请求，分别加载不同的资源。    <br>    步骤:<br>      <span class="hljs-number">1</span> 建立连接<br>        客户端（通常是浏览器）通过TCP/IP协议与服务器建立连接。这是HTTP通信的基础，确保数据能够在客户端和服务器之间可靠地传输。  <br>      <span class="hljs-number">2</span>. 发送请求<br>        一旦连接建立，客户端会向服务器发送一个HTTP请求。这个请求由多个部分组成，包括：<br>          请求行：包含<br>            请求方法（如GET、POST等）、<br>            请求URI（统一资源标识符，指定了要访问的资源的位置）<br>            HTTP版本号（表示请求所使用的HTTP协议版本）等。<br>          头部字段：使用key-value形式传递一些请求信息，如<br>            <span class="hljs-keyword">Accept</span>（客户端可以接受的响应内容类型）、<br>            User-Agent（客户端的浏览器信息）、<br>            Referer（客户端从哪个页面跳转而来）等。<br>          正文：可选部分，用于向服务器传递一些数据。例如，<br>            当客户端向服务器提交表单时，表单数据就可以放在请求的正文中。<br>      <span class="hljs-number">3</span>. 处理请求<br>        服务器接收到客户端的请求后，会解析请求行和头部字段，查找所请求的资源，并准备相应的响应。<br>      <span class="hljs-number">4</span>. 发送响应<br>        服务器将处理后的响应发送回客户端。响应也由多个部分组成，包括：<br>          状态行：包含HTTP版本号、状态码和状态短语。<br>          状态码是一个三位数字，用于表示服务器对请求的处理结果<br>           （如<span class="hljs-number">200</span>表示成功，<span class="hljs-number">404</span>表示未找到资源，<span class="hljs-number">500</span>表示服务器内部错误等）。<br>          状态短语是对状态码的简短描述。<br>         头部字段：使用key-value形式传递一些响应信息，如<br>           Content-<span class="hljs-keyword">Type</span>（响应内容的类型）、<br>           Content-Length（响应内容的长度）、<br>           Set-Cookie（服务器要求客户端保存一个Cookie等）。<br>         正文：响应的实际内容。<br>           例如，当客户端请求一个网页时，网页的HTML代码就可以放在响应的正文中。 <br>       <span class="hljs-number">5</span>. 关闭连接<br>         连接在请求和响应之后通常会被关闭，以释放系统资源。然而，在HTTP/<span class="hljs-number">1.1</span>中引入了持久连接（也称为连接重用），允许在同一个TCP连接上发送和接收多个HTTP请求和响应，从而提高了网络传输的效率。<br>  为了解决HTTP的无状态问题，引入了Cookie和Session机制<br>   如果客户端需要在多次请求之间保持状态，通常会使用一些机制，如Cookie或Session。<br>   Cookies 和 Sessions 都是用于在Web应用程序中管理用户状态的机制，它们的作用主要涉及用户身<br>份验证、跟踪会话信息以及存储用户偏好等方面。<br><br>Cookie和Session:<br>  Cookie:<br>    一种在客户端保存状态信息的机制。服务器可以通过Set-Cookie头部向客户端发送一个Cookie，客户端在下一次请求时将该Cookie发送回服务器。<br>    服务器可以根据Cookie的内容来识别客户端的身份，从而实现状态管理。   <br> <br>消息通信:<br>  同步和异步 - 消息的通信机制  <br>    同步和异步关注的是消息的通信机制，即调用者在等待一件事情的处理结果时，被调用者是否提供完成状态的通知<br>    - 同步：sychronous，<br>      被调用者并不提供事件的处理结果相关的通知消息，需要调用者主动询问事件是否处理完成<br>    - 异步：asynchronous，<br>      被调用者通过状态，通知或者回调机制主动通知发起调用者相关的运行状态<br>  阻塞和非阻塞 - 发起者在等待结果时的状态<br>    阻塞和非阻塞关注的是调用发起者在等待结果返回之前所处的状态<br>      - 阻塞：blocking，<br>        指IO操作需要彻底完成后才返回到用户空间，调用结果返回之前，调用者被挂起，干不了别的事情。<br>        示例：心脑血管阻塞的时候，你只能在手术台上等着他们做手术。<br>      - 非阻塞：nonblocking，<br>        指IO操作被调用后立即返回给用户一个状态值，而无需等到IO操作彻底完成，在最终的调用结果返回之前，调用者不会被挂起，可以去做别的事情。<br>        示例：关将军刮骨疗毒，同时下棋，等待手术完成后，知道了即可。  <br> <br>五中IO模型：<br>  阻塞 IO（blocking IO）   <br>  非阻塞 IO（non-blocking IO）<br>  多路复用 IO（IO multiplexing） (单用户,多任务的场景)<br>  信号驱动 IO（signal driven I/O， SIGIO）<br>  异步 IO（Asynchronous I/O）<br> <br> <br> <br> <br> <br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CApache%E6%9C%8D%E5%8A%A1/image_DKGmAVxCbg.png"></p><p>!!!!<img src="/../image/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CApache%E6%9C%8D%E5%8A%A1/image_DuaoRmlwbw.png"></p><p>!!!!<img src="/../image/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CApache%E6%9C%8D%E5%8A%A1/image_O2cw2NTwdE.png"></p><p>!!!!<img src="/../image/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CApache%E6%9C%8D%E5%8A%A1/image_JyFCsdwO8L.png"></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs ada">Apache服务<br>  软件特点：<br>  apache2 特性   <br>    - 高度模块化：core + modules<br>    - DSO：Dynamic Shared Object 动态加载/卸载<br>    - MPM：multi-processing module 多路处理模块<br>  apache2 功能<br>    - 虚拟主机：IP，Port，FQDN<br>    - CGl：Common Gateway lnterface，通用网关接口<br>    - 反向代理、负载均衡、路径别名<br>    - 丰富的用户认证机制：basic，digest<br>    - 支持第三方模块<br>  工作模式：<br>    prefork 模型<br>    worker 模型<br>    event 模型<br>     <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CApache%E6%9C%8D%E5%8A%A1/image_7XStQI3lSs.png"></p><p>!!!!<img src="/../image/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CApache%E6%9C%8D%E5%8A%A1/image_-rTNqcZqWX.png"></p><p>!!!!<img src="/../image/HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CApache%E6%9C%8D%E5%8A%A1/image_6HZ_xYzYkS.png"></p>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DevOps 之 CICD 服务器 Jenkins</title>
    <link href="/2024/04/16/DevOps%20%E4%B9%8B%20CICD%20%E6%9C%8D%E5%8A%A1%E5%99%A8%20Jenkins/"/>
    <url>/2024/04/16/DevOps%20%E4%B9%8B%20CICD%20%E6%9C%8D%E5%8A%A1%E5%99%A8%20Jenkins/</url>
    
    <content type="html"><![CDATA[<h1 id="DevOps-之-CICD-服务器-Jenkins"><a href="#DevOps-之-CICD-服务器-Jenkins" class="headerlink" title="DevOps 之 CICD 服务器 Jenkins"></a>DevOps 之 CICD 服务器 Jenkins</h1><h4 id="Jenkins-部署与基本配置"><a href="#Jenkins-部署与基本配置" class="headerlink" title="Jenkins 部署与基本配置"></a>Jenkins 部署与基本配置</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Jenkins 用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。可用于自动化各种任务，如构建，测试和部署软件。<br>Jenkins 作为一个可扩展的自动化服务器，可以用作简单的 CI 服务器，或者变成任何项目的持续交付中心。<br>Jenkins 只是一个调度平台,其本身并不能完成项目的构建部署<br>Jenkins 需要安装各种插件,可能还需要编写Shell,python脚本等才能调用和集成众多的组件来实现复杂的构建部署功能<br><br>主要用途：<br>持续、自动地构建/测试软件项目<br>监控一些定时执行的任务<br><br>Jenkins特点：<br>开源免费<br>跨平台，支持所有的平台<br>master/slave支持分布式的build<br>web形式的可视化的管理页面<br>安装配置简单<br>及时快速的提示和帮助<br>已有的<span class="hljs-number">1800</span>+插件<br></code></pre></td></tr></table></figure><h4 id="Jenkins-安装和启动"><a href="#Jenkins-安装和启动" class="headerlink" title="Jenkins 安装和启动"></a>Jenkins 安装和启动</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Jenkins 支持多种部署和运行方式<br>Jenkins支持多种安装方法<br>包安装<br>JAVA的WAR文件<br>容器运行<br></code></pre></td></tr></table></figure><h4 id="Jenkins-实现-CICD"><a href="#Jenkins-实现-CICD" class="headerlink" title="Jenkins 实现 CICD"></a>Jenkins 实现 CICD</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">任务中构建将程序源码转换成一个可用的目标Target的过程，该过程可能会包括获取下载源码、解决依赖、编译和打包等环节<br>目标可以包括库、可执行文件及生成的脚本等，该类文件即是所谓的“制品”,它们通常应该存储于制品库,Nexus就是著名的制品库服务之一<br>程序员可以在本地进行构建，但基于有标准、统一构建环境的构建系统完成应用程序的构建，能有效确保制品质量<br>Jenkins虽然可以为构建服务器，但自身并未提供构建工具<br>Jenkins可以集成用户所需要的大部分主流构建工具来实现完整的构建过程<br>构建工具与源程序的编程语言及工程工具有密切关系,因而,在Jenkins服务器中具体需要安装和集成的构建工具,取决于用户的实际需要<br><br>Maven: Java<br>Go: Golang<br>Gradle: Java,Groovey和Kotlin等<br>SBT: Scala<br>Babel、Browserify、Weboack、Grunt及Gulp等: javascript<br></code></pre></td></tr></table></figure><h6 id="Jenkins-实现传统的-CICD-流程"><a href="#Jenkins-实现传统的-CICD-流程" class="headerlink" title="Jenkins 实现传统的 CICD 流程"></a>Jenkins 实现传统的 CICD 流程</h6><p>!!!!![](..&#x2F;image&#x2F;DevOps 之 CICD 服务器 Jenkins&#x2F;image-20250422142607063.png)</p><h6 id="Jenkins-架构"><a href="#Jenkins-架构" class="headerlink" title="Jenkins 架构"></a>Jenkins 架构</h6><p>!!!!![](..&#x2F;image&#x2F;DevOps 之 CICD 服务器 Jenkins&#x2F;image-20250422142631313.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Jenkins根据业务场景的不同,提供了多种风格的任务，默认是自由风格任务，通过安装插件，还可以支持其它风格的插件<br>Job的风格分类<br>自由风格freestyle：支持实现各种开发语言的不同场景的风格，以Shell为主要技术，内部有各种灵活的配置属性，默认只有此类型<br>流水线 pipeline：重点掌握的风格，使用专用语法<br>Maven 项目：仅适用于 JAVA 项目<br></code></pre></td></tr></table></figure><h4 id="创建-Freestyle-风格的任务-Job"><a href="#创建-Freestyle-风格的任务-Job" class="headerlink" title="创建 Freestyle 风格的任务 Job"></a>创建 Freestyle 风格的任务 Job</h4><p>!!!!![](..&#x2F;image&#x2F;DevOps 之 CICD 服务器 Jenkins&#x2F;image-20250422142733146.png)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">自由风格的任务提供了下面的组成<br>通用配置：当前任务的基本配置，历史记录、存储数据、认证、存储目录等<br>源码管理：指定当前任务依赖的代码仓库地址(仓库的分支)<br>构建触发器：在什么情况下，才会自动执行当前的任务<br>构建环境：构建过程中，依赖的环境变量等<br>构建：当前的代码构建操作，实现CICD核心步骤<br>构建后动作：构建任务成功后，我们可以做的事情，发送邮件、提交代码标签、触发其他任务、等等<br></code></pre></td></tr></table></figure><h4 id="Freestyle-风格任务构建流程"><a href="#Freestyle-风格任务构建流程" class="headerlink" title="Freestyle 风格任务构建流程"></a>Freestyle 风格任务构建流程</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs powershell">新建任务<br>输入任务名<br>选择自由风格的软件项目<br>描述该任务的作用<br><br>设置丢弃旧的构建<br>丢弃旧的构建：构建后的产物，保留多久<br>条件<span class="hljs-number">1</span>：保持构建的天数：当前项目构建的产物最多保留多少天<br>条件<span class="hljs-number">2</span>：保持构建的最大个数：当前项目最多保留多少构建产物，多出的自动删除<br><br>源码管理<br>从gitlab等仓库下载源码<br><br>构建触发器<br>定义自动构建的触发器<br><br>构建<br>构建项目的具体过程,比如: 编译,打包,部署等<br><br>构建后操作<br><br>晴雨表主要是针对一个任务的整体执行成功比例来算的。<span class="hljs-number">80</span>%成功表示太阳。<br>构建完成后可以执行的操作,比如,通知或执行其它任务<br></code></pre></td></tr></table></figure><h4 id="Jenkins-构建的环境变量"><a href="#Jenkins-构建的环境变量" class="headerlink" title="Jenkins 构建的环境变量"></a>Jenkins 构建的环境变量</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">构建时，Jenkins 支持使用变量,从而增强了任务的灵活性<br>环境变量有内置和自定义两种<br>在自由风格的的shell中可以使用<span class="hljs-variable">$</span>&#123;VAR_NAME&#125;引用变量<br><br>Pipeline 中引用全局环境<br>Jenkins内置的全局环境变量可被所有的pipeline引用，它们以“env.”为前缀<br>在pipeline中引用全局环境变量格式有三种：<br><span class="hljs-variable">$</span>&#123;env.&lt;ENV_VAR_NAME&gt;&#125; 不支持在shell 中引用<br><span class="hljs-variable">$env</span>.&lt;ENV_VAR_NAME&gt; 不支持 shell 中引用<br><span class="hljs-variable">$</span>&#123;ENV_VAR_NAME&#125; 支持在shell 中引用<br></code></pre></td></tr></table></figure><h4 id="Jenkins-内置环境变量"><a href="#Jenkins-内置环境变量" class="headerlink" title="Jenkins 内置环境变量"></a>Jenkins 内置环境变量</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Jenkins 提供了很多内置的变量<br><br>Jenkins内置的常用的环境变量<br>JENKINS_HOME：Jenkins的家目录<br>JENKINS_URL：Jenkins服务的URL<br>JOB_NAME：当前作业的名称<br>BUILD_NUMBER：构建号，递增的整数值；打包时，经常用作制品名称的一部分<br>BRANCH_NAME：在多分支pipeline中，需要根据不同的分支施加不同的操作时较为常用<br>BUILD_URL：当前构建页面的URL，常用于邮件通知中<br>GIT_BRANCH：基于git拉取的源码进行构建时使用该变量<br></code></pre></td></tr></table></figure><h4 id="自定义环境变量"><a href="#自定义环境变量" class="headerlink" title="自定义环境变量"></a>自定义环境变量</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">变量的优先级顺序：<br>任务中的自定义的变量 &gt; Jenkins 的自定义环境量 &gt; Jenkins 内置的环境变量<br></code></pre></td></tr></table></figure><h5 id="创建环境变量"><a href="#创建环境变量" class="headerlink" title="创建环境变量"></a>创建环境变量</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">自定义变量可以在系统管理<span class="hljs-literal">--</span>配置系统<span class="hljs-literal">--</span>全局属性<span class="hljs-literal">--</span> 环境变量 定义<br>注意：如果自定义环境变量与内置全局环境变量同名时，内置全局环境变量将被自定义环境变量覆盖<br>这可能会引起错误，必要时，可为自定义环境变量使用固定的前缀，例如“_ _”等<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>awk</title>
    <link href="/2024/04/12/awk/"/>
    <url>/2024/04/12/awk/</url>
    
    <content type="html"><![CDATA[<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs ada">格式：<br>    awk [参数] &#x27;[动作]&#x27; [文件名]<br>    awk [参数] –f 动作文件 var=value [文件名]<br>    awk [参数] <span class="hljs-symbol">&#x27;BEGIN</span>段 [动作] <span class="hljs-keyword">END</span>段&#x27; [文件名]<br>注意：<br>   动作的格式  &#x27;匹配条件&#123;打印动作&#125;&#x27;<br><br><br><br>动作<br>  <span class="hljs-keyword">BEGIN</span>&#123;动作的与操作&#125;<br>  /匹配条件/&#123;信息提取的答应动作&#125;(print|printf)<br>  <span class="hljs-keyword">END</span>&#123;动作的收尾工作&#125;<br> print 显示内容<br>    $<span class="hljs-number">0</span> 显示当前行所有内容<br>    $n 显示当前行的第n列内容，如果存在多个$n，它们之间使用逗号(,)隔开<br>    $NF 表示文本行中的最后一个数据字段<br>  注意:<br>    如果打印的内容是变量,则无需在变量两侧加上双引号,其他的都应该加双引号  <br> printf 格式化显示内容 <br>   %s 显示字符串 <br><br>awk进阶<br> <span class="hljs-keyword">if</span>条件判断<br> 样式<span class="hljs-number">1</span>：普通的非语句<br>   <span class="hljs-keyword">if</span>(条件)&#123;执行语句;...&#125;<span class="hljs-keyword">else</span> &#123;执行语句;...&#125;<br>   <span class="hljs-keyword">if</span>(条件<span class="hljs-number">1</span>)&#123;执行语句<span class="hljs-number">1</span>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件<span class="hljs-number">2</span>)&#123;执行语句<span class="hljs-number">2</span>&#125;<span class="hljs-keyword">else</span>&#123;执行语句<span class="hljs-number">3</span>&#125;<br> 样式<span class="hljs-number">2</span>：三元表达式<br>   条件表达式?真值表达式:假值表达式<br>   可以类比为：<br>        <span class="hljs-keyword">if</span>(条件)&#123;<br>            执行语句<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            执行语句<br>        &#125;    <br><br>switch条件<br>  语法格式<br>    switch (表达式) &#123;<br>        <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>|regex1 : 执行语句1;break<br>        <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>|regex2 : 执行语句2;break<br>        <span class="hljs-keyword">case</span> 值<span class="hljs-number">3</span>|regex3 : 执行语句3;break<br>        ...<br>        [ default: 执行语句 ]<br>    &#125;<br>注意：<br> 表达式的结果符合awk的逻辑运算，表达式成功返回<span class="hljs-number">0</span>，表达式失败返回<span class="hljs-number">1</span><br> 因为switch本身外侧没有流程控制，所以，一般情况下，当外侧没有循环控制的时候，会结合break来使用<br> 一旦遇到break，代表退出当前循环  <br><br><span class="hljs-keyword">for</span>循环：<br>  <span class="hljs-keyword">for</span>语句标准格式<br>     <span class="hljs-keyword">for</span> (三元表达式) &#123;<br>        执行语句<br>    &#125;<br>    <span class="hljs-keyword">for</span> (变量 <span class="hljs-keyword">in</span> 列表) &#123;<br>        执行语句<br>    &#125;<br>    <br><span class="hljs-keyword">for</span>语句简写格式<br>    <span class="hljs-keyword">for</span>(表达式) &#123;执行语句;...&#125;<br> <br>注意：<br>   <span class="hljs-keyword">for</span>语句可以结合<span class="hljs-keyword">if</span>语句进行操作<br>   <br><span class="hljs-keyword">while</span>循环:<br>  样式<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span>(条件)&#123;<br>        执行语句<br>    &#125;<br>  样式<span class="hljs-number">2</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        执行语句<br>    &#125; <span class="hljs-keyword">while</span>(条件)<br>    <br>简写样式<br>   <span class="hljs-keyword">while</span>(condition)&#123;执行语句;...&#125;<br>   <span class="hljs-keyword">do</span> &#123;条件;...&#125; <span class="hljs-keyword">while</span>(条件)     <br>   <br>流程控制:<br>  continue 中断本次循环(跳过本次循环)<br>     -条件匹配<br>  break 中断整个循环<br>  next 可以提前结束对匹配行处理而直接进入下一行处理<br>  nextfile 进阶版的next，可以提前结束对匹配行处理，直接读取下一个文件进行循环处理<br>  <span class="hljs-keyword">exit</span> 退出awk程序<br>    <span class="hljs-keyword">END</span>代码段属于<span class="hljs-keyword">exit</span>一部分，可以在<span class="hljs-keyword">BEGIN</span>或main段中执行<span class="hljs-keyword">exit</span>操作<span class="hljs-comment">--执行END语句块。     </span><br>   <br> 数组:<br>   定义数组：<br>      <span class="hljs-keyword">array</span>[index表达式]<br>      index表达式:<br>          可使用任意字符串；字符串要使用双引号括起来<br>          如果某数组元素事先不存在，在引用时，awk会自动创建此元素，并将其值初始化为空串<br>          若要判断数组中是否存在某元素，要使用index <span class="hljs-keyword">in</span> <span class="hljs-keyword">array</span>格式进行遍历<br>   <br>   遍历数组中的元素，要使用<span class="hljs-keyword">for</span>循环<br>      <span class="hljs-keyword">for</span>(var <span class="hljs-keyword">in</span> <span class="hljs-keyword">array</span>)&#123;<span class="hljs-keyword">for</span>-<span class="hljs-keyword">body</span>&#125;<br>      注意：<br>        var会遍历<span class="hljs-keyword">array</span>的每个索引，var不能用关键字index    <br>   <br>自定义函数:<br>  语法格式<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">函数名</span>(参数1, 参数2, ...)<br>    &#123;<br>        函数体代码<br>    &#125;<br>  注意：<br>    函数名不能用awk的关键字信息       <br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ansible基础</title>
    <link href="/2024/03/05/Ansible%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/03/05/Ansible%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Ansible基础"><a href="#Ansible基础" class="headerlink" title="Ansible基础"></a>Ansible基础</h1><p>本笔记介绍了Ansible的基本概念、工作特性、使用场景、架构解析、工作流程以及常用命令和配置文件结构。内容经过优化润色，保留了原始信息并增加了总结和注意事项，使条理更加清晰，重点更突出。所有正文内容均以 <code>ada</code> 代码块呈现，标题和章节采用标准 Markdown 语法，便于一次性复制使用。</p><hr><h2 id="1-Ansible简介"><a href="#1-Ansible简介" class="headerlink" title="1. Ansible简介"></a>1. Ansible简介</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Ansible是一个开源软件，提供配置管理、应用程序部署、自动化云服务管理等项目通用的管理功能。<br>- 主要运行在类Unix系统上，也支持Microsoft Windows系统。<br>- 利用特性语言描述各种资源对象，从而管理系统资源。<br></code></pre></td></tr></table></figure><hr><h2 id="2-Ansible的工作特性"><a href="#2-Ansible的工作特性" class="headerlink" title="2. Ansible的工作特性"></a>2. Ansible的工作特性</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">【基础属性】<br>- 开发：基于Python语言实现。<br>- 部署：依靠Python和SSH（agentless）实现简单部署。<br>- 安全：基于OpenSSH加密方式传输数据，无需代理，不依赖PKI；具有命令执行的幂等性。<br><br>【功能属性】<br>- 设计：采用插件化方式实现定制功能。<br>- 关键：三大关键模块：Paramiko、PyYAML、Jinja2。<br>- 定制：支持自定义功能模块，模块的使用方法类似于专用命令。<br><br>【进阶属性】<br>- 劣势：由于通信基于SSH，因此受SSH限制较多，尤其在主机量大时存在性能损耗问题。解决方案可采用专用代理或客户端方式以提高效率。<br></code></pre></td></tr></table></figure><hr><h2 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. 使用场景</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Ansible可用于：<br>- 自动化云服务管理<br>- 自动化设备管理<br>- 自动化应用部署<br>- 自动化配置管理<br>- 自动化持续交付<br>- 自动化安全管理<br><br>一句话概括：业务环境的自动化管理。<br></code></pre></td></tr></table></figure><hr><h2 id="4-架构解析与工作流程"><a href="#4-架构解析与工作流程" class="headerlink" title="4. 架构解析与工作流程"></a>4. 架构解析与工作流程</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">【架构解析】<br>Ansible采用三层结构：<br>  <span class="hljs-number">1</span>. 用户端<br>  <span class="hljs-number">2</span>. 控制端<br>  <span class="hljs-number">3</span>. 被控端<br><br>【工作流程】<br>  <span class="hljs-number">1</span>. 用户通过命令或playbook向控制端发起请求。<br>  <span class="hljs-number">2</span>. 控制端检查主机列表，验证目标主机是否存在。<br>  <span class="hljs-number">3</span>. 若目标存在，控制端通过连接插件与被控端建立连接。<br>  <span class="hljs-number">4</span>. 控制端根据用户指令和功能模块，指定目标主机执行相应任务。<br>  <span class="hljs-number">5</span>. 被控端执行任务后，将状态结果返回给控制端。<br>  <span class="hljs-number">6</span>. 控制端通过插件实现日志记录、邮件通知等辅助功能。<br></code></pre></td></tr></table></figure><hr><h2 id="5-Ansible命令执行来源"><a href="#5-Ansible命令执行来源" class="headerlink" title="5. Ansible命令执行来源"></a>5. Ansible命令执行来源</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Ansible的命令可通过以下方式执行：<br>- 系统用户直接在终端中执行Ad<span class="hljs-literal">-Hoc</span>命令。<br>- 在playbook中间接执行：playbook中包含多条Ansible命令，依次执行。<br>- 通过Web管理界面执行。<br>- 通过API调用执行：配置API接口，让第三方应用调用执行Ansible命令。<br></code></pre></td></tr></table></figure><hr><h2 id="6-软件部署与需求"><a href="#6-软件部署与需求" class="headerlink" title="6. 软件部署与需求"></a>6. 软件部署与需求</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">【通用环境需求】<br>- 服务端与客户端均基于SSH协议通信，须提前配置SSH环境。<br><br>【控制端需求】<br>- 控制端需运行在类Unix系统上（不支持Windows）。<br>- 需预先安装Python <span class="hljs-number">2.7</span>+或Python <span class="hljs-number">3.5</span>+环境。<br><br>【被控端需求】<br>- 一般功能无需预装Python，但若涉及Python业务，则需配置相应版本：<br>    - 若被控端Python版本小于<span class="hljs-number">2.4</span>，则需安装python<span class="hljs-literal">-simplejson</span>。<br>    - 若启用SELinux，则需安装libselinux<span class="hljs-literal">-python</span>。<br>    - Windows只能作为被控端使用。<br></code></pre></td></tr></table></figure><hr><h2 id="7-软件环境与常见命令"><a href="#7-软件环境与常见命令" class="headerlink" title="7. 软件环境与常见命令"></a>7. 软件环境与常见命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Ansible常见的可执行命令包括：<br>- /usr/bin/ansible             —— 主命令，用于执行Ad<span class="hljs-literal">-Hoc</span>任务。<br>- /usr/bin/ansible<span class="hljs-literal">-config</span>      —— 配置管理命令。<br>- /usr/bin/ansible<span class="hljs-literal">-console</span>     —— 交互式命令行工具。<br>- /usr/bin/ansible<span class="hljs-literal">-doc</span>         —— 模块帮助命令。<br>- /usr/bin/ansible<span class="hljs-literal">-galaxy</span>      —— 扩展命令，用于获取角色模板文件。<br>- /usr/bin/ansible<span class="hljs-literal">-playbook</span>    —— 任务管理工具（主要用于长期规划、大型项目）。<br>- /usr/bin/ansible<span class="hljs-literal">-pull</span>        —— 反模式工作命令。<br>- /usr/bin/ansible<span class="hljs-literal">-vault</span>       —— 文件加密工具。<br></code></pre></td></tr></table></figure><hr><h2 id="8-Ansible管理方式"><a href="#8-Ansible管理方式" class="headerlink" title="8. Ansible管理方式"></a>8. Ansible管理方式</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">主要管理方式：<br>- Ad<span class="hljs-literal">-Hoc</span>：直接使用Ansible命令在远程主机上执行单个任务，适用于临时操作。<br>- Ansible<span class="hljs-literal">-playbook</span>：适用于长期规划、大型项目，需要预先编写剧本（Playbook）。<br></code></pre></td></tr></table></figure><hr><h2 id="9-命令格式与模块"><a href="#9-命令格式与模块" class="headerlink" title="9. 命令格式与模块"></a>9. 命令格式与模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell">【通用命令格式】<br>  ansible &lt;目标主机&gt; 参数<br><br>【专用格式】<br>  ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> 模块 <span class="hljs-literal">-a</span> 模块参数<br><br>【说明】<br>- Ad<span class="hljs-literal">-Hoc</span>命令允许用户快速在远程主机上执行单条任务，无需编写完整剧本。<br>- Ansible的主要功能均通过各类插件模块实现，默认模块为command。<br></code></pre></td></tr></table></figure><hr><h2 id="10-主配置文件结构"><a href="#10-主配置文件结构" class="headerlink" title="10. 主配置文件结构"></a>10. 主配置文件结构</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">默认配置文件和目录：<br>  - /etc/ansible/ansible.cfg：主配置文件，定义Ansible工作特性，可在项目目录下创建独立配置文件，当前目录的ansible.cfg优先级最高。<br>  - /etc/ansible/hosts：主机清单文件。<br>  - /etc/ansible/roles/：存放角色的目录。<br><br>配置文件优先级（由高到低）：<br>  <span class="hljs-number">1</span>. ANSIBLE_CONFIG环境变量<br>  <span class="hljs-number">2</span>. 当前目录下的ansible.cfg<br>  <span class="hljs-number">3</span>. 当前用户家目录下的.ansible.cfg<br>  <span class="hljs-number">4</span>. /etc/ansible/ansible.cfg<br></code></pre></td></tr></table></figure><hr><h2 id="11-模块与命令示例"><a href="#11-模块与命令示例" class="headerlink" title="11. 模块与命令示例"></a>11. 模块与命令示例</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs powershell">【command模块】<br>- 默认模块，无需使用<span class="hljs-literal">-m</span>指定，可直接通过 <span class="hljs-literal">-a</span> 传入命令参数执行。<br>- 示例：ansible &lt;目标主机&gt; <span class="hljs-literal">-a</span> <span class="hljs-string">&quot;命令参数&quot;</span><br><br>【ping模块】<br>- 用于检测目标主机的连通性。<br>- 示例：ansible localhost <span class="hljs-literal">-m</span> ping<br><br>【ansible<span class="hljs-literal">-doc</span>命令】<br>- 用于查看Ansible模块的帮助信息。<br>- 示例：ansible<span class="hljs-literal">-doc</span> command （完整帮助）或 ansible<span class="hljs-literal">-doc</span> command <span class="hljs-literal">-s</span> （简要帮助）<br><br>【ansible<span class="hljs-literal">-config</span>命令】<br>- 管理Ansible配置信息：<br>    - view：查看当前配置<br>    - dump：查看默认环境变量<br>    - list：列出详细配置项<br>    - init：创建初始化配置文件<br></code></pre></td></tr></table></figure><hr><h2 id="12-主机清单"><a href="#12-主机清单" class="headerlink" title="12. 主机清单"></a>12. 主机清单</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">【主机清单文件】<br>- 默认文件：/etc/ansible/hosts，可在项目目录下创建独立的hosts文件以区分不同项目。<br>- 格式：INI风格，组名写在中括号中，同一主机可归属于多个组。<br>- 主机描述方式：可以使用IP地址或主机名，并可指定非默认SSH端口（用冒号标识）。<br>  <br>【主机列表形式】<br>主机清单的描述方式有两种：主机ip地址和主机名<br><span class="hljs-comment">## blue<span class="hljs-doctag">.example</span>.com</span><br><span class="hljs-comment">## 192.168.100.1</span><br>主机列表有两种形式：散列主机列表和主机组列表<br>散列主机列表            主机组列表              嵌套主机组列表<br><span class="hljs-comment">## blue<span class="hljs-doctag">.example</span>.com   ## [webservers]       ## [server:children]</span><br><span class="hljs-comment">## 192.168.100.1:9999 ## beta<span class="hljs-doctag">.example</span>.org   ## webservers</span><br><span class="hljs-comment">## 192.168.1.100      ## [webservers]       ## www[1:100]<span class="hljs-doctag">.example</span>.com</span><br>主机列表范围形式可以使用<span class="hljs-string">&quot;[起始值:结束值]&quot;</span>样式来表示<br><span class="hljs-comment">## www[001:006]<span class="hljs-doctag">.example</span>.com         主机名方式表示6台目标主机</span><br><span class="hljs-comment">## 192.168.1.10[0:9]                主机ip地址表示10台目标主机</span><br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">主机组名列表样式:<br><span class="hljs-number">10.0</span>.<span class="hljs-number">0.13</span><br>[<span class="hljs-type">ansible_server</span>]<br><span class="hljs-number">10.0</span>.<span class="hljs-number">0.13</span><br>组名只能包含了 字母、数字、下划线符号<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">主机做ssh的免密认证:<br>root@ubuntu24<span class="hljs-literal">-13</span>:~<span class="hljs-comment"># ssh-keygen</span><br>root@ubuntu24<span class="hljs-literal">-13</span>:~<span class="hljs-comment"># ssh-copy-id root@localhost</span><br>root@ubuntu24<span class="hljs-literal">-13</span>:~<span class="hljs-comment"># ssh-copy-id root@10.0.0.13</span><br> 通信方式：ansible连接目标主机主要是通过ssh协议的方式<br> 认证列表：ansible会将连接成功的主机列表信息，记录到ssh的认证列表<span class="hljs-string">&quot;.ssh/known_hosts&quot;</span>中<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">[<span class="hljs-type">root</span>@<span class="hljs-type">ubuntu13</span> ~]<span class="hljs-comment"># ansible 10.0.0.13 -a &quot;ls /root&quot;</span><br>Enter passphrase <span class="hljs-keyword">for</span> key <span class="hljs-string">&#x27;/root/.ssh/id_ed25519&#x27;</span>:<br>[<span class="hljs-type">WARNING</span>]: Platform linux on host <span class="hljs-number">10.0</span>.<span class="hljs-number">0.13</span> is <span class="hljs-keyword">using</span> the discovered Python interpreter at /usr/bin/python3.12, but<br>future installation of another Python interpreter could change the meaning of that path. See<br>https://docs.ansible.com/ansible<span class="hljs-literal">-core</span>/<span class="hljs-number">2.17</span>/reference_appendices/interpreter_discovery.html <span class="hljs-keyword">for</span> more information.<br><span class="hljs-number">10.0</span>.<span class="hljs-number">0.13</span> | CHANGED | rc=<span class="hljs-number">0</span> &gt;&gt;<br><span class="hljs-number">1</span>.sh<br>  这个警告信息来自 Ansible，它指出在目标主机（IP 地址为 <span class="hljs-number">10.0</span>.<span class="hljs-number">0.13</span>）上，Ansible 使用的是<br>位于 /usr/bin/python3.<span class="hljs-number">12</span> 的 Python 解释器。然而，警告中提到未来如果安装了另一个 Python 解<br>释器，这个路径的含义可能会改变，这可能会导致 Ansible 脚本执行时出现问题。<br>为了解决这个问题，我们可以采取指定 Python 解释器路径 的方法来解决<br>把之前的主机改成:<br><span class="hljs-number">10.0</span>.<span class="hljs-number">0.13</span> ansible_python_interpreter=/usr/bin/python3.<span class="hljs-number">12</span><br>[<span class="hljs-type">ansible_server</span>]<br><span class="hljs-number">10.0</span>.<span class="hljs-number">0.13</span> ansible_python_interpreter=/usr/bin/python3.<span class="hljs-number">12</span><br>    <br></code></pre></td></tr></table></figure><h2 id="13-目标主机匹配"><a href="#13-目标主机匹配" class="headerlink" title="13.目标主机匹配"></a><strong>13.<strong>目标主机匹配</strong></strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">匹配规则;<br>  对于目标的匹配规则来说，他们的获取方式和表现样式主要有这么几种：<br>    匹配所有：all<br>    正则匹配：*(通配符)<br>    逻辑或：:(并集)，一般用于主机组<br>    逻辑与：:&amp;(交集)，一般用于主机组<br>    逻辑非：:!(补集)，一般用于主机组  <br></code></pre></td></tr></table></figure><h2 id="14-命令执行流程"><a href="#14-命令执行流程" class="headerlink" title="14.命令执行流程"></a>14.命令执行流程</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">命令执行过程:<br>  <span class="hljs-number">1</span>. 加载ansible配置文件 <br>    默认加载的是 /etc/ansible/ansible.cfg <br>  <span class="hljs-number">2</span>. 加载指定模块：command<br>  <span class="hljs-number">3</span>. 获取目标主机，与主机列表进行匹配认证    /etc/ansible/hosts<br>  <span class="hljs-number">4</span>. ansible指挥目标主机执行命令<br>    <span class="hljs-number">4.1</span> 控制端生成临时执行文件        ~/.ansible/<span class="hljs-built_in">cp</span><br>    <span class="hljs-number">4.2</span> 通过连接插件，与目标主机建立连接     paramiko_ssh<br>    <span class="hljs-number">4.3</span> 通过插件功能将控制端的临时执行文件传输至目标主机的临时目录     ~/.ansible/tmp<br>      <span class="hljs-variable">$HOME</span>/.ansible/tmp/ansible<span class="hljs-literal">-tmp-</span>数字/XXX.PY文件<br>    <span class="hljs-number">4.4</span> 指挥目标主机给临时执行文件添加执行权限<br>    <span class="hljs-number">4.5</span> 目标主机执行临时文件并将结果返回给控制主机<br>    <span class="hljs-number">4.6</span> 目标主机删除临时执行py文件，然后断开连接<br>  <span class="hljs-number">5</span>. ansible控制端显示结果，并退出。  <br></code></pre></td></tr></table></figure><h1 id="日常命令操作模块"><a href="#日常命令操作模块" class="headerlink" title="日常命令操作模块"></a><strong>日常命令操作模块</strong></h1><h2 id="command模块"><a href="#command模块" class="headerlink" title="command模块"></a><strong>command</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell">command： ansible的默认模块，可以运行远程权限所有的shell命令<br>命令格式:<br>  Command模块在ansible使用的时候，标准的写法是：<br>    ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> command <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;可执行命令&#x27;</span><br>  注意：<br>    由于ansible的默认模块就是command，所以远程执行命令的时候，一般会忽略<span class="hljs-literal">-m</span>选项，效果如下：<br>    ansible &lt;目标主机&gt; <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;可执行命令&#x27;</span><br>    可执行命令，就是我们平常在命令行输入的一些执行成功的命令,但是不允许是别名<br>    command不支持<span class="hljs-string">&quot;可执行命令&quot;</span>中的自定义变量和特殊符号(&lt; &gt; | ;&amp;等) <br>    <br>argv:           <span class="hljs-comment"># 以列表或者字符串格式输入命令</span><br><span class="hljs-built_in">chdir</span>:             <span class="hljs-comment"># 执行命令前，先切换工作路径.</span><br>creates:         <span class="hljs-comment"># 依赖存在对象的命令，若被创建的对象已存在，则不执行该命令</span><br>free_form:     <span class="hljs-comment"># 以自由格式输入参数，这是一个强制的选项</span><br>removes:            <span class="hljs-comment"># 依赖移除对象的命令，若被移除的对象存在，则执行该命令</span><br>stdin:           <span class="hljs-comment"># 设定标准输入作为参数.</span><br>warn:             <span class="hljs-comment"># 警告信息，需要ansible的配置文件的 command_warnings的属性值是yes.</span><br>command默认情况下，可执行命令中不允许出现命令别名 和管道符等特殊服务号<br>对于系统默认的环境变量，ansible可以正常执行，但是涉及到一些自定义变量和特殊符号就不行了<br></code></pre></td></tr></table></figure><h2 id="shell模块"><a href="#shell模块" class="headerlink" title="shell模块"></a>shell模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">shell：command对于某些特殊的符号命令执行效果不好，专用的shell模块可以满足要求<br><br><span class="hljs-built_in">chdir</span>:               <span class="hljs-comment"># 同command</span><br>creates:               <span class="hljs-comment"># 同command</span><br>executable:           <span class="hljs-comment"># 设置执行命令的shell类型</span><br>free_form:             <span class="hljs-comment"># 同command</span><br>removes:               <span class="hljs-comment"># 同command</span><br>stdin:                 <span class="hljs-comment"># 同command</span><br>warn:                 <span class="hljs-comment"># 同command</span><br>命令格式<br>  Shell模块在ansible使用的时候，标准的写法是：<br>  ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> shell <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;可执行命令&#x27;</span><br>  注意：<br>    可执行命令，就是我们平常在命令行输入的一些执行成功的命令<br>    shell支持<span class="hljs-string">&quot;可执行命令&quot;</span>中的所有效果<br>    shell在远程执行脚本的时候，必须远程主机存在，否则的话会报错<br>    <br></code></pre></td></tr></table></figure><h2 id="scripts模块"><a href="#scripts模块" class="headerlink" title="scripts模块"></a>scripts模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">scripts：批量的系统命令可以写成一个脚本文件，然后基于scripts的方式来运行，类似scp+shell的功能。<br>        专门用于执行复杂脚本场景的功能模块<br>命令格式<br>script模块在ansible使用的时候，标准的写法是：<br>ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> script <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;可执行命令&#x27;</span><br>注意：<br> script就是不但可以执行目标主机上的脚本文件，而且还能执行目标主机不存在的控制端特有的脚本文件<br>  对于控制端的脚本文件执行的时候，必须使用executable<br>  此模块不具有幂等性<br>  <br>  命令执行成功的标志 CHANGED <br>  标准的输出信息在 stdout_lines      <br></code></pre></td></tr></table></figure><h1 id="系统管理模块"><a href="#系统管理模块" class="headerlink" title="系统管理模块"></a><strong>系统管理模块</strong></h1><h2 id="hostname模块"><a href="#hostname模块" class="headerlink" title="hostname模块"></a>hostname模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">该模块可以获取主机名相关的信息<br>hostname模块在ansible使用的时候，标准的写法是：<br>ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> hostname <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;name=主机名&#x27;</span><br>注意：<br> 主机名的设置一定要规范<br> 这种方式更改的主机名，是立刻生效而且是永久生效的<br></code></pre></td></tr></table></figure><h2 id="user模块"><a href="#user模块" class="headerlink" title="user模块"></a><strong>user</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">user模块，主要是用于对远程主机的用户进行干预操作<br>常见属性<br>    comment:               <span class="hljs-comment"># 用户的描述信息.</span><br>    <span class="hljs-built_in">group</span>:                 <span class="hljs-comment"># 设定用户的主组信息</span><br>    home:                 <span class="hljs-comment"># 设置用户家目录.</span><br>    password:             <span class="hljs-comment"># 设置登录密码</span><br>    shell:                 <span class="hljs-comment"># 设定用户的专用shell类型</span><br>    state:                 <span class="hljs-comment"># 设定用户的存活状态</span><br>    system:               <span class="hljs-comment"># 设定用户是否为系统用户</span><br>    uid:                   <span class="hljs-comment"># 设定用户uid</span><br>    remove <span class="hljs-comment"># 设定删除用户及家目录等数据,默认remove=no，推荐用yes</span><br>命令格式<br>  hostname模块在ansible使用的时候，标准的写法是：<br>    ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> user <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 属性2=值2 ... 属性n=值n&#x27;</span><br>  注意：<br>    用户名的设置一定要提前做好规划<br>    在工作中，uid的值一定要提前做好规划，而且必须唯一。  <br></code></pre></td></tr></table></figure><h2 id="group模块"><a href="#group模块" class="headerlink" title="group模块"></a><strong>group</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">该模块应用于用户组的管理<br>命令格式<br>  <span class="hljs-built_in">group</span>模块在ansible使用的时候，标准的写法是：<br>  ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> <span class="hljs-built_in">group</span> <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 属性2=值2 ... 属性n=值n&#x27;</span><br>    注意：<br>    主机名的设置一定要规范，gid一定要唯一。  <br></code></pre></td></tr></table></figure><h4 id="getent命令可以用来察看系统的数据库中的相关记录-经常使用getent查看用户账号"><a href="#getent命令可以用来察看系统的数据库中的相关记录-经常使用getent查看用户账号" class="headerlink" title="getent命令可以用来察看系统的数据库中的相关记录 经常使用getent查看用户账号"></a>getent命令可以用来察看系统的数据库中的相关记录 经常使用getent查看用户账号</h4><h2 id="cron模块"><a href="#cron模块" class="headerlink" title="cron模块"></a><strong>cron</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs powershell">cron模块主要做一些，类似于周期性任务相关的任务执行动作<br>常见属性<br>      day:               <span class="hljs-comment"># 设定天效果 ( 1-31, *, */2, etc )</span><br>      disabled:         <span class="hljs-comment"># 结合`state=present&#x27;实现禁用定时任务.</span><br>      hour:             <span class="hljs-comment">#设定时效果 ( 0-23, *, */2, etc )</span><br>      job:               <span class="hljs-comment"># 如果是env，内容是变量，如果是state=present，内容是定时任务.</span><br>      minute:           <span class="hljs-comment"># 设定分钟效果 ( 0-59, *, */2, etc )</span><br>      month:             <span class="hljs-comment"># 设定月效果 ( 1-12, *, */2, etc )</span><br>      name:               <span class="hljs-comment"># 如果有 env，则是变量名，如果有state=present则是定时任务名.</span><br>      weekday:           <span class="hljs-comment"># 周表示样式 ( 0-6 for Sunday-Saturday, *, etc )</span><br>注意：<br> 上面是常用的属性<br> name和job最好作为强制选项<br> <br> 命令格式<br>   cron模块在ansible使用的时候，标准的写法是：<br>   ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> cron <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 属性2=值2 ... 属性n=值n&#x27;</span><br>注意：<br>   job的命令一定要规范，最好使用绝对路径。<br>   state=absent 表示删除<br>   disabled=yes|no|true|false 表示禁用或启用  <br></code></pre></td></tr></table></figure><h1 id="setup模块"><a href="#setup模块" class="headerlink" title="setup模块"></a><strong>setup</strong>模块</h1><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">setup 主要是用来收集目标主机的属性信息的<br>常用参数<br>      fact_path:             <span class="hljs-comment"># 设定facts的文件路径</span><br>      <span class="hljs-keyword">filter</span>:               <span class="hljs-comment"># 指定过滤格式，可以正则形式.</span><br>注意：<br>  常用的属性，也就上面标红的两个。<br>  setup这个模块是通过调用ansible的facts组件来获取主机是所有属性信息的<br>命令格式<br>  setup模块在ansible使用的时候，标准的写法是：<br>  ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> setup <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 属性2=值2 ... 属性n=值n&#x27;</span><br>注意：<br>  不加 <span class="hljs-literal">-a</span>的话，表示获取目标主机的所有属性信息<br>  过滤信息的规则一定要合理的设计。<br>  这个功能很重要，尤其是后期自动化管理的时候  <br></code></pre></td></tr></table></figure><h2 id="selinux模块"><a href="#selinux模块" class="headerlink" title="selinux模块"></a><strong>selinux</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">selinux 模块用作对远程主机的 selinux 机制进行管理<br>常见参数<br>  configfile=/path/file <span class="hljs-comment">#selinux 配置文件路径，默认/etc/selinux/config</span><br>  policy=targeted|minimum|mls <span class="hljs-comment">#在state值不为 disabled 时必选</span><br>  state=disabled|enforcing|permissive <span class="hljs-comment">#具体设置</span><br></code></pre></td></tr></table></figure><h2 id="mount模块"><a href="#mount模块" class="headerlink" title="mount模块"></a><strong>mount</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">mount</span> 模块用于管理远程主机的挂载<br>常见参数<br>  src=/path/device <span class="hljs-comment">#要挂载的设备路径，可以是网络地址</span><br>  path=/path/point <span class="hljs-comment">#挂载点</span><br>  state=absent|mounted|present|unmounted|remounted  <span class="hljs-comment"># absent 取消挂载,并删除永久挂载中的配置</span><br>                   <span class="hljs-comment"># mounted 永久挂载,立即生效，挂载点不存在会自动创建</span><br>                   <span class="hljs-comment"># present 永久挂载，写配置文件，但不会立即生效</span><br>                   <span class="hljs-comment"># unmounted 临时取消挂载，不改变配置文件</span><br>                   <span class="hljs-comment"># remounted 重新挂载，但不会改变配置文件</span><br>  fstab=/path/file <span class="hljs-comment">#指定挂载配置文件路径，默认 /etc/fstab</span><br>  fstype=str <span class="hljs-comment">#设备文件系统 xfs|ext4|swap|iso9660...</span><br>  opts=str <span class="hljs-comment">#挂载选项</span><br></code></pre></td></tr></table></figure><h2 id="sysctl模块"><a href="#sysctl模块" class="headerlink" title="sysctl模块"></a><strong>sysctl</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sysctl 模块用来修改远程主机上的内核参数<br>常见参数<br>  name=str <span class="hljs-comment">#参数名称</span><br>  val=str <span class="hljs-comment">#参数值</span><br>  reload=yes|no <span class="hljs-comment">#默认yes，调用 /sbin/sysctl -p 生效</span><br>  state=present|absent <span class="hljs-comment">#是否保存到文件，默认present</span><br>  sysctl_file=/path/file <span class="hljs-comment">#指定保存文件路径，默认 /etc/sysctl.conf</span><br>  sysctl_set=yes|no <span class="hljs-comment">#是否使用systctl -w 校验，默认no  </span><br></code></pre></td></tr></table></figure><h1 id="文件管理模块"><a href="#文件管理模块" class="headerlink" title="文件管理模块"></a><strong>文件管理模块</strong></h1><h2 id="copy模块"><a href="#copy模块" class="headerlink" title="copy模块"></a><strong>copy</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">copy</span>模块主要涉及到文件的拷贝动作<br>常见参数<br>   backup:             <span class="hljs-comment"># 创建一个包含时间戳信息的备份文件</span><br>   dest:               <span class="hljs-comment"># 设置目标的路径(强制选项)，格式与src一致</span><br>   <span class="hljs-built_in">group</span>:             <span class="hljs-comment"># 设定文件属组信息.</span><br>   mode:             <span class="hljs-comment"># 设定文件属性信息.</span><br>   owner:             <span class="hljs-comment"># 设定文件属主信息.</span><br>   src:               <span class="hljs-comment"># 源文件的路径，平常使用的话，推荐使用相对路径，敏感文件推荐用绝对路径</span><br> <br>注意：<br> 常用的属性，也就上面标红的六个。<br> 备份的时候，使用默认的时间戳效果。<br> 如果源文件是目录的话，则必须携带/后缀<br> <br>命令格式<br>  <span class="hljs-built_in">copy</span>模块在ansible使用的时候，标准的写法是：<br>    ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> <span class="hljs-built_in">copy</span> <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 属性2=值2 ... 属性n=值n&#x27;</span><br>注意：<br>    src源文件路径和dest目标文件的路径，最好格式一致<br></code></pre></td></tr></table></figure><h2 id="fetch模块"><a href="#fetch模块" class="headerlink" title="fetch模块"></a><strong>fetch</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">该模块的作用于<span class="hljs-built_in">copy</span>的作用正好相反，它是从远程主机拉取文件到本地目录<br>常见参数<br>      dest:                 <span class="hljs-comment"># 设定目标文件的地址(强制选项)</span><br>      flat:                 <span class="hljs-comment"># 允许拼接方式创建文件名</span><br>      src:                   <span class="hljs-comment"># 设定源文件的地址(强制选项)</span><br>注意：<br>   常用的属性，也就上面标红的三个。<br>   源文件和目标文件的格式最好一致。<br>   src 当前的版本，只支持抓取远程的单个文件<br>   dest 支持只能是本机的目录，抓取后的格式： <span class="hljs-string">&quot;/dest/&quot;</span> + <span class="hljs-string">&quot;目标主机/path/to/src&quot;</span><br>命令格式<br>  fetch模块在ansible使用的时候，标准的写法是：<br>  ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> fetch <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 属性2=值2 ... 属性n=值n&#x27;</span>  <br></code></pre></td></tr></table></figure><h2 id="file模块"><a href="#file模块" class="headerlink" title="file模块"></a><strong>file</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">file模块，用于管理远程主机的文件，操作远程文件的各种动作<br>常见参数<br>  mode:                 <span class="hljs-comment"># 设定文件权限属性.</span><br>  owner:                 <span class="hljs-comment"># 设定文件属主.</span><br>  path:                 <span class="hljs-comment"># 指定文件的路径(强制选项).之前版本可以用name和dest来代替</span><br>  src:                   <span class="hljs-comment"># 指定文件的源路径.</span><br>  state:                 <span class="hljs-comment"># 设定文件的状态，directory、file、absent、touch、link</span><br>命令格式<br>  file模块在ansible使用的时候，标准的写法是：<br>    ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> file <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 属性2=值2 ... 属性n=值n&#x27;</span><br> <br>注意：<br> 在创建相关文件的话，如果涉及到父目录，必须确保父目录存在，否则会失败  <br></code></pre></td></tr></table></figure><h2 id="stat模块"><a href="#stat模块" class="headerlink" title="stat模块"></a><strong>stat</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">stat模块主要作用的场景是 文件状态查看等<br>常见参数<br>   path:                 <span class="hljs-comment"># 获取文件的路径，强制选项</span><br>命令格式<br>   stat模块在ansible使用的时候，标准的写法是：<br>   ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> stat <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;path=文件路径 属性1=值1 ... 属性n=值n&#x27;</span><br>注意：<br>   文件的路径一定要正确。  <br></code></pre></td></tr></table></figure><h1 id="压缩包模块"><a href="#压缩包模块" class="headerlink" title="压缩包模块"></a><strong>压缩包模块</strong></h1><h2 id="Get-url模块"><a href="#Get-url模块" class="headerlink" title="Get_url模块"></a><strong>Get_url</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">用于将文件从http、https或ftp下载到被管理机节点上<br>常见参数：<br>   url: 下载文件的URL,支持HTTP，HTTPS或FTP协议<br>   dest: 下载到目标路径（绝对路径）<br>   force: 如果yes，dest不是目录，将每次下载文件，如果内容改变，替换文件，否则只有文件不存在时才下载<br>   checksum:  对目标文件在下载前进行摘要计算，只有文件内容正确，才会进行文件下载<br>命令格式<br>   get_url模块在ansible使用的时候，标准的写法是：<br>   ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> get_url <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;url=文件的http路径 属性1=值1 ... 属性n=值n&#x27;</span><br>注意：<br>   文件的url路径一定要正确。  <br></code></pre></td></tr></table></figure><h2 id="archive模块"><a href="#archive模块" class="headerlink" title="archive模块"></a><strong>archive</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">archive模块，用于打包压缩保存在被管理节点<br>命令格式<br>  archive模块在ansible使用的时候，标准的写法是：<br>    ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> archive <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 ... 属性n=值n&#x27;</span>  <br></code></pre></td></tr></table></figure><h2 id="unarchive模块"><a href="#unarchive模块" class="headerlink" title="unarchive模块"></a><strong>unarchive</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">unarchive模块主要用于压缩包的解压功能<br>常见参数<br>   <span class="hljs-built_in">copy</span>：默认为yes，<br>         当<span class="hljs-built_in">copy</span>=yes，拷贝的文件是从ansible主机复制到远程主机上，<br>         如果设置为<span class="hljs-built_in">copy</span>=no，会在远程主机上寻找src源文件<br>   remote_src：和<span class="hljs-built_in">copy</span>功能一样且互斥，yes表示在远程主机，不在ansible主机，no表示文件在ansible主机上<br>   src：源路径，可以是ansible主机上或远程主机上的路径，如果是远程主机上的路径，则需要设置<span class="hljs-built_in">copy</span>=no<br>   dest：远程主机上的目标路径<br>   mode：设置解压缩后的文件权限<br>注意：<br>   有时候，会因为ansible版本的问题，导致无法远程解压，可以通过 <span class="hljs-built_in">copy</span> + shell方式来解决<br>命令格式<br>  unarchive模块在ansible使用的时候，标准的写法是：<br>     ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> unarchive <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 ... 属性n=值n&#x27;</span>  <br></code></pre></td></tr></table></figure><h1 id="编辑模块"><a href="#编辑模块" class="headerlink" title="编辑模块"></a><strong>编辑模块</strong></h1><h2 id="Lineinfile模块"><a href="#Lineinfile模块" class="headerlink" title="Lineinfile模块"></a><strong>Lineinfile</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">   ansible在使用sed进行替换时，经常会遇到需要转义的问题，而且ansible在遇到特殊符号进行替换时，存在问题，无法正常进行替换 。其实在ansible自身提供了两个模块：lineinfile模块和replace模块，可以方便的进行替换<br>   一般在ansible当中去修改某个文件的单行进行替换的时候需要使用lineinfile模块<br>重要选项 <br>   regexp参数：使用正则表达式匹配对应的行，当替换文本时，如果有多行文本都能被匹配，则只有最后面被匹配到的那行文本才会被替换，当删除文本时，如果有多行文本都能被匹配，这么这些行都会被删除。<br>   如果想进行多行匹配进行替换需要使用replace模块<br>命令格式<br>  lineinfile模块在ansible使用的时候，标准的写法是：<br>    ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> lineinfile <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 ... 属性n=值n&#x27;</span>  <br></code></pre></td></tr></table></figure><h2 id="Replace模块"><a href="#Replace模块" class="headerlink" title="Replace模块"></a><strong>Replace</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Replace模块相较于lineinfile模块来说，更倾向于sed命令的操作，尤其是多行匹配进行替换操作<br>命令格式<br>  replace模块在ansible使用的时候，标准的写法是：<br>    ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> replace <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 ... 属性n=值n&#x27;</span>  <br></code></pre></td></tr></table></figure><h1 id="软件模块"><a href="#软件模块" class="headerlink" title="软件模块"></a><strong>软件模块</strong></h1><h2 id="apt模块"><a href="#apt模块" class="headerlink" title="apt模块"></a><strong>apt</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs powershell">yum模块和apt模块分别用于 centos|redhat 和 ubuntu|debian 系统下的软件安装<br>  这两个模块的核心选项基本上都是一样的，常见的选项有<br>    name:                 <span class="hljs-comment"># 指定安装软件.</span><br>    state:                 <span class="hljs-comment"># 软件状态：安装(present|installed)</span><br>                           <span class="hljs-comment"># 移除(absent|removed)</span><br>                           <span class="hljs-comment"># 升级到最新版本latest</span><br>                           <span class="hljs-comment"># build-dep 安装依赖包</span><br>                           <span class="hljs-comment"># fix 修复</span><br> 注意：<br> 安装多个包，将包名之间使用逗号隔开即可<br> 特殊语法：所有包都升级到最新版本<br> ansible <span class="hljs-number">10.0</span>.<span class="hljs-number">0.16</span> <span class="hljs-literal">-m</span> apt <span class="hljs-literal">-a</span> <span class="hljs-string">&quot;name=* state=latest&quot;</span><br> 其他选项<br>   autoclean=yes|no <span class="hljs-comment">#清除本地安装包，只删除己卸载的软件的 deb包</span><br>   deb=/path/file.deb <span class="hljs-comment">#指定deb包，可以是本地的，也可以是网络的</span><br>   autoremove=yes|no <span class="hljs-comment">#卸载依赖包,默认no</span><br>   only_upgrade=yes|no <span class="hljs-comment">#仅更新，不安装</span><br>   update_cache=yes|no <span class="hljs-comment">#更新索引</span><br></code></pre></td></tr></table></figure><h2 id="apt-repository模块1"><a href="#apt-repository模块1" class="headerlink" title="apt_repository模块1"></a><strong>apt_repository</strong>模块1</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">这个模块，主要用于配置远程客户端主机上的软件源信息的<br>选项解读<br>  repo=str <span class="hljs-comment">#具体源</span><br>  filename=/path/file <span class="hljs-comment">#具体文件名，默认加到 /etc/apt/sources.list 中</span><br>  state=absent|present <span class="hljs-comment">#absent 删除,present 新增，默认 present</span><br>  update_cache=yes|no <span class="hljs-comment">#yes 更新源，相当于执行 apt-get update  </span><br></code></pre></td></tr></table></figure><h2 id="yum模块"><a href="#yum模块" class="headerlink" title="yum模块"></a><strong>yum</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs powershell">命令格式<br>  yum|apt模块在ansible使用的时候，标准的写法是：<br>  ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> yum|apt <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 ... 属性n=值n&#x27;</span><br> <br>注意：<br>   在安装本地包的时候，使用的是name属性，而且目标主机的本地必须有相应的包<br>   在安装本地包的时候，有时候可能会因为软件依赖的问题，我们可以基于disable_gpg_check=yes来忽略<br> 常见选项<br>   name=packagename <span class="hljs-comment">#指定包名 name1,name2</span><br>   state=absent|installed|latest|present|removed <span class="hljs-comment">#absent|removed 删除,installed|present 安装,latest 升级到最新版</span><br>    list=packagename|installed|updates|available|repos <span class="hljs-comment">#此选项与name选项互斥，</span><br>                               <span class="hljs-comment">#写具体包名是相当于执行 yum list --showduplicates packagename</span><br>    download_dir=/path <span class="hljs-comment">#指定下载目录</span><br>    download_only=yes|no <span class="hljs-comment">#只下载不安装，默认 no</span><br>    update_only=yes|no <span class="hljs-comment">#yes 仅更新,默认no</span><br>    use_backend=auto|yum|yum4|dnf <span class="hljs-comment">#指定真实执行的命令,默认 auto</span><br>    autoremove=yes|no <span class="hljs-comment">#卸载依赖，仅在卸载时生效，默认no</span><br>    disablerepo=repoid <span class="hljs-comment">#排除某些仓库 repoid1,repoid2</span><br>    enablerepo=repoid <span class="hljs-comment">#从指定仓库中安装 repoid1,repoid2</span><br>    validate_certs=yes|no <span class="hljs-comment">#是否对包进行校验，默认yes</span><br>    disable_gpg_check=yes|no <span class="hljs-comment">#是否不对包进行校验，默认no</span><br>    update_only=yes|no <span class="hljs-comment">#只更新不安装,默认no </span><br>    注意：yum 模块本身没有直接的选项来刷新缓存，但你可以通过执行 yum clean all 和 yum makecache 命令来达到这一目的。<br></code></pre></td></tr></table></figure><h2 id="yum-repository模块"><a href="#yum-repository模块" class="headerlink" title="yum_repository模块"></a><strong>yum_repository</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">此模块用来对远程主机上的 yum 仓库配置进行管理<br>常见选项<br>name=repoid <span class="hljs-comment">#repoid</span><br>description=desc <span class="hljs-comment">#描述信息</span><br>baseurl=url <span class="hljs-comment">#仓库地址</span><br>enabled=yes|no <span class="hljs-comment">#是否启用</span><br>gpgcheck=yes|no <span class="hljs-comment">#是否启用gpgcheck，没有默认值，默认跟随 /etc/yum.conf 中的全局配置</span><br>gpgkey=/path/key <span class="hljs-comment">#gpgkey路径</span><br>state=absent|present <span class="hljs-comment">#absent删除， present安装，默认present</span><br>timeout=<span class="hljs-number">30</span> <span class="hljs-comment">#超时时长，默认30s</span><br><br></code></pre></td></tr></table></figure><h2 id="service模块"><a href="#service模块" class="headerlink" title="service模块"></a><strong>service</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">service模块的作用就是操作应用服务的<br>主要选项<br>    enabled:               <span class="hljs-comment"># 设置开机自启动</span><br>    name:                 <span class="hljs-comment"># 服务名称(强制选项).</span><br>    state:                 <span class="hljs-comment"># 设置服务的状态started|stopped|restarted|reloaded</span><br>命令格式<br>  service模块在ansible使用的时候，标准的写法是：<br>  ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> service <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 ... 属性n=值n&#x27;</span>  <br></code></pre></td></tr></table></figure><h1 id="信息模块"><a href="#信息模块" class="headerlink" title="信息模块"></a><strong>信息模块</strong></h1><h2 id="Setup模块"><a href="#Setup模块" class="headerlink" title="Setup模块"></a><strong>Setup</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">setup 模块来收集主机的系统信息，这些 facts 信息可以直接以变量的形式使用<br>重要选项<br>    fact_path:             <span class="hljs-comment"># 设定facts的文件路径</span><br>    <span class="hljs-keyword">filter</span>:               <span class="hljs-comment"># 指定过滤格式，可以正则形式.</span><br>注意<br>   setup这个模块是通过调用ansible的facts组件来获取主机是所有属性信息的<br>   如果主机较多，会影响执行速度，可以使用`gather_facts: no` 来禁止 Ansible 收集 facts 信息<br> 命令格式<br>   setup模块在ansible使用的时候，标准的写法是：<br>          ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> setup <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;属性1=值1 属性2=值2 ... 属性n=值n&#x27;</span><br>注意：<br> 不加 <span class="hljs-literal">-a</span>的话，表示获取目标主机的所有属性信息<br> 过滤信息的规则一定要合理的设计。<br> 这个功能很重要，尤其是后期自动化管理的时候      <br></code></pre></td></tr></table></figure><h2 id="debug模块"><a href="#debug模块" class="headerlink" title="debug模块"></a><strong>debug</strong>模块</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">debug模块的功能主要是我们调试环境时候，用到的一个模块，帮助我们获取一些更详细的信息<br>重要选项<br>    msg:                   <span class="hljs-comment"># 打印自定义消息</span><br>    var:                   <span class="hljs-comment"># 调试变量名称，与msg互斥</span><br>    verbosity:             <span class="hljs-comment"># 显示更详细信息</span><br>注意：<br> 这个功能在命令行模式下作用不大，但是在高级playbook方法中使用的场景作用很大。<br> 命令格式<br> debug模块在ansible使用的时候，标准的写法是：<br>     ansible &lt;目标主机&gt; <span class="hljs-literal">-m</span> debug <span class="hljs-literal">-a</span> <span class="hljs-string">&#x27;name=主机名&#x27;</span>  <br></code></pre></td></tr></table></figure><h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a><strong>相关命令</strong></h1><h2 id="ansible-console"><a href="#ansible-console" class="headerlink" title="ansible-console"></a><strong>ansible-console</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ansible<span class="hljs-literal">-console</span>是让我们以可交互终端形式执行命令，我们可以直接输入该条命令就直接进入到可操作终端.<br>命令简介<br>  console提供了一些常见的应用命令，效果如下：<br>    设置并发数：forks n 例如：forks <span class="hljs-number">10</span><br>    切换主机组：<span class="hljs-built_in">cd</span> group_name 例如：<span class="hljs-built_in">cd</span> web<br>    列出当前组主机列表：list<br>    列出所有的内置命令：?或help<br>    退出：<span class="hljs-keyword">exit</span> <br></code></pre></td></tr></table></figure><h2 id="ansible-playbook"><a href="#ansible-playbook" class="headerlink" title="ansible-playbook"></a><strong>ansible-playbook</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ansible<span class="hljs-literal">-playbook</span>命令是我们接触ansible的一个高级命令，而且使用频率仅次于ansible命令，工作中的很多高级动作的操作，都是通过ansible<span class="hljs-literal">-playbook</span>命令完成的，ansible<span class="hljs-literal">-playbook</span>操作的对象其实是一个yaml文件，这个文件中定义好了我们想要做的一切事情，ansible<span class="hljs-literal">-playbook</span> 执行 yaml 文件就相当于自动化的执行了大量的ansible命令。<br>常见的重要参数<br>     Options: <span class="hljs-comment"># 基本参数</span><br>       <span class="hljs-literal">-C</span>, <span class="hljs-literal">--check</span>         <span class="hljs-comment"># 检查文件执行效果，可以理解为语法检查</span><br>       <span class="hljs-literal">-l</span> SUBSET, <span class="hljs-literal">--limit</span>=SUBSET <span class="hljs-comment"># 限制目标主机</span><br>       <span class="hljs-literal">--list-hosts</span>         <span class="hljs-comment"># 列出可用主机</span><br>       <span class="hljs-literal">--list-tags</span>           <span class="hljs-comment"># 列出可用标签</span><br>       <span class="hljs-literal">--list-tasks</span>         <span class="hljs-comment"># 列出所有任务</span><br>       <span class="hljs-literal">--step</span>               <span class="hljs-comment"># 设定任务执行步骤，一步一步的执行，用于调试场景</span><br>       <span class="hljs-literal">--syntax-check</span> <span class="hljs-comment"># 语法检查</span><br>       <span class="hljs-literal">-t</span> TAGS, <span class="hljs-literal">--tags</span>=TAGS <span class="hljs-comment"># 设定标签</span><br>       Connection Options: <span class="hljs-comment"># 连接参数</span><br>       <span class="hljs-literal">-k</span>, <span class="hljs-literal">--ask-pass</span>     <span class="hljs-comment"># 设定连接密码</span><br>   <br>       Privilege Escalation Options: <span class="hljs-comment"># 提权选项</span><br>       <span class="hljs-literal">-b</span>, <span class="hljs-literal">--become</span>       <span class="hljs-comment"># 切换角色权限</span><br>       <span class="hljs-literal">-K</span>, <span class="hljs-literal">--ask-become-pass</span> <span class="hljs-comment"># 提权用户密码</span><br></code></pre></td></tr></table></figure><h2 id="ansible-vault"><a href="#ansible-vault" class="headerlink" title="ansible-vault"></a><strong>ansible-vault</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">yaml文件中有很多敏感的信息，不想丢失安全<br>生产中的某些敏感信息才会使用这种方式。<br>ansible<span class="hljs-literal">-vault</span> 命令的作用就是采用安全加密的方式来操作相关文件。<br><br></code></pre></td></tr></table></figure><h2 id="ansible-galaxy"><a href="#ansible-galaxy" class="headerlink" title="ansible-galaxy"></a><strong>ansible-galaxy</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">这个命令主要是罗列ansible的第三方共享资源的专用命令，它给我们提供了非常多的模板信息<br>常见的操作命令<br>    delete 删除 import 导入 info 查看信息 init 本地初始化 install 安装<br>    list 罗列 login 登录 remove 移除 search 搜索 setup 启动<br>命令格式<br>  列出所有已安装的galaxy 功能角色<br>    ansible<span class="hljs-literal">-galaxy</span> list &lt;username.role_name&gt;<br> 注意：<br> 如果不加username.role_name表示列出所有，如果指定表示只看指定的内容 <br>  <br>  下载 galaxy 功能角色<br>    ansible<span class="hljs-literal">-galaxy</span> install username.role_name<br> 注意：<br> 他会自动从互联网上下载我们想要的内容，包含大量yaml格式的文件<br> 下载的内容在 <span class="hljs-string">&quot;/etc/ansible/roles/功能角色名&quot;</span> 路径下，<br> 原因在于ansible的配置文件中的<span class="hljs-string">&quot;roles_path&quot;</span>属性决定的<br></code></pre></td></tr></table></figure><h1 id="Playbook"><a href="#Playbook" class="headerlink" title="Playbook"></a><strong>Playbook</strong></h1><h2 id="playbook基础"><a href="#playbook基础" class="headerlink" title="playbook基础"></a><strong>playbook</strong>基础</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">playbook 其实就是一个自动化执行ansible命令的方式<br><br>playbook 是有一个一个的任务组合而成<br>playbook 中的指令都是基于ansible的命令演变过来的<br>playbook 的专用执行命令是 ansible<span class="hljs-literal">-playbook</span><br></code></pre></td></tr></table></figure><p>!!!!<img src="/../image/Ansible%E5%9F%BA%E7%A1%80/image-20250301174321436.png"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ansible在执行playbook的时候，执行效果具有幂等性(即一个命令执行多次与执行一次效果一样)<br><br></code></pre></td></tr></table></figure><h2 id="YAML基础"><a href="#YAML基础" class="headerlink" title="YAML基础"></a><strong>YAML</strong>基础</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">YAML特点<br>  YAML由于是一种特殊的描述性语言，所以它<br>   可读性较好、表达能力强、扩展性好，易于实现<br>  YAML整合了多种语言的优势,所以它<br>   具有通用数据类型、执行方式好、与脚本语言的交互性好  <br></code></pre></td></tr></table></figure><h2 id="三种常见的数据格式"><a href="#三种常见的数据格式" class="headerlink" title="三种常见的数据格式"></a><strong>三种常见的数据格式</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">XML (eXtensible Markup Language)<br>  XML 是一种标记语言，旨在传输和存储数据。主要用于数据交换和配置<br>JSON (JavaScript Object Notation)<br>  JSON 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。主要用来数据交换和配置，不支持注释。<br>YAML (YAML Ain<span class="hljs-string">&#x27;t Markup Language)</span><br><span class="hljs-string">  YAML 是一种人类可读的数据序列化标准，广泛用于配置文件和数据交换。YAML 的目标是简洁、易读，并且具有一致性。主要用来配置，大小写敏感，不支持tab。</span><br><span class="hljs-string"></span><br><span class="hljs-string">数据格式特点</span><br><span class="hljs-string">  大小写敏感</span><br><span class="hljs-string">  使用缩进表示层级关系</span><br><span class="hljs-string">  缩进时不允许使用Tab键，只允许使用空格。</span><br><span class="hljs-string">  缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</span><br><span class="hljs-string">    # 表示注释，从这个字符一直到行尾，都会被解析器忽略</span><br><span class="hljs-string">  文件内容分隔符&quot;---&quot;</span><br><span class="hljs-string">    简单来说，多个文件合并在一个文件中的的分隔符号，这属于yaml语法的问题，</span><br><span class="hljs-string">    但可能因为ansible的插件原因，不推荐将多个ansible playbook写到一个yaml文件中  </span><br><span class="hljs-string">  </span><br></code></pre></td></tr></table></figure><h2 id="基本样式一：YAML-Maps"><a href="#基本样式一：YAML-Maps" class="headerlink" title="基本样式一：YAML Maps"></a>基本样式一：YAML Maps</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">它其实就是一个键值对，键和值中间使用<span class="hljs-string">&quot;冒号+空格&quot;</span>隔开。<br>        格式：<br>            键: 值<br>        示例：<br>            app: mysql<br>这种基本样式，还有一种变种形式，就是值的本身就是一个键值对，两层之间使用两个空格表示层级关系<br> 格式：<br>            键:<br>              值-键：值-值<br> 示例：<br>            metadata:<br>              name: mysql<br></code></pre></td></tr></table></figure><h2 id="基本样式二：YAML-Lists"><a href="#基本样式二：YAML-Lists" class="headerlink" title="基本样式二：YAML Lists"></a>基本样式二：YAML Lists</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs powershell">其实这也是一种键值对，只不过它的值是一个列表形式。<br>    特点：<br>        <span class="hljs-number">1</span>、键和冒号为一行，值为下一行<br>        <span class="hljs-number">2</span>、键和值有层级关系，使用两个空格表示层级关系<br>        <span class="hljs-number">3</span>、列表多元素之间是同级关系，使用 - 表示<br>格式：<br>        键:<br>          - 值a1<br>            值a2<br>          - 值b1<br>            值b2<br>          ... <br>    示例：<br>        args:<br>         - <span class="hljs-built_in">sleep</span><br>         - <span class="hljs-string">&quot;1000&quot;</span><br>         - message<br>         <br></code></pre></td></tr></table></figure><h2 id="playbook常见组件"><a href="#playbook常见组件" class="headerlink" title="playbook常见组件"></a><strong>playbook</strong>常见组件</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">一个playbook 中由多个组件组成,其中所用到的常见组件类型如下:<br> Hosts   执行的远程主机列表<br> Tasks   任务集,由多个task的元素组成的列表实现,每个task是一个字典<br> Variables 内置变量或自定义变量在playbook中调用<br> Templates  模板，可替换模板文件中的变量并实现一些简单逻辑的文件<br> Handlers  和 notify 结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行<br> tags 标签  指定某条任务执行，用于选择运行playbook中的部分代码。ansible具有幂等性，因此会<br>自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断<br><br>个完整的代码块功能需最少元素需包括 name 和 task,一个name只能包括一个task<br></code></pre></td></tr></table></figure><h2 id="hosts属性"><a href="#hosts属性" class="headerlink" title="hosts属性"></a><strong>hosts</strong>属性</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">由于hosts的配置目的与ansible的主机列表文件目的一致，所以他们的编写方法也一样，主要有这么几种表<br>示样式：<br>单个主机：<br>    <span class="hljs-literal">-hosts</span>: <span class="hljs-number">192.168</span>.<span class="hljs-number">8.14</span><br>    <span class="hljs-literal">-hosts</span>: master.ansible.com<br>多个主机<br>    <span class="hljs-literal">-hosts</span>: <span class="hljs-number">192.168</span>.<span class="hljs-number">8</span>.*<br>    <span class="hljs-literal">-hosts</span>: *.ansible.com<br>特定主机<br>    <span class="hljs-literal">-hosts</span>: web:mysql<br>    <span class="hljs-literal">-hosts</span>: web:&amp;mysql<br>    <span class="hljs-literal">-hosts</span>: web:!mysql<br>注意:<br>    如果主机数量过多的话，我们可以通过 serial 属性来限制一次多少台主机来执行任务，从而减轻所有任务执行时候的并行压力。<br> serial: <span class="hljs-string">&quot;20%&quot;</span>   <span class="hljs-comment"># 每次只同时处理20%的主机</span><br> serial: <span class="hljs-string">&quot;2&quot;</span>   <span class="hljs-comment"># 每次只同时处理2台主机</span><br></code></pre></td></tr></table></figure><h2 id="remote-user属性"><a href="#remote-user属性" class="headerlink" title="remote_user属性"></a><strong>remote_user</strong>属性</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">指定这些ansible指令以什么样的身份到目标主机执行，这个属性就是remote_user。<br>   用户身份虽然简单，但是它不仅仅涉及到了登录用户，也涉及到了用户在执行命令时候的权限控制，即sudo的方式<br>   remote_user 的作用就类似于ansible命令中 <span class="hljs-string">&quot;-u 登录用户&quot;</span> + <span class="hljs-string">&quot;-k 登录密码&quot;</span> + <span class="hljs-string">&quot;-K 提权密码&quot;</span> 的效果<br>属性样式<br>  由于playbook是由大量的功能任务组成的，而这些功能任务有可能在不同的目标主机上以不同的用户什么来运行，所以在playbook中remote_user基于使用范围和目的的不同，有两种表现形式。<br><br></code></pre></td></tr></table></figure><h2 id="tasks属性"><a href="#tasks属性" class="headerlink" title="tasks属性"></a><strong>tasks</strong>属性</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell"> playbook文件的主要作用就是实现各种各样的功能，每一个功能都是有大量的ansible指令来组成，所<br>以对于playbook来说，每一个特定的ansible动作都是一个子功能任务，所以playbook的功能主体就是大<br>量的task列表。而且这些任务在执行的时候有一个非常重要的特性:幂等的。简单来说就是执行多次和执行一<br>次效果一样。<br> playbook在执行的时候，根据task列表中的顺序，逐个在hosts的目标主机上执行，默认情况下，任何一个任务中途发生错误，整个任务就自动中断。所以默认的task在执行的时候有一个隐患：在某些条件场景下的逻辑感不强。<br>我们后序有相应的属性来解决这种隐患：notify+handler<br><br>每一个具体的task主要有两部分组成：<br> task名称：通过name属性来设定该任务中的子命令的名称，建议详细一点点<br> task动作：ansible命令实现特定功能的模块及其使用方法<br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面相对象</title>
    <link href="/2024/02/19/%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/02/19/%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="面相对象"><a href="#面相对象" class="headerlink" title="面相对象"></a>面相对象</h1><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p>&#x20;类的理解</p><ol><li>类是对现实生活中一类具有共同属性和行为的事物的抽象</li><li>类是对象的数据类型，类是具有相同属性和行为的一组对象的集合</li><li>简单理解：类就是对现实事物的一种描述</li></ol><p>&#x20;类的组成</p><ol><li>属性：指事物的特征.</li><li>行为：指事物能执行的操作.</li></ol><p>类和对象的关系</p><p>类：类是对现实生活中一类具有共同属性和行为的事物的抽象</p><p>对象：是能够看得到摸的着的真实存在的实体</p><p>类的定义</p><p>类的组成是由属性和行为两部分组成</p><ol><li>属性：在类中通过成员变量来体现</li><li>行为：在类中通过成员方法来体现</li></ol><p>代码格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class 类名 &#123;<br>  // 成员变量<br>  变量1的数据类型 变量1；<br>  变量2的数据类型 变量2;<br>  …<br>  // 成员方法<br>  方法1;<br>  方法2;  <br>&#125;<br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Phone &#123;<br>       String brand;<br>       double price;<br>       public void call()&#123;<br>           System.out.println(&quot;打电话&quot;);<br>       &#125;<br>    public void playGame()&#123;<br>        System.out.println(&quot;玩游戏&quot;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>对象</p><p>代码格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">类名 对象名 = new 类名();<br></code></pre></td></tr></table></figure><p>调用成员格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">对象名.成员变量<br>对象名.成员方法();<br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class PhoneTest &#123;<br>    public static void main(String[] args) &#123;<br>        Phone p=new Phone();<br>        p.brand=&quot;小米&quot;;<br>        p.price=1010;<br>        System.out.println(p.brand);<br>        System.out.println(p.price);<br>        p.call();<br>        p.playGame();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../image/%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1/image_p0aG6Hkxdq.png"></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ol><li><p>封装概述 是面向对象三大特征之一（封装，继承，多态）</p><p><strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为</strong></p></li><li><p>封装代码实现 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 .成员变量private</p></li></ol><h3 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h3><p>private是一个修饰符，可以用来修饰成员（成员变量，成员方法）</p><ul><li>被private修饰的成员，只能在本类进行访问，针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作<ul><li>提供“get变量名()”方法，用于获取成员变量的值，方法用public修饰</li><li>提供“set变量名(参数)”方法，用于设置成员变量的值，方法用public修饰</li></ul></li></ul><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Student &#123;<br>    private String name;<br>    private int age;<br>    private String gender;<br>    public void setName(String n)&#123;<br>        name=n;<br>    &#125;<br>    public String getName()&#123;<br>        return name;<br>    &#125;<br>    public void setAge(int a)&#123;<br>        if(a&gt;=18&amp;&amp;a&lt;=50)&#123;<br>           age =a;<br>        &#125;else&#123;<br>            System.out.println(&quot;非法参数&quot;);<br>        &#125;<br><br>    &#125;<br>    public int getAge()&#123;<br>        return age;<br>    &#125;<br>    public void setGender(String g )&#123;<br>        gender=g ;<br>    &#125;<br>    public String getGender()&#123;<br>        return gender;<br>    &#125;<br>    public void sleep() &#123;<br>        System.out.println(&quot;在睡觉&quot;);<br>    &#125;<br><br>    public void learn() &#123;<br>        System.out.println(&quot;在学习&quot;);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class StudentTest &#123;<br>    public static void main(String[] args) &#123;<br>        Student s1=new Student();<br>      s1.setName(&quot;我到后&quot;);<br>      s1.setAge(18);<br>      s1.setGender(&quot;男&quot;);<br>        System.out.println(s1.getName());<br>        System.out.println(s1.getAge());<br>        System.out.println(s1.getGender());<br>        s1.sleep();<br>        s1.learn();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../image/%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1/image_MfBAyUa5eS.png"></p><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>this修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）</p><ol><li>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量</li><li>方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量</li></ol><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Student &#123;<br>    private String name;<br>    private int age;<br><br>    public void setName(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    public String getName() &#123;<br>        return name;<br>    &#125;<br><br>    public void setAge(int age) &#123;<br>        this.age = age;<br>    &#125;<br><br>    public int getAge() &#123;<br>        return age;<br>    &#125;<br><br>    public void show() &#123;<br>        System.out.println(name + &quot;,&quot; + age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法是一种特殊的方法</p><ul><li>作用：创建对象 Student stu &#x3D; <strong>new Student();</strong></li><li>代码格式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class 类名&#123;<br>​        修饰符 类名( 参数 ) &#123;<br>​        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>功能：主要是完成对象数据的初始化</li><li>示例代码：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">class Student &#123;<br>    private String name;<br>    private int age;<br>    public Student() &#123;<br>        System.out.println(&quot;无参构造方法&quot;);<br>    &#125;<br>    public void show() &#123;<br>        System.out.println(name + &quot;,&quot; + age);<br>    &#125;<br>&#125;<br>public class StudentDemo &#123;<br>    public static void main(String[] args) &#123;<br>        Student s = new Student();<br>        s.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="标准类"><a href="#标准类" class="headerlink" title="标准类"></a>标准类</h4><p>① 类名需要见名知意</p><p>② 成员变量使用private修饰</p><p>③ 提供至少两个构造方法</p><ul><li>无参构造方法</li><li>带全部参数的构造方法</li></ul><p>④ get和set方法</p><p>提供每一个成员变量对应的setXxx()&#x2F;getXxx()</p><p>⑤ 如果还有其他行为，也需要写上</p><h3 id="三种情况的对象内存图"><a href="#三种情况的对象内存图" class="headerlink" title="三种情况的对象内存图"></a>三种情况的对象内存图</h3><p><img src="/../image/%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1/image_3VTiak6Czd.png"></p><p><img src="/../image/%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1/image_kzqnk6EB5g.png"></p><p><img src="/../image/%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1/image_IlraknyYxx.png"></p><p>总结:</p><p>多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份</p><h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><ol><li>类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）</li><li>内存中位置不同：成员变量（堆内存）局部变量（栈内存）</li><li>生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）</li><li>初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象进阶</title>
    <link href="/2024/02/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"/>
    <url>/2024/02/13/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h1><h1 id="static关键字-x20"><a href="#static关键字-x20" class="headerlink" title="static关键字  &#x20;"></a>static关键字  &#x20;</h1><p>Java中成员（<strong>变量和方法</strong>）等是存在所属性的，Java是通过static关键字来区分的。<strong>static关键字在Java开发非常的重要，对于理解面向对象非常关键。</strong></p><p>关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被static修饰的成员是<strong>属于类</strong>的是放在静态区中，没有static修饰的成员变量和方法则是<strong>属于对象</strong>的。上面案例中的成员变量都是没有static修饰的，所以属于每个对象。</p><h2 id="x20-定义格式和使用-x20"><a href="#x20-定义格式和使用-x20" class="headerlink" title="&#x20;定义格式和使用&#x20;"></a>&#x20;定义格式和使用&#x20;</h2><p>static是静态的意思。 static可以修饰成员变量或者修饰方法。</p><h3 id="x20-静态变量及其访问"><a href="#x20-静态变量及其访问" class="headerlink" title="&#x20;静态变量及其访问"></a>&#x20;静态变量及其访问</h3><p>有static修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为<strong>类变量</strong>或者<strong>静态成员变量</strong>。 直接用  类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。</p><p><strong>定义格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">修饰符 static 数据类型 变量名 = 初始值；    <br></code></pre></td></tr></table></figure><p>示例</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Student &#123;<br>    public static String schoolName = &quot;1234&quot;； // 属于类，只有一份。<br>    // .....<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>静态成员变量的访问:</strong></p><p><strong>格式：类名.静态变量</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">public static void  main(String[] args)&#123;<br>    System.out.println(Student.schoolName);<br>    Student.schoolName = &quot;1234&quot;;<br>    System.out.println(Student.schoolName);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例变量及其访问"><a href="#实例变量及其访问" class="headerlink" title="实例变量及其访问"></a>实例变量及其访问</h3><p>无static修饰的成员变量属于每个对象的，  这个成员变量叫<strong>实例变量</strong>，之前写成员变量就是实例成员变量。</p><p><strong>需要注意的是</strong>：实例成员变量属于每个对象，必须创建类的对象才可以访问。  &#x20;</p><p><strong>格式：对象.实例成员变量</strong></p><h3 id="静态方法及其访问"><a href="#静态方法及其访问" class="headerlink" title="静态方法及其访问"></a>静态方法及其访问</h3><p>有static修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为<strong>类方法或者</strong>静态方法 **。 直接用  类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。</p><p>与静态成员变量一样，静态方法也是直接通过<strong>类名.方法名称</strong>即可访问。</p><p><strong>示例</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Student&#123;<br>    public static String schoolName = &quot;1234&quot;；<br>    public static void study()&#123;<br>      System.out.println(&quot;123456&quot;);   <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>静态成员变量的访问:</strong></p><p><strong>格式：类名.静态方法</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">public static void  main(String[] args)&#123;<br>    Student.study();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实例方法及其访问"><a href="#实例方法及其访问" class="headerlink" title="实例方法及其访问"></a>实例方法及其访问</h3><p>无static修饰的成员方法属于每个对象的，这个成员方法也叫做<strong>实例方法</strong>。</p><p><strong>需要注意的是</strong>：实例方法是属于每个对象，必须创建类的对象才可以访问。 &#x20;</p><p><strong>格式：对象.实例方法</strong></p><p><strong>示例</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Student &#123;<br>    private String name ;<br>    public void run()&#123;<br>        System.out.println(&quot;学生可以跑步&quot;);<br>    &#125;<br>    public  void sleep()&#123;<br>        System.out.println(&quot;学生睡觉&quot;);<br>    &#125;<br>    public static void study()&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">public static void main(String[] args)&#123;<br>    Student stu = new Student ;<br>    stu.name = &quot;张三&quot;;<br>    // Student.sleep();<br>    stu.sleep();<br>    stu.run();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1.当 static修饰成员变量或者成员方法时，该变量称为<strong>静态变量</strong>，该方法称为<strong>静态方法</strong>。该类的每个对象都<strong>共享</strong>同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。</p><p>2.无static修饰的成员变量或者成员方法，称为<strong>实例变量，实例方法</strong>，实例变量和实例方法必须创建类的对象，然后通过对象来访问。</p><p>3.static修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。</p><p>4.无static修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。</p><h1 id="继承-x20"><a href="#继承-x20" class="headerlink" title="继承&#x20;"></a>继承&#x20;</h1><h3 id="继承的含义"><a href="#继承的含义" class="headerlink" title="继承的含义"></a>继承的含义</h3><p>继承描述的是事物之间的所属关系，这种关系是：<code>is-a</code> 的关系。例如，兔子属于食草动物，食草动物属于动物。可见，父类更通用，子类更具体。我们通过继承，可以使多种事物之间形成一种关系体系。</p><p><strong>继承</strong>：就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象可以直接具有与父类相同的属性、相同的行为。子类可以直接访问父类中的<strong>非私有</strong>的属性和行为。</p><h3 id="x20-继承的好处"><a href="#x20-继承的好处" class="headerlink" title="&#x20;继承的好处"></a>&#x20;继承的好处</h3><ol><li>提高<strong>代码的复用性</strong>（减少代码冗余，相同代码重复利用）。</li><li>使类与类之间产生了关系。</li></ol><h2 id="x20-继承的格式"><a href="#x20-继承的格式" class="headerlink" title="&#x20;继承的格式"></a>&#x20;继承的格式</h2><p>通过 extends 关键字，可以声明一个子类继承另外一个父类，定义格式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">class 父类 &#123;<br>  ...<br>&#125;<br><br>class 子类 extends 父类 &#123;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：Java是单继承的，一个类只能继承一个直接父类，跟现实世界很像，但是Java中的子类是更加强大的。</strong></p><h3 id="案例代码实现"><a href="#案例代码实现" class="headerlink" title="案例代码实现"></a>案例代码实现</h3><p><strong>1.父类Human类</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Human &#123;<br>   private String name ;<br>   private int age ;<br>   public String getName() &#123;<br>       return name;<br>   &#125;<br><br>   public void setName(String name) &#123;<br>       this.name = name;<br>   &#125;<br>   public int getAge() &#123;<br>       return age;<br>   &#125;<br>   public void setAge(int age) &#123;<br>       this.age = age;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.子类Teacher类</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Teacher extends Human &#123;<br>    private double salary ;<br>    public void teach()&#123;<br>        System.out.println(&quot;老师在认真教技术！&quot;)；<br>    &#125;<br>    public double getSalary() &#123;<br>        return salary;<br>    &#125;<br>    public void setSalary(double salary) &#123;<br>        this.salary = salary;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.子类Student类</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Student extends Human&#123;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.子类BanZhuren类</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Teacher extends Human &#123;<br>    private double salary ;<br><br>    public void admin()&#123;<br>        System.out.println(&quot;班主任强调纪律问题！&quot;)；<br>    &#125;<br>    public double getSalary() &#123;<br>        return salary;<br>    &#125;<br>    public void setSalary(double salary) &#123;<br>        this.salary = salary;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>1.继承实际上是子类相同的属性和行为可以定义在父类中，子类特有的属性和行为由自己定义，这样就实现了相同属性和行为的重复利用，从而提高了代码复用。</p><p>2.子类继承父类，就可以直接得到父类的成员变量和方法。是否可以继承所有成分呢？请看下节！</p><h2 id="x20-子类不能继承的内容"><a href="#x20-子类不能继承的内容" class="headerlink" title="&#x20;子类不能继承的内容"></a>&#x20;子类不能继承的内容</h2><p>并不是父类的所有内容都可以给子类继承的：</p><p><strong>子类不能继承父类的构造方法。</strong></p><p><strong>值得注意的是子类可以继承父类的私有成员（成员变量，方法），只是子类无法直接访问而已，可以通过getter&#x2F;setter方法访问父类的private成员变量。</strong></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public static void main(String[] args) &#123;<br>               Zi z = new Zi();<br>               System.out.println(z.num1);<br>               System.out.println(z.getNum2());<br>               z.show1();<br>           &#125;<br>       &#125;<br>       class Fu &#123;<br>           public int num1 = 10;<br>           private int num2 = 20;<br>           public void show1() &#123;<br>               System.out.println(&quot;show1&quot;);<br>           &#125;<br>           private void show2() &#123;<br>               System.out.println(&quot;show2&quot;);<br>           &#125;<br>           public int getNum2() &#123;<br>               return num2;<br>           &#125;<br>           public void setNum2(int num2) &#123;<br>               this.num2 = num2;<br>           &#125;<br>       &#125;<br>       class Zi extends Fu &#123;<br>       &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/../image/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/image_vBfAwXmsQU.png"></p><h3 id="super访问父类成员变量"><a href="#super访问父类成员变量" class="headerlink" title="super访问父类成员变量"></a>super访问父类成员变量</h3><p>子父类中出现了同名的成员变量时，在子类中需要访问父类中非私有成员变量时，需要使用<code>super</code> 关键字，修饰父类成员变量，类似于之前学过的 <code>this</code> 。</p><p>需要注意的是：<strong>super代表的是父类对象的引用，this代表的是当前对象的引用。</strong></p><p><strong>使用格式：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">super.父类成员变量名<br></code></pre></td></tr></table></figure><h2 id="继承后的特点—成员方法"><a href="#继承后的特点—成员方法" class="headerlink" title="继承后的特点—成员方法"></a>继承后的特点—成员方法</h2><p>当类之间产生了关系，其中各类中的成员方法，又产生了哪些影响呢？</p><h3 id="x20-成员方法不重名"><a href="#x20-成员方法不重名" class="headerlink" title="&#x20;成员方法不重名"></a>&#x20;成员方法不重名</h3><p>如果子类父类中出现<strong>不重名</strong>的成员方法，这时的调用是<strong>没有影响的</strong>。对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">class Fu &#123;<br>  public void show() &#123;<br>    System.out.println(&quot;Fu类中的show方法执行&quot;);<br>  &#125;<br>&#125;<br>class Zi extends Fu &#123;<br>  public void show2() &#123;<br>    System.out.println(&quot;Zi类中的show2方法执行&quot;);<br>  &#125;<br>&#125;<br>public  class Demo05 &#123;<br>  public static void main(String[] args) &#123;<br>    Zi z = new Zi();<br>    z.show(); <br>    z.show2();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成员方法重名"><a href="#成员方法重名" class="headerlink" title="成员方法重名"></a>成员方法重名</h3><p>如果子类父类中出现<strong>重名</strong>的成员方法，则创建子类对象调用该方法的时候，子类对象会优先调用自己的方法。</p><p>代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">class Fu &#123;<br>  public void show() &#123;<br>    System.out.println(&quot;Fu show&quot;);<br>  &#125;<br>&#125;<br>class Zi extends Fu &#123;<br>  public void show() &#123;<br>    System.out.println(&quot;Zi show&quot;);<br>  &#125;<br>&#125;<br>public class ExtendsDemo05&#123;<br>  public static void main(String[] args) &#123;<br>    Zi z = new Zi();<br>    z.show();  // Zi show<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="x20-方法重写"><a href="#x20-方法重写" class="headerlink" title="&#x20;方法重写"></a>&#x20;方法重写</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>方法重写</strong> ：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。<strong>声明不变，重新实现</strong>。</p><h3 id="使用场景与案例"><a href="#使用场景与案例" class="headerlink" title="使用场景与案例"></a>使用场景与案例</h3><p>发生在子父类之间的关系。<br>子类继承了父类的方法，但是子类觉得父类的这方法不足以满足自己的需求，子类重新写了一个与父类同名的方法，以便覆盖父类的该方 法。</p><p>例如：定义了一个动物类代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Animal  &#123;<br>    public void run()&#123;<br>        System.out.println(&quot;动物跑的很快！&quot;);<br>    &#125;<br>    public void cry()&#123;<br>        System.out.println(&quot;动物都可以叫~~~&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后定义一个猫类，猫可能认为父类cry()方法不能满足自己的需求</p><p>代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Cat extends Animal &#123;<br>    public void cry()&#123;<br>        System.out.println(&quot;喵喵喵!&quot;);<br>    &#125;<br>&#125;<br><br>public class Test &#123;<br>  public static void main(String[] args) &#123;<br>        Cat ddm = new Cat()；<br>        ddm.run();<br>        ddm.cry();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="x20-注意事项"><a href="#x20-注意事项" class="headerlink" title="&#x20;注意事项"></a>&#x20;注意事项</h3><ol><li>方法重写是发生在子父类之间的关系。</li><li>子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</li><li>子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</li></ol><h2 id="x20-继承后的特点—构造方法"><a href="#x20-继承后的特点—构造方法" class="headerlink" title="&#x20;继承后的特点—构造方法"></a>&#x20;继承后的特点—构造方法</h2><h3 id="x20-引入"><a href="#x20-引入" class="headerlink" title="&#x20;引入"></a>&#x20;引入</h3><p>当类之间产生了关系，其中各类中的构造方法，又产生了哪些影响呢？</p><ol><li>构造方法的名字是与类名一致的。所以子类是无法继承父类构造方法的。</li><li>构造方法的作用是初始化对象成员变量数据的。所以子类的初始化过程中，必须先执行父类的初始化动作。子类的构造方法中默认有一个<code>super()</code> ，表示调用父类的构造方法，父类成员变量初始化后，才可以给子类使用。</li></ol><p><strong>继承后子类构方法器特点:子类所有构造方法的第一行都会默认先调用父类的无参构造方法</strong></p><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><p>按如下需求定义类:</p><ol><li><p>人类</p><p>成员变量: 姓名,年龄</p><p>成员方法: 吃饭</p></li><li><p>学生类</p><p>成员变量: 姓名,年龄,成绩</p><p>成员方法: 吃饭</p></li></ol><p>示例代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs text">class Person &#123;<br>    private String name;<br>    private int age;<br><br>    public Person() &#123;<br>        System.out.println(&quot;父类无参&quot;);<br>    &#125;<br><br>    // getter/setter省略<br>&#125;<br><br>class Student extends Person &#123;<br>    private double score;<br><br>    public Student() &#123;<br>        //super(); // 调用父类无参,默认就存在，可以不写，必须再第一行<br>        System.out.println(&quot;子类无参&quot;);<br>    &#125;<br>    <br>     public Student(double score) &#123;<br>        //super();  // 调用父类无参,默认就存在，可以不写，必须再第一行<br>        this.score = score;    <br>        System.out.println(&quot;子类有参&quot;);<br>     &#125;<br><br>&#125;<br><br>public class Demo07 &#123;<br>    public static void main(String[] args) &#123;<br>        Student s1 = new Student();<br>        System.out.println(&quot;----------&quot;);<br>        Student s2 = new Student(99.9);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="x20-小结"><a href="#x20-小结" class="headerlink" title="&#x20;小结"></a>&#x20;小结</h3><ul><li>子类构造方法执行的时候，都会在第一行默认先调用父类无参数构造方法一次。</li><li>子类构造方法的第一行都隐含了一个<strong>super()</strong> 去调用父类无参数构造方法，<strong>super()</strong> 可以省略不写。</li></ul><h2 id="super-…-和this-…"><a href="#super-…-和this-…" class="headerlink" title="super(…)和this(…)"></a>super(…)和this(…)</h2><h3 id="x20-super和this的用法格式"><a href="#x20-super和this的用法格式" class="headerlink" title="&#x20;super和this的用法格式"></a>&#x20;super和this的用法格式</h3><p>super和this完整的用法如下，</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">this.成员变量      --    本类的<br>super.成员变量      --    父类的<br><br>this.成员方法名()    --    本类的    <br>super.成员方法名()   --    父类的<br></code></pre></td></tr></table></figure><p>接下来使用调用构造方法格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">super(...) -- 调用父类的构造方法，根据参数匹配确认<br>this(...) -- 调用本类的其他构造方法，根据参数匹配确认<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></p><p><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></p><p>super(..)是根据参数去确定调用父类哪个构造方法的。</p><h3 id="this-…-用法"><a href="#this-…-用法" class="headerlink" title="this(…)用法"></a>this(…)用法</h3><p>this(…)</p><ul><li>默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。</li><li>为了借用其他构造方法的功能。</li></ul><p>代码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class StudentTest &#123;<br>            public static void main(String[] args) &#123;<br>                Student xuGan = new Student();<br>                System.out.println(xuGan.getName()); <br>                System.out.println(xuGan.getAge());<br>                System.out.println(xuGan.getSex());<br>            &#125;<br>        &#125;<br>        class Student&#123;<br>            private String name ;<br>            private int age ;<br>            private char sex ;<br>            public Student() &#123;<br>                // 很弱，我的兄弟很牛逼啊，我可以调用其他构造方法：Student(String name, int age, char sex)<br>                this(&quot;张三&quot;,21,&#x27;男&#x27;);<br>            &#125;<br>            public Student(String name, int age, char sex) &#123;<br>                this.name = name ;<br>                this.age = age   ;<br>                this.sex = sex   ;<br>            &#125;<br>            public String getName() &#123;<br>                return name;<br>            &#125;<br>            public void setName(String name) &#123;<br>                this.name = name;<br>            &#125;<br>            public int getAge() &#123;<br>                return age;<br>            &#125;<br>            public void setAge(int age) &#123;<br>                this.age = age;<br>            &#125;<br>            public char getSex() &#123;<br>                return sex;<br>            &#125;<br>            public void setSex(char sex) &#123;<br>                this.sex = sex;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/image_wQ9dnrUwBN.png"></p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。</strong></li><li><strong>super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</strong></li><li><strong>super(..)和this(…)是根据参数去确定调用父类哪个构造方法的。</strong></li><li>super(..)可以调用父类构造方法初始化继承自父类的成员变量的数据。</li><li>this(..)可以调用本类中的其他构造方法。</li></ul><h2 id="多态的形式"><a href="#多态的形式" class="headerlink" title="多态的形式"></a>多态的形式</h2><p><strong>多态是继封装、继承之后，面向对象的第三大特性。</strong></p><p><strong>多态是出现在继承或者实现关系中的</strong>。</p><p><strong>多态体现的格式</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">父类类型 变量名 = new 子类/实现类构造器;<br>变量名.方法名();<br></code></pre></td></tr></table></figure><p><strong>多态的前提</strong>：有继承关系，子类对象是可以赋值给父类类型的变量。例如Animal是一个动物类型，而Cat是一个猫类型。Cat继承了Animal，Cat对象也是Animal类型，自然可以赋值给父类类型的变量。</p><h2 id="x20-多态的定义和前提"><a href="#x20-多态的定义和前提" class="headerlink" title="&#x20;多态的定义和前提"></a>&#x20;多态的定义和前提</h2><p><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。</p><p>从上面案例可以看出，Cat和Dog都是动物，都是吃这一行为，但是出现的效果（表现形式）是不一样的。</p><p><strong>前提【重点】</strong></p><ol><li>有继承或者实现关系</li><li>方法的重写【意义体现：不重写，无意义】</li><li>父类引用指向子类对象【格式体现】<blockquote><p>父类类型：指子类对象继承的父类类型，或者实现的父接口类型。</p></blockquote></li></ol><h2 id="多态的运行特点"><a href="#多态的运行特点" class="headerlink" title="多态的运行特点"></a>多态的运行特点</h2><p>调用成员变量时：编译看左边，运行看左边</p><p>调用成员方法时：编译看左边，运行看右边</p><p>代码示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">Fu f = new Zi()；<br>//编译看左边的父类中有没有name这个属性，没有就报错<br>//在实际运行的时候，把父类name属性的值打印出来<br>System.out.println(f.name);<br>//编译看左边的父类中有没有show这个方法，没有就报错<br>//在实际运行的时候，运行的是子类中的show方法<br>f.show();<br></code></pre></td></tr></table></figure><h2 id="x20-多态的弊端"><a href="#x20-多态的弊端" class="headerlink" title="&#x20;多态的弊端"></a>&#x20;多态的弊端</h2><p>我们已经知道多态编译阶段是看左边父类类型的，如果子类有些独有的功能，此时<strong>多态的写法就无法访问子类独有功能了</strong>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs text">class Animal&#123;<br>    public  void eat()｛<br>        System.out.println(&quot;动物吃东西！&quot;)<br>    ｝<br>&#125;<br>class Cat extends Animal &#123;  <br>    public void eat() &#123;  <br>        System.out.println(&quot;吃鱼&quot;);  <br>    &#125;  <br>   <br>    public void catchMouse() &#123;  <br>        System.out.println(&quot;抓老鼠&quot;);  <br>    &#125;  <br>&#125;  <br><br>class Dog extends Animal &#123;  <br>    public void eat() &#123;  <br>        System.out.println(&quot;吃骨头&quot;);  <br>    &#125;  <br>&#125;<br><br>class Test&#123;<br>    public static void main(String[] args)&#123;<br>        Animal a = new Cat();<br>        a.eat();<br>        a.catchMouse();//编译报错，编译看左边，Animal没有这个方法<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="x20-引用类型转换"><a href="#x20-引用类型转换" class="headerlink" title="&#x20;引用类型转换"></a>&#x20;引用类型转换</h2><h3 id="x20-为什么要转型"><a href="#x20-为什么要转型" class="headerlink" title="&#x20;为什么要转型"></a>&#x20;为什么要转型</h3><p><strong>多态的写法就无法访问子类独有功能了。</strong></p><p>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，<strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。所以，想要调用子类特有的方法，必须做向下转型。</p><p>回顾基本数据类型转换</p><ul><li>自动转换: 范围小的赋值给范围大的.自动完成:double d &#x3D; 5;</li><li>强制转换: 范围大的赋值给范围小的,强制转换:int i &#x3D; (int)3.14</li></ul><p>​     多态的转型分为向上转型（自动转换）与向下转型（强制转换）两种。</p><h3 id="x20-向上转型（自动转换）"><a href="#x20-向上转型（自动转换）" class="headerlink" title="&#x20;向上转型（自动转换）"></a>&#x20;向上转型（自动转换）</h3><ul><li><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换（自动转换）的过程，这个过程是默认的。<br>当父类引用指向一个子类对象时，便是向上转型。<br>使用格式：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">父类类型  变量名 = new 子类类型();<br>如：Animal a = new Cat();<br></code></pre></td></tr></table></figure><p><strong>原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。</strong> ​<strong>原因是：父类类型相对与子类来说是大范围的类型，Animal是动物类，是父类类型。Cat是猫类，是子类类型。Animal类型的范围当然很大，包含一切动物。</strong> 所以子类范围小可以直接自动转型给父类类型的变量。 所以子类范围小可以直接自动转型给父类类型的变量。</p><h3 id="x20-向下转型（强制转换）"><a href="#x20-向下转型（强制转换）" class="headerlink" title="&#x20;向下转型（强制转换）"></a>&#x20;向下转型（强制转换）</h3><ul><li><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。<br>一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</li></ul><p>使用格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">子类类型 变量名 = (子类类型) 父类变量名;<br>如:Aniaml a = new Cat();<br>   Cat c =(Cat) a;  <br></code></pre></td></tr></table></figure><h3 id="转型的异常"><a href="#转型的异常" class="headerlink" title="转型的异常"></a>转型的异常</h3><p>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Test &#123;<br>    public static void main(String[] args)  <br>        Animal a = new Cat();  <br>        a.eat();                <br>        Dog d = (Dog)a;       <br>        d.watchHouse();       <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="x20-instanceof关键字"><a href="#x20-instanceof关键字" class="headerlink" title="&#x20;instanceof关键字"></a>&#x20;instanceof关键字</h3><p>为了避免ClassCastException的发生，Java提供了 <code>instanceof</code> 关键字，给引用变量做类型的校验，格式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">变量名 instanceof 数据类型 <br>如果变量属于该数据类型或者其子类类型，返回true。<br>如果变量不属于该数据类型或者其子类类型，返回false。<br></code></pre></td></tr></table></figure><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>​包在操作系统中其实就是一个文件夹。<strong>包是用来分门别类的管理技术，不同的技术类放在不同的包下</strong>，方便管理和维护。</p><p><strong>包名的命名规范</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">路径名.路径名.xxx.xxx<br><span class="hljs-comment">// 例如：com.itheima.oa</span><br></code></pre></td></tr></table></figure><ul><li>包名一般是公司域名的倒写。例如：黑马是www.itheima.com,包名就可以定义成com.itheima.技术名称。</li><li>包名必须用”.“连接。</li><li>包名的每个路径名必须是一个合法的标识符，而且不能是Java的关键字。</li></ul><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><p>什么时候需要导包？</p><p>​情况一：在使用Java中提供的非核心包中的类时</p><p>​情况二：使用自己写的其他包中的类时</p><p>什么时候不需要导包？</p><p>​情况一：在使用Java核心包（java.lang）中的类时</p><p>​情况二：在使用自己写的同一个包中的类时</p><h2 id="使用不同包下的相同类怎么办？"><a href="#使用不同包下的相同类怎么办？" class="headerlink" title="使用不同包下的相同类怎么办？"></a>使用不同包下的相同类怎么办？</h2><p>假设demo1和demo2中都有一个Student该如何使用？</p><p>代码示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">//使用全类名的形式即可。<br>//全类名：包名 + 类名<br>//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Reference<br>com.itheima.homework.demo1.Student s1 = new com.itheima.homework.demo1.Student();<br>com.itheima.homework.demo2.Student s2 = new com.itheima.homework.demo2.Student();<br></code></pre></td></tr></table></figure><h2 id="x20-权限修饰符"><a href="#x20-权限修饰符" class="headerlink" title="&#x20;权限修饰符"></a>&#x20;权限修饰符</h2><p>​在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，</p><ul><li>public：公共的，所有地方都可以访问。</li><li>protected：本类 ，本包，其他包中的子类都可以访问。</li><li>默认（没有修饰符）：本类 ，本包可以访问。<br>注意：默认是空着不写，不是default</li><li>private：私有的，当前类可以访问。<br><code>public &gt; protected &gt; 默认 &gt; private</code></li></ul><h2 id="x20-不同权限的访问能力"><a href="#x20-不同权限的访问能力" class="headerlink" title="&#x20;不同权限的访问能力"></a>&#x20;不同权限的访问能力</h2><table><thead><tr><th></th><th>public</th><th>protected</th><th>默认</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一包中的类</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><p>可见，public具有最大权限。private则是最小权限。</p><p>编写代码时，如果没有特殊的考虑，建议这样使用权限：</p><ul><li>成员变量使用<code>private</code> ，隐藏细节。</li><li>构造方法使用<code> public</code> ，方便创建对象。</li><li>成员方法使用<code>public</code> ，方便调用方法。</li></ul><blockquote><p>小贴士：不加权限修饰符，就是默认权限</p></blockquote><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​学习了继承后，我们知道，子类可以在父类的基础上改写父类内容，比如，方法重写。</p><p>如果有一个方法我不想别人去改写里面内容，该怎么办呢？</p><p>Java提供了<code>final</code> 关键字，表示修饰的内容不可变。</p><ul><li><strong>final</strong>：  不可改变，最终的含义。可以用于修饰类、方法和变量。<ul><li>类：被修饰的类，不能被继承。</li><li>方法：被修饰的方法，不能被重写。</li><li>变量：被修饰的变量，有且仅能被赋值一次。</li></ul></li></ul><h2 id="x20-使用方式"><a href="#x20-使用方式" class="headerlink" title="&#x20;使用方式"></a>&#x20;使用方式</h2><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3><p>final修饰的类，不能被继承。</p><p>格式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">final class 类名 &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">final class Fu &#123;<br>&#125;<br>// class Zi extends Fu &#123;&#125; // 报错,不能继承final的类<br></code></pre></td></tr></table></figure><h3 id="x20-修饰方法"><a href="#x20-修饰方法" class="headerlink" title="&#x20;修饰方法"></a>&#x20;修饰方法</h3><p>final修饰的方法，不能被重写。<br>格式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">修饰符 final 返回值类型 方法名(参数列表)&#123;<br>    //方法体<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰变量-成员变量"><a href="#修饰变量-成员变量" class="headerlink" title="修饰变量-成员变量"></a>修饰变量-成员变量</h3><p>成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：</p><ul><li>显示初始化(在定义成员变量的时候立马赋值)（常用）；</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Student &#123;<br>    final int num = 10;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="x20-抽象类"><a href="#x20-抽象类" class="headerlink" title="&#x20;抽象类"></a>&#x20;抽象类</h1><h2 id="x20-概述"><a href="#x20-概述" class="headerlink" title="&#x20;概述"></a>&#x20;概述</h2><h3 id="x20-抽象类引入"><a href="#x20-抽象类引入" class="headerlink" title="&#x20;抽象类引入"></a>&#x20;抽象类引入</h3><p>​父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了(因为子类对象会调用自己重写的方法)。换句话说，父类可能知道子类应该有哪个功能，但是功能具体怎么实现父类是不清楚的（由子类自己决定），父类只需要提供一个没有方法体的定义即可，具体实现交给子类自己去实现。<strong>我们把没有方法体的方法称为抽象方法。Java语法规定，包含抽象方法的类就是抽象类</strong>。</p><ul><li><strong>抽象方法</strong> ： 没有方法体的方法。</li><li><strong>抽象类</strong>：包含抽象方法的类。</li></ul><h2 id="x20-abstract使用格式"><a href="#x20-abstract使用格式" class="headerlink" title="&#x20;abstract使用格式"></a>&#x20;abstract使用格式</h2><p><strong>abstract是抽象的意思，用于修饰方法方法和类，修饰的方法是抽象方法，修饰的类是抽象类。</strong></p><h3 id="x20-抽象方法"><a href="#x20-抽象方法" class="headerlink" title="&#x20;抽象方法"></a>&#x20;抽象方法</h3><p>使用<code>abstract</code> 关键字修饰方法，该方法就成了抽象方法，抽象方法只包含一个方法名，而没有方法体。</p><p>定义格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">修饰符 abstract 返回值类型 方法名 (参数列表)；<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">public abstract void run()；<br></code></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>如果一个类包含抽象方法，那么该类必须是抽象类。<strong>注意：抽象类不一定有抽象方法，但是有抽象方法的类必须定义成抽象类。</strong></p><p>定义格式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">abstract class 类名字 &#123; <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">public abstract class Animal &#123;<br>    public abstract void run()；<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="x20-抽象类的特征"><a href="#x20-抽象类的特征" class="headerlink" title="&#x20;抽象类的特征"></a>&#x20;抽象类的特征</h2><p>抽象类的特征总结起来可以说是 <strong>有得有失</strong></p><p><strong>有得：抽象类得到了拥有抽象方法的能力。</strong></p><p><strong>有失：抽象类失去了创建对象的能力。</strong></p><p>其他成员（构造方法，实例方法，静态方法等）抽象类都是具备的。</p><h2 id="x20-抽象类的细节"><a href="#x20-抽象类的细节" class="headerlink" title="&#x20;抽象类的细节"></a>&#x20;抽象类的细节</h2><p>不需要背，只要当idea报错之后，知道如何修改即可。</p><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。</p><ol><li>抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。<blockquote><p>理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。</p></blockquote></li><li>抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。<blockquote><p>理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。</p></blockquote></li><li>抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。<blockquote><p>理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。</p></blockquote></li><li>抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则子类也必须定义成抽象类，编译无法通过而报错。<blockquote><p>理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。</p></blockquote></li><li>抽象类存在的意义是为了被子类继承。<blockquote><p>理解：抽象类中已经实现的是模板中确定的成员，抽象类不确定如何实现的定义成抽象方法，交给具体的子类去实现。</p></blockquote></li></ol><h2 id="x20-抽象类存在的意义"><a href="#x20-抽象类存在的意义" class="headerlink" title="&#x20;抽象类存在的意义"></a>&#x20;抽象类存在的意义</h2><p>​抽象类存在的意义是为了被子类继承，否则抽象类将毫无意义。抽象类可以强制让子类，一定要按照规定的格式进行重写。</p><h1 id="x20-接口"><a href="#x20-接口" class="headerlink" title="&#x20;接口"></a>&#x20;接口</h1><h2 id="x20-概述-1"><a href="#x20-概述-1" class="headerlink" title="&#x20;概述"></a>&#x20;概述</h2><p><strong>接口是更加彻底的抽象，JDK7之前，包括JDK7，接口中全部是抽象方法。接口同样是不能创建对象的</strong>。</p><h2 id="x20-代码格式"><a href="#x20-代码格式" class="headerlink" title="&#x20;代码格式"></a>&#x20;代码格式</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">//接口的定义格式：<br>interface 接口名称&#123;<br>    // 抽象方法<br>&#125;<br><br>// 接口的声明：interface<br>// 接口名称：首字母大写，满足“驼峰模式”<br></code></pre></td></tr></table></figure><h2 id="接口成分的特点"><a href="#接口成分的特点" class="headerlink" title="接口成分的特点"></a>接口成分的特点</h2><p>在JDK7，包括JDK7之前，接口中的<strong>只有</strong>包含：抽象方法和常量</p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>​       注意：接口中的抽象方法默认会自动加上public abstract修饰程序员无需自己手写！！<br>​       按照规范：以后接口中的抽象方法建议不要写上public abstract。因为没有必要啊，默认会加上。</p><h3 id="x20-常量"><a href="#x20-常量" class="headerlink" title="&#x20;常量"></a>&#x20;常量</h3><p>在接口中定义的成员变量默认会加上： public static final修饰。也就是说在接口中定义的成员变量实际上是一个常量。这里是使用public static final修饰后，变量值就不可被修改，并且是静态化的变量可以直接用接口名访问，所以也叫常量。常量必须要给初始值。常量命名规范建议字母全部大写，多个单词用下划线连接。</p><h2 id="x20-基本的实现"><a href="#x20-基本的实现" class="headerlink" title="&#x20;基本的实现"></a>&#x20;基本的实现</h2><h3 id="x20-实现接口的概述"><a href="#x20-实现接口的概述" class="headerlink" title="&#x20;实现接口的概述"></a>&#x20;实现接口的概述</h3><p>类与接口的关系为实现关系，即<strong>类实现接口</strong>，该类可以称为接口的实现类，也可以称为接口的子类。实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <code> implements</code>关键字。</p><h3 id="x20-实现接口的格式"><a href="#x20-实现接口的格式" class="headerlink" title="&#x20;实现接口的格式"></a>&#x20;实现接口的格式</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>class 类名 implements 接口1,接口2,接口3...&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类实现接口的要求和意义"><a href="#类实现接口的要求和意义" class="headerlink" title="类实现接口的要求和意义"></a>类实现接口的要求和意义</h3><ol><li>必须重写实现的全部接口中所有抽象方法。</li><li>如果一个类实现了接口，但是没有重写完全部接口的全部抽象方法，这个类也必须定义成抽象类。</li><li><strong>意义：接口体现的是一种规范，接口对实现类是一种强制性的约束，要么全部完成接口申明的功能，要么自己也定义成抽象类。这正是一种强制性的规范。</strong></li></ol><h3 id="x20-类与接口基本实现案例"><a href="#x20-类与接口基本实现案例" class="headerlink" title="&#x20; 类与接口基本实现案例"></a>&#x20; 类与接口基本实现案例</h3><p>假如定义一个运动员的<strong>接口</strong>（规范），代码如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text"><br>public interface SportMan &#123;<br>    void run(); // 抽象方法，跑步。<br>    void law(); // 抽象方法，遵守法律。<br>    String compittion(String project);  // 抽象方法，比赛。<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="接口与接口的多继承"><a href="#接口与接口的多继承" class="headerlink" title="接口与接口的多继承"></a>接口与接口的多继承</h2><p>Java中，接口与接口之间是可以多继承的：也就是一个接口可以同时继承多个接口。</p><p><strong>类与接口是实现关系</strong></p><p><strong>接口与接口是继承关系</strong></p><h2 id="扩展：接口的细节"><a href="#扩展：接口的细节" class="headerlink" title="扩展：接口的细节"></a>扩展：接口的细节</h2><ol><li>当两个接口中存在相同抽象方法的时候，该怎么办？</li></ol><blockquote><p>只要重写一次即可。此时重写的方法，既表示重写1接口的，也表示重写2接口的。</p></blockquote><ol><li>实现类能不能继承A类的时候，同时实现其他接口呢？</li></ol><blockquote><p>继承的父类，就好比是亲爸爸一样<br>实现的接口，就好比是干爹一样<br>可以继承一个类的同时，再实现多个接口，只不过，要把接口里面所有的抽象方法，全部实现。</p></blockquote><ol><li>实现类能不能继承一个抽象类的时候，同时实现其他接口呢？</li></ol><blockquote><p>实现类可以继承一个抽象类的同时，再实现其他多个接口，只不过要把里面所有的抽象方法全部重写。</p></blockquote><ol><li>实现类Zi，实现了一个接口，还继承了一个Fu类。假设在接口中有一个方法，父类中也有一个相同的方法。子类如何操作呢？</li></ol><blockquote><p>处理办法一：如果父类中的方法体，能满足当前业务的需求，在子类中可以不用重写。<br>处理办法二：如果父类中的方法体，不能满足当前业务的需求，需要在子类中重写。</p></blockquote><ol><li>如果一个接口中，有10个抽象方法，但是我在实现类中，只需要用其中一个，该怎么办?</li></ol><blockquote><p>可以在接口跟实现类中间，新建一个中间类（适配器类）<br>让这个适配器类去实现接口，对接口里面的所有的方法做空重写。<br>让子类继承这个适配器类，想要用到哪个方法，就重写哪个方法。<br>因为中间类没有什么实际的意义，所以一般会把中间类定义为抽象的，不让外界创建对象</p></blockquote><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h3 id="x20-什么是内部类"><a href="#x20-什么是内部类" class="headerlink" title="&#x20;什么是内部类"></a>&#x20;什么是内部类</h3><p>将一个类A定义在另一个类B里面，里面的那个类A就称为<strong>内部类</strong>，B则称为<strong>外部类</strong>。可以把内部类理解成寄生，外部类理解成宿主。</p><h3 id="x20-什么时候使用内部类"><a href="#x20-什么时候使用内部类" class="headerlink" title="&#x20;什么时候使用内部类"></a>&#x20;什么时候使用内部类</h3><p>一个事物内部还有一个独立的事物，内部的事物脱离外部的事物无法独立使用</p><ol><li>人里面有一颗心脏。</li><li>汽车内部有一个发动机。</li><li>为了实现更好的封装性。</li></ol><h2 id="x20-内部类的分类"><a href="#x20-内部类的分类" class="headerlink" title="&#x20;内部类的分类"></a>&#x20;内部类的分类</h2><p>按定义的位置来分</p><ol><li><strong>成员内部内</strong>，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)</li><li><strong>静态内部类</strong>，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)</li><li><strong>局部内部类</strong>，类定义在方法内</li><li><strong>匿名内部类</strong>，没有名字的内部类，可以在方法中，也可以在类中方法外。</li></ol><h2 id="x20-成员内部类"><a href="#x20-成员内部类" class="headerlink" title="&#x20;成员内部类"></a>&#x20;成员内部类</h2><p><strong>成员内部类特点</strong>：</p><ul><li>无static修饰的内部类，属于外部类对象的。</li><li>宿主：外部类对象。</li></ul><p><strong>内部类的使用格式</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类<br></code></pre></td></tr></table></figure><p><strong>获取成员内部类对象的两种方式</strong>：</p><p>方式一：外部直接创建成员内部类的对象</p><p>方式二：在外部类中定义一个方法提供内部类的对象</p><p><strong>案例演示</strong></p><h2 id="x20-成员内部类的细节"><a href="#x20-成员内部类的细节" class="headerlink" title="&#x20;成员内部类的细节"></a>&#x20;成员内部类的细节</h2><p>编写成员内部类的注意点：</p><ol><li>成员内部类可以被一些修饰符所修饰，比如： private，默认，protected，public，static等</li><li>在成员内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。</li><li>创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。（请参见3.6节的内存图）</li></ol><p>详解：</p><p>​内部类被private修饰，外界无法直接获取内部类的对象，只能通过3.3节中的方式二获取内部类的对象</p><p>​被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象</p><p>​内部类被static修饰是成员内部类中的特殊情况，叫做静态内部类下面单独学习。</p><p>​内部类如果想要访问外部类的成员变量，外部类的变量必须用final修饰，JDK8以前必须手动写final，JDK8之后不需要手动写，JDK默认加上。</p><h2 id="x20-静态内部类"><a href="#x20-静态内部类" class="headerlink" title="&#x20;静态内部类"></a>&#x20;静态内部类</h2><p><strong>静态内部类特点</strong>：</p><ul><li>静态内部类是一种特殊的成员内部类。</li><li>有static修饰，属于外部类本身的。</li><li>总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类。</li><li><strong>拓展1</strong>:静态内部类可以直接访问外部类的静态成员。</li><li><strong>拓展2</strong>:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象。</li><li><strong>拓展3</strong>:静态内部类中没有银行的Outer.this。</li></ul><p><strong>内部类的使用格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">外部类.内部类。<br></code></pre></td></tr></table></figure><p><strong>静态内部类对象的创建格式</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">外部类.内部类  变量 = new  外部类.内部类构造器;<br></code></pre></td></tr></table></figure><p><strong>调用方法的格式：</strong></p><ul><li>调用非静态方法的格式：先创建对象，用对象调用</li><li>调用静态方法的格式：外部类名.内部类名.方法名();</li></ul><p><strong>案例演示</strong>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs text">// 外部类：Outer01<br>class Outer01&#123;<br>    private static  String sc_name = &quot;黑马程序&quot;;<br>    // 内部类: Inner01<br>    public static class Inner01&#123;<br>        // 这里面的东西与类是完全一样的。<br>        private String name;<br>        public Inner01(String name) &#123;<br>            this.name = name;<br>        &#125;<br>        public void showName()&#123;<br>            System.out.println(this.name);<br>            // 拓展:静态内部类可以直接访问外部类的静态成员。<br>            System.out.println(sc_name);<br>        &#125;<br>    &#125;<br>&#125;<br><br>public class InnerClassDemo01 &#123;<br>    public static void main(String[] args) &#123;<br>        // 创建静态内部类对象。<br>        // 外部类.内部类  变量 = new  外部类.内部类构造器;<br>        Outer01.Inner01 in  = new Outer01.Inner01(&quot;张三&quot;);<br>        in.showName();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="x20-局部内部类"><a href="#x20-局部内部类" class="headerlink" title="&#x20;局部内部类"></a>&#x20;局部内部类</h2><ul><li><strong>局部内部类</strong> ：定义在<strong>方法中</strong>的类。</li></ul><p>定义格式:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">class 外部类名 &#123;<br>  数据类型 变量名;<br>  <br>  修饰符 返回值类型 方法名(参数列表) &#123;<br>    // …<br>    class 内部类 &#123;<br>      // 成员变量<br>      // 成员方法<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="x20-匿名内部类【重点】"><a href="#x20-匿名内部类【重点】" class="headerlink" title="&#x20;匿名内部类【重点】"></a>&#x20;匿名内部类【重点】</h2><h3 id="x20-概述-2"><a href="#x20-概述-2" class="headerlink" title="&#x20;概述"></a>&#x20;概述</h3><p><strong>匿名内部类</strong> ：是内部类的简化写法。他是一个隐含了名字的内部类。开发中，最常用到的内部类就是匿名内部类了。</p><h3 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">new 类名或者接口名() &#123;<br>     重写方法;<br>&#125;;<br></code></pre></td></tr></table></figure><p>包含了：</p><ul><li>继承或者实现关系</li><li>方法重写</li><li>创建对象</li></ul><p>所以从语法上来讲，这个整体其实是匿名内部类对象</p><h3 id="x20-什么时候用到匿名内部类"><a href="#x20-什么时候用到匿名内部类" class="headerlink" title="&#x20;什么时候用到匿名内部类"></a>&#x20;什么时候用到匿名内部类</h3><p><strong>实际上，如果我们希望定义一个只要使用一次的类，就可考虑使用匿名内部类。匿名内部类的本质作用</strong></p><p><strong>是为了简化代码</strong>。</p><p>最终的目的，最终只是为了调用方法，那么能不能简化一下，把以上四步合成一步呢？匿名内部类就是做这样的快捷方式。</p><h3 id="x20-匿名内部类前提和格式"><a href="#x20-匿名内部类前提和格式" class="headerlink" title="&#x20;匿名内部类前提和格式"></a>&#x20;匿名内部类前提和格式</h3><p>匿名内部类必须<strong>继承一个父类</strong>或者<strong>实现一个父接口</strong>。</p><p><strong>匿名内部类格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">new 父类名或者接口名()&#123;<br>    // 方法重写<br>    @Override <br>    public void method() &#123;<br>        // 执行语句<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="x20-匿名内部类的特点"><a href="#x20-匿名内部类的特点" class="headerlink" title="&#x20;匿名内部类的特点"></a>&#x20;匿名内部类的特点</h3><ol><li>定义一个没有名字的内部类</li><li>这个类实现了父类，或者父类接口</li><li>匿名内部类会创建这个没有名字的类的对象</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组</title>
    <link href="/2024/01/17/%E6%95%B0%E7%BB%84/"/>
    <url>/2024/01/17/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h3><p>指的是一种容器，可以同来存储同种数据类型的多个值。</p><p>但是数组容器在存储数据的时候，还需要结合隐式转换考虑。</p><p>比如：</p><p>定义了一个int类型的数组。那么boolean。double类型的数据是不能存到这个数组中的，</p><p>但是byte类型，short类型，int类型的数据是可以存到这个数组里面的。</p><p>建议：</p><p>容器的类，和存储的数据类型保持一致。</p><p>举例：</p><p>整数1 2 3 4 56 就可以使用int类型的数组来存储。</p><p>小数1.1 1.2 1.3 1.4 就可以使用double类型的数组来存储。</p><p>字符串”aaa” “bbb” “ccc” 就可以使用String类型的数组来存储。</p><h2 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h2><p>格式一:数据类型 [] 数组名</p><p>例: int [] array</p><p>格式二:数据类型  数组名 []</p><p>例: int array []</p><p>方括号和数组名谁前谁后都一样.</p><h3 id="数组的静态初始化"><a href="#数组的静态初始化" class="headerlink" title="数组的静态初始化"></a>数组的静态初始化</h3><p>代码格式:</p><p>数据类型[] 数组名 &#x3D; new 数据类型[]{元素1，元素2，元素3…};</p><p>例:int[] array &#x3D; new int[]{1,2,3…};</p><p>&#x20;   int[] array &#x3D; {1,2,3…};   &#x20;</p><h4 id="格式解释"><a href="#格式解释" class="headerlink" title="格式解释:"></a>格式解释:</h4><p>数据类型：限定了数组以后能存什么类型的数据。</p><p>&#x20; 前面和后面的数据类型一定要保持一致。</p><p>方括号：表示现在定义的是一个数组。</p><p>数组名：是一个名字，方便以后使用。</p><p>大括号：表示数组里面的元素。元素也就是存入到数组中的数据。</p><p>&#x20;  多个元素之间，一定要用逗号隔开。</p><p>注意点:</p><p>①等号前后的数据类型必须保持一致。</p><p>②数组一旦创建之后，长度不能发生变化。</p><h2 id="地址值"><a href="#地址值" class="headerlink" title="地址值"></a>地址值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">int[] arr = &#123;1,2,3,4,5&#125;;<br>System.out.println(arr);<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%95%B0%E7%BB%84/image_IXksxb6utd.png"></p><p>打印数组的时候，实际出现的是数组的地址值。</p><p>数组的地址值：就表示数组在内存中的位置。</p><p>比如:</p><p>[: 表示现在打印的是一个数组.</p><p>I: 表示答应的数据类型是int类型.</p><p>@: 是一个间隔符号.</p><p>1540e19d: 表示是数组在内存中真正的地址值.(十六进制)</p><p>∴ [I@1540e19d 就是数组的地址值</p><h2 id="数组元素的访问"><a href="#数组元素的访问" class="headerlink" title="数组元素的访问"></a>数组元素的访问</h2><p>代码格式:数组名[索引]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        int[] arr = &#123;1, 2, 3, 4, 5, 6&#125;;<br>        int number=arr [3];<br>        System.out.println(number);<br>        System.out.println(arr[2]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%95%B0%E7%BB%84/image_fXFFNKW3Xz.png"></p><p>作用:①获取数组中对应索引上的值</p><p>&#x20;       ②修改数组中对应索引上的值</p><p>&#x20;   一旦修改之后，原来的值就会被覆盖了。</p><p>索引的特点:</p><ol><li>一定是从0 开始的</li><li>连续不间断</li><li>逐个+1增长</li></ol><h4 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h4><p>代码格式:数组名[索引]&#x3D;具体数据&#x2F;变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        int[] arr = &#123;1, 2, 3, 4, 5&#125;;<br>        arr[1]= 10;<br>        System.out.println(arr[1]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%95%B0%E7%BB%84/image_GKObzIx2g8.png"></p><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><p>遍历：就是把数组里面所有的内容一个一个全部取出来。</p><p>代码格式:数组名.length;</p><p>代码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        int[] arr = &#123;1,2,3,4,5&#125;;<br>        for (int i = 0; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%95%B0%E7%BB%84/image_sx62nV9o-l.png"></p><p>扩展:</p><p>自动的快速生成数组的遍历方式</p><p>数组名.fori</p><h3 id="求和练习"><a href="#求和练习" class="headerlink" title="求和练习:"></a>求和练习:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本"> int[] arr = &#123;1, 2, 4, 4, 5, 6&#125;;<br>        int sum = 0;<br>        for (int i = 0; i &lt; arr.length; i++) &#123;<br>            sum = sum + arr[i];<br>        &#125;<br>        System.out.println(sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%95%B0%E7%BB%84/image_-bG42DE2EF.png"></p><p>统计个数:统计数组里有几个数可以被5 整除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        int[] arr = &#123;1, 2, 5, 4, 5, 6, 7, 8, 9, 10&#125;;<br>        int count = 0;<br>        for (int i = 0; i &lt; arr.length; i++) &#123;<br>            if (arr[i] % 5 == 0) &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        System.out.println(&quot;数组中能被5整除的数字有&quot; + count + &quot;个&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%95%B0%E7%BB%84/image_rUwGxZQ18f.png"></p><h3 id="数据变化-x20"><a href="#数据变化-x20" class="headerlink" title="数据变化&#x20;"></a>数据变化&#x20;</h3><p>1.如果是奇数，则将当前数字扩大两倍</p><p>2.如果是偶数，则将当前数字变成二分之一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        int[] arr = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;;<br>        for (int i = 0; i &lt; arr.length; i++) &#123;<br>            if (arr[i] % 2 == 0) &#123;<br>                arr[i] = arr[i] / 2;<br>            &#125; else &#123;<br>                arr[i] = arr[i] * 2;<br>            &#125;<br>        &#125;<br>        for (int i = 0; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i]);<br></code></pre></td></tr></table></figure><p><img src="/../image/%E6%95%B0%E7%BB%84/image_aoqQBrHpd4.png"></p><h3 id="数组的动态初始化"><a href="#数组的动态初始化" class="headerlink" title="数组的动态初始化"></a>数组的动态初始化</h3><p>代码格式:数据类型[] 数组名 &#x3D; new 数据类型[数组的长度];</p><h3 id="数组的默认初始化值："><a href="#数组的默认初始化值：" class="headerlink" title="数组的默认初始化值："></a>数组的默认初始化值：</h3><p>整数类型：0</p><p>小数类型：0.0</p><p>布尔类型：false</p><p>字符类型：’\u0000’</p><p>引用类型：null</p><h3 id="数组两种初始化方式的区别"><a href="#数组两种初始化方式的区别" class="headerlink" title="数组两种初始化方式的区别"></a>数组两种初始化方式的区别</h3><p>静态初始化：int[] arr &#x3D; {1,2,3,4,5};</p><p>动态初始化：int[] arr &#x3D; new int[3];</p><p>静态初始化：手动指定数组的元素，系统会根据元素的个数，计算出数组的长度。</p><p>动态初始化：手动指定数组长度，由系统给出默认初始化值。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><p>只明确元素个数，但是不明确具体的数据，使用动态初始化。</p><p>已经明确了要操作的所有数据，使用静态初始化。</p><h3 id="数组的内存图"><a href="#数组的内存图" class="headerlink" title="数组的内存图"></a>数组的内存图</h3><p>1.JAVA内存分配:</p><p>栈:方法运行时使用的内存，比如main方法运行，进入方法栈中执行</p><p>堆:存储对象或者数组，new来创建的，都存储在堆内存</p><p>方法区:存储可以运行的class文件</p><p>本地方法栈:JVM在使用操作系统功能的时候使用，和我们开发无关</p><p>寄存器:给CPU使用，和我们开发无关</p><p><img src="/../image/%E6%95%B0%E7%BB%84/image_rD8nFXZLJ_.png"></p><p><img src="/../image/%E6%95%B0%E7%BB%84/image_6KDYAjjSdr.png"></p><p>注:只要是new出来的一定是在堆里开辟了一个小空间</p><p>如果new了多次,那么在堆里有多个小空间,每个小空间有各自的数据.</p><p><img src="/../image/%E6%95%B0%E7%BB%84/image_CkdYK1K-XZ.png"></p><p>注:</p><p>当两个数组指向同一个小空间时，其中一个数组对小空间中的值发生了改变，那么其他数组再次访问的时候都是修改之后的结果了。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>循环高级</title>
    <link href="/2024/01/15/%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7/"/>
    <url>/2024/01/15/%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="循环高级"><a href="#循环高级" class="headerlink" title="循环高级"></a>循环高级</h1><h3 id="1-无限循环"><a href="#1-无限循环" class="headerlink" title="1.无限循环"></a>1.无限循环</h3><p>for格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">for(;;)&#123;<br>    System.out.println(&quot;循环执行一直在打印内容&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>注:</p><p>初始化语句可以空着不写，表示循环之前不定义任何的控制变量。</p><p>条件判断语句可以空着不写，如果不写，默认表示true，循环一直进行。</p><p>条件控制语句可以空着不写，表示每次循环体执行完毕后，控制变量不做任何变化。</p><p>while格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">while(true)&#123;<br>    System.out.println(&quot;循环执行一直在打印内容&quot;);<br>&#125;<br></code></pre></td></tr></table></figure><p>注:小括号里的true不能省略，true一定要写出来，否则代码会报错。</p><p>do…..while格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">do&#123;<br>    System.out.println(&quot;循环执行一直在打印内容&quot;);<br>&#125;while(true);<br></code></pre></td></tr></table></figure><p>注:小括号里的true不能省略，true一定要写出来，否则代码会报错。</p><h3 id="无限循环的注意事项："><a href="#无限循环的注意事项：" class="headerlink" title="无限循环的注意事项："></a>无限循环的注意事项：</h3><p>①最为常用的格式：while</p><p>②无限循环下面不能再写其他代码了，因为永远执行不到。</p><h3 id="2-条件控制语句"><a href="#2-条件控制语句" class="headerlink" title="2.条件控制语句"></a>2.条件控制语句</h3><p>break:</p><p>不能单独存在的。可以用在switch和循环中，表示结束，跳出的意思。</p><p>continue:</p><p>不能单独存在的。只能存在于循环当中。</p><p>表示：跳过本次循环，继续执行下次循环。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串</title>
    <link href="/2023/09/28/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/09/28/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><p>1.什么是API</p><p>API (Application Programming Interface) ：应用程序编程接口</p><p>&#x20;  2.java中的API&#x20;</p><p>指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来.</p><h4 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h4><p>1.概述:String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！</p><p>&#x20;    2.特点:</p><ol><li>字符串不可变，它们的值在创建后不能被更改</li><li>虽然 String 的值是不可变的，但是它们可以被共享</li><li>字符串效果上相当于字符数组( char[] )，但是底层原理是字节数组( byte[] )</li></ol><p>3.构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String s &#x3D; “abc”;</td><td>直接赋值的方式创建字符串对象，内容就是abc</td></tr><tr><td>public String()</td><td>创建一个空白字符串对象，不含有任何内容</td></tr><tr><td>public String(char[] chs)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr><td>public String(byte[] bys)</td><td>根据字节数组的内容，来创建字符串对象</td></tr></tbody></table><p>示例代码:</p><p>1.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">//String s = “abc”;  直接赋值的方式创建字符串对象，内容就是abc<br>        String s1 = &quot;abc&quot;;<br>        System.out.println(&quot;s1:&quot; + s1);<br></code></pre></td></tr></table></figure><p>2.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">//public String()：创建一个空白字符串对象，不含有任何内容<br>       String s2 = new String();<br>       System.out.println(&quot;s2:&quot; + s2);<br></code></pre></td></tr></table></figure><p>3.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">//public String(char[] chs)：根据字符数组的内容，来创建字符串对象<br>       char[] chs = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;<br>       String s3 = new String(chs);<br>       System.out.println(&quot;s3:&quot; + s3);<br></code></pre></td></tr></table></figure><p>4.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">//public String(byte[] bys)：根据字节数组的内容，来创建字符串对象<br>        byte[] bys = &#123;97, 98, 99&#125;;<br>        String s4 = new String(bys);<br>        System.out.println(&quot;s4:&quot; + s4);<br><br></code></pre></td></tr></table></figure><p>创建字符串对象的两种方式的区别:</p><ol><li><p>通过构造方法创建</p><p>通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同</p></li><li><p>直接赋值方式创建</p><p>以“”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护</p></li></ol><h3 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h3><p>1.&#x3D;&#x3D;的作用</p><ul><li>比较基本数据类型：比较的是具体的值</li><li>比较引用数据类型：比较的是对象地址值</li></ul><p>2.equals方法的作用</p><p>基本代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public boolean equals(String s)     <br>比较两个字符串内容是否相同、区分大小写<br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">  public static void main(String[] args) &#123;<br>        char[] chs = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;<br>        String s1 = new String(chs);<br>        String s2 = new String(chs);<br>        String s3 = &quot;abc&quot;;<br>        String s4 = &quot;abc&quot;;<br>        //比较字符串对象地址是否相同<br>        System.out.println(s1 == s2);<br>        System.out.println(s1 == s3);<br>        System.out.println(s3 == s4);<br>        System.out.println(&quot;--------&quot;);<br>        //比较字符串内容是否相同<br>        System.out.println(s1.equals(s2));<br>        System.out.println(s1.equals(s3));<br>        System.out.println(s3.equals(s4));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../image/%E5%AD%97%E7%AC%A6%E4%B8%B2/image_2Tu3I2SaCy.png"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>用户登录:代码示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public static void main(String[] args) &#123;<br>       String rightUsername = &quot;qwer&quot;;<br>       String rightPassword = &quot;1234&quot;;<br>       for (int i = 0; i &lt; 3; i++) &#123;//0 1 2<br>           Scanner sc = new Scanner(System.in);<br>           System.out.println(&quot;请输入用户名&quot;);<br>           String username = sc.next();<br>           System.out.println(&quot;请输入密码&quot;);<br>           String password = sc.next();<br>           //判断比较<br>           if (username.equals(rightUsername) &amp;&amp; password.equals(rightPassword)) &#123;<br>               System.out.println(&quot;登录成功&quot;);<br>               break;<br>           &#125; else &#123;<br>               if(i == 2)&#123;<br>                   System.out.println(&quot;账户&quot; + username + &quot;被锁定&quot;);<br>               &#125;else&#123;<br>                   //不是最后一次机会<br>                   System.out.println(&quot;用户名或密码错误，登录失败,还剩下&quot; + (2 - i) + &quot;次机会&quot;);//2 1 0<br><br></code></pre></td></tr></table></figure><p><img src="/../image/%E5%AD%97%E7%AC%A6%E4%B8%B2/image_q0KcqtrSkZ.png"></p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuilder 可以看成是一个容器，创建之后里面的内容是可变的。</p><p>当我们在拼接字符串和反转字符串的时候会使用到</p><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本"><br>        StringBuilder sc = new StringBuilder(&quot;abc&quot;);<br>        sb.reverse();<br>        int len = sb.length();<br>        System.out.println(len);<br>        System.out.println(sc);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="集合和数组的优势对比："><a href="#集合和数组的优势对比：" class="headerlink" title="集合和数组的优势对比："></a>集合和数组的优势对比：</h3><ol><li>长度可变</li><li>添加数据的时候不需要考虑索引，默认将数据添加到末尾</li></ol><h3 id="ArrayList类概述"><a href="#ArrayList类概述" class="headerlink" title="ArrayList类概述"></a>ArrayList类概述</h3><ul><li><p>什么是集合</p><p>提供一种存储空间可变的存储模型，存储的数据容量可以发生改变</p></li><li><p>ArrayList集合的特点</p><p>长度可以变化，只能存储引用数据类型。</p></li><li><p>泛型的使用</p><p>用于约束集合中存储元素的数据类型</p></li></ul><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public ArrayList()</td><td>创建一个空的集合对象</td></tr></tbody></table><h4 id="1-2-2-成员方法"><a href="#1-2-2-成员方法" class="headerlink" title="1.2.2 成员方法"></a>1.2.2 成员方法</h4><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean add(要添加的元素)</td><td>将指定的元素追加到此集合的末尾</td></tr><tr><td>public boolean remove(要删除的元素)</td><td>删除指定元素,返回值表示是否删除成功</td></tr><tr><td>public E remove(int index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>public E set(int index,E element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>public E get(int index)</td><td>返回指定索引处的元素</td></tr><tr><td>public int size()</td><td>返回集合中的元素的个数</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA</title>
    <link href="/2023/07/18/JAVA/"/>
    <url>/2023/07/18/JAVA/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p><a href="%E8%BF%90%E7%AE%97%E7%AC%A6-/%E8%BF%90%E7%AE%97%E7%AC%A6-.md" title="运算符 ">运算符 </a></p><p><a href="%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF/%E5%88%A4%E6%96%AD%E4%B8%8E%E5%BE%AA%E7%8E%AF.md" title="判断与循环">判断与循环</a></p><p><a href="%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7/%E5%BE%AA%E7%8E%AF%E9%AB%98%E7%BA%A7.md" title="循环高级">循环高级</a></p><p><a href="%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84.md" title="数组">数组</a></p><p><a href="%E6%96%B9%E6%B3%95/%E6%96%B9%E6%B3%95.md" title="方法">方法</a></p><p><a href="%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1.md" title="面相对象">面相对象</a></p><p><a href="%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E4%B8%B2.md" title="字符串">字符串</a></p><p><a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.md" title="面向对象进阶">面向对象进阶</a></p><p><a href="API%EF%BC%881%EF%BC%89/API%EF%BC%881%EF%BC%89.md" title="API（1）">API（1）</a></p><p><a href="API%EF%BC%882%EF%BC%89/API%EF%BC%882%EF%BC%89.md" title="API（2）">API（2）</a></p><p><a href="API%EF%BC%883%EF%BC%89/API%EF%BC%883%EF%BC%89.md" title="API（3）">API（3）</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>API（3）</title>
    <link href="/2023/07/10/API%EF%BC%883%EF%BC%89/"/>
    <url>/2023/07/10/API%EF%BC%883%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="API（3）"><a href="#API（3）" class="headerlink" title="API（3）"></a>API（3）</h1><h1 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h1><h2 id="x20-Date概述"><a href="#x20-Date概述" class="headerlink" title="&#x20;Date概述"></a>&#x20;Date概述</h2><p>java.util.Date`类 表示特定的瞬间，精确到毫秒。</p><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，我们重点看以下两个构造函数</p><ul><li><code>public Date()</code>：从运行程序的此时此刻到时间原点经历的毫秒值,转换成Date对象，分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li><code>public Date(long date)</code>：将指定参数的毫秒值date,转换成Date对象，分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。</li></ul><blockquote><p>tips: 由于中国处于东八区（GMT+08:00）是比世界协调时间&#x2F;格林尼治时间（GMT）快8小时的时区，当格林尼治标准时间为0:00时，东八区的标准时间为08:00。</p></blockquote><p>简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 创建日期对象，把当前的时间</span><br>System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><span class="hljs-comment">// 创建日期对象，把当前的毫秒值转成日期对象</span><br>System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">0L</span>));<br><br></code></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Sat May <span class="hljs-number">27</span> <span class="hljs-number">19</span>:08:<span class="hljs-number">42</span> GMT+08:<span class="hljs-number">00</span> <span class="hljs-number">2023</span><br>Thu Jan <span class="hljs-number">01</span> 08:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> GMT+08:<span class="hljs-number">00</span> <span class="hljs-number">1970</span><br></code></pre></td></tr></table></figure><blockquote><p>tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。</p></blockquote><h2 id="x20-Date常用方法"><a href="#x20-Date常用方法" class="headerlink" title="&#x20;Date常用方法"></a>&#x20;Date常用方法</h2><p>Date类中的多数方法已经过时，常用的方法有：</p><ul><li><code>public long getTime()</code> 把日期对象转换成对应的时间毫秒值。</li><li><code>public void setTime(long time)</code> 把方法参数给定的毫秒值设置给日期对象</li></ul><blockquote><p>小结：Date表示特定的时间瞬间，我们可以使用Date对象对时间进行操作。</p></blockquote><h1 id="x20-SimpleDateFormat类"><a href="#x20-SimpleDateFormat类" class="headerlink" title="&#x20;SimpleDateFormat类"></a>&#x20;SimpleDateFormat类</h1><p><code>java.text.SimpleDateFormat</code> 是日期&#x2F;时间格式化类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。</p><ul><li><strong>格式化</strong>：按照指定的格式，把Date对象转换为String对象。</li><li><strong>解析</strong>：按照指定的格式，把String对象转换为Date对象。</li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>由于DateFormat为抽象类，不能直接使用，所以需要常用的子类<code>java.text.SimpleDateFormat</code>。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：</p><ul><li><code>public SimpleDateFormat(String pattern)</code>：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。参数pattern是一个字符串，代表日期时间的自定义格式。</li></ul><h2 id="x20-格式规则"><a href="#x20-格式规则" class="headerlink" title="&#x20;格式规则"></a>&#x20;格式规则</h2><p>常用的格式规则为：</p><table><thead><tr><th>标识字母（区分大小写）</th><th>含义</th></tr></thead><tbody><tr><td>y</td><td>年</td></tr><tr><td>M</td><td>月</td></tr><tr><td>d</td><td>日</td></tr><tr><td>H</td><td>时</td></tr><tr><td>m</td><td>分</td></tr><tr><td>s</td><td>秒</td></tr></tbody></table><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>DateFormat类的常用方法有：</p><ul><li><code>public String format(Date date)</code>：将Date对象格式化为字符串。</li><li><code>public Date parse(String source)</code>：将字符串解析为Date对象。</li></ul><blockquote><p>小结：DateFormat可以将Date对象和字符串相互转换。</p></blockquote><h1 id="x20-Calendar类"><a href="#x20-Calendar类" class="headerlink" title="&#x20;Calendar类"></a>&#x20;Calendar类</h1><h2 id="x20-概述"><a href="#x20-概述" class="headerlink" title="&#x20;概述"></a>&#x20;概述</h2><ul><li>java.util.Calendar类表示一个“日历类”，可以进行日期运算。它是一个抽象类，不能创建对象，我们可以使用它的子类：java.util.GregorianCalendar类。</li><li>有两种方式可以获取GregorianCalendar对象：<ul><li>直接创建GregorianCalendar对象；</li><li>通过Calendar的静态方法getInstance()方法获取GregorianCalendar对象【本次课使用】</li></ul></li></ul><h2 id="x20-常用方法"><a href="#x20-常用方法" class="headerlink" title="&#x20;常用方法"></a>&#x20;常用方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Calendar getInstance()</td><td>获取一个它的子类GregorianCalendar对象。</td></tr><tr><td>public int get(int field)</td><td>获取某个字段的值。field参数表示获取哪个字段的值，&#xA;可以使用Calender中定义的常量来表示：&#xA;Calendar.YEAR : 年&#xA;Calendar.MONTH ：月&#xA;Calendar.DAY_OF_MONTH：月中的日期&#xA;Calendar.HOUR：小时&#xA;Calendar.MINUTE：分钟&#xA;Calendar.SECOND：秒&#xA;Calendar.DAY_OF_WEEK：星期</td></tr><tr><td>public void set(int field,int value)</td><td>设置某个字段的值</td></tr><tr><td>public void add(int field,int amount)</td><td>为某个字段增加&#x2F;减少指定的值</td></tr></tbody></table><h2 id="x20-get方法示例"><a href="#x20-get方法示例" class="headerlink" title="&#x20;get方法示例"></a>&#x20;get方法示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.获取一个GregorianCalendar对象</span><br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> Calendar.getInstance();<span class="hljs-comment">//获取子类对象</span><br><br>        <span class="hljs-comment">//2.打印子类对象</span><br>        System.out.println(instance);<br><br>        <span class="hljs-comment">//3.获取属性</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> instance.get(Calendar.YEAR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">month</span> <span class="hljs-operator">=</span> instance.get(Calendar.MONTH) + <span class="hljs-number">1</span>;<span class="hljs-comment">//Calendar的月份值是0-11</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">day</span> <span class="hljs-operator">=</span> instance.get(Calendar.DAY_OF_MONTH);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hour</span> <span class="hljs-operator">=</span> instance.get(Calendar.HOUR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minute</span> <span class="hljs-operator">=</span> instance.get(Calendar.MINUTE);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> instance.get(Calendar.SECOND);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">week</span> <span class="hljs-operator">=</span> instance.get(Calendar.DAY_OF_WEEK);<span class="hljs-comment">//返回值范围：1--7，分别表示：&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,...,&quot;星期六&quot;</span><br><br>        System.out.println(year + <span class="hljs-string">&quot;年&quot;</span> + month + <span class="hljs-string">&quot;月&quot;</span> + day + <span class="hljs-string">&quot;日&quot;</span> + <br>                             hour + <span class="hljs-string">&quot;:&quot;</span> + minute + <span class="hljs-string">&quot;:&quot;</span> + second);<br>        System.out.println(getWeek(week));<br><br>    &#125;<br><br>    <span class="hljs-comment">//查表法，查询星期几</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getWeek</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> &#123;<span class="hljs-comment">//w = 1 --- 7</span><br>        <span class="hljs-comment">//做一个表(数组)</span><br>        String[] weekArray = &#123;<span class="hljs-string">&quot;星期日&quot;</span>, <span class="hljs-string">&quot;星期一&quot;</span>, <span class="hljs-string">&quot;星期二&quot;</span>, <span class="hljs-string">&quot;星期三&quot;</span>, <span class="hljs-string">&quot;星期四&quot;</span>, <span class="hljs-string">&quot;星期五&quot;</span>, <span class="hljs-string">&quot;星期六&quot;</span>&#125;;<br>        <span class="hljs-comment">//            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]</span><br>        <span class="hljs-comment">//查表</span><br>        <span class="hljs-keyword">return</span> weekArray[w - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="x20-set方法示例："><a href="#x20-set方法示例：" class="headerlink" title="&#x20;set方法示例："></a>&#x20;set方法示例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//设置属性——set(int field,int value):</span><br>    <span class="hljs-type">Calendar</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> Calendar.getInstance();<span class="hljs-comment">//获取当前日期</span><br><br>    <span class="hljs-comment">//计算班长出生那天是星期几(假如班长出生日期为：1998年3月18日)</span><br>    c1.set(Calendar.YEAR, <span class="hljs-number">1998</span>);<br>    c1.set(Calendar.MONTH, <span class="hljs-number">3</span> - <span class="hljs-number">1</span>);<span class="hljs-comment">//转换为Calendar内部的月份值</span><br>    c1.set(Calendar.DAY_OF_MONTH, <span class="hljs-number">18</span>);<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> c1.get(Calendar.DAY_OF_WEEK);<br>    System.out.println(<span class="hljs-string">&quot;班长出生那天是：&quot;</span> + getWeek(w));<br><br>        <br>    &#125;<br>    <span class="hljs-comment">//查表法，查询星期几</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getWeek</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> &#123;<span class="hljs-comment">//w = 1 --- 7</span><br>        <span class="hljs-comment">//做一个表(数组)</span><br>        String[] weekArray = &#123;<span class="hljs-string">&quot;星期日&quot;</span>, <span class="hljs-string">&quot;星期一&quot;</span>, <span class="hljs-string">&quot;星期二&quot;</span>, <span class="hljs-string">&quot;星期三&quot;</span>, <span class="hljs-string">&quot;星期四&quot;</span>, <span class="hljs-string">&quot;星期五&quot;</span>, <span class="hljs-string">&quot;星期六&quot;</span>&#125;;<br>        <span class="hljs-comment">//            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]</span><br>        <span class="hljs-comment">//查表</span><br>        <span class="hljs-keyword">return</span> weekArray[w - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="add方法示例："><a href="#add方法示例：" class="headerlink" title="add方法示例："></a>add方法示例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//计算200天以后是哪年哪月哪日，星期几？</span><br>    <span class="hljs-type">Calendar</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> Calendar.getInstance();<span class="hljs-comment">//获取当前日期</span><br>        c2.add(Calendar.DAY_OF_MONTH, <span class="hljs-number">200</span>);<span class="hljs-comment">//日期加200</span><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> c2.get(Calendar.YEAR);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> c2.get(Calendar.MONTH) + <span class="hljs-number">1</span>;<span class="hljs-comment">//转换为实际的月份</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> c2.get(Calendar.DAY_OF_MONTH);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wk</span> <span class="hljs-operator">=</span> c2.get(Calendar.DAY_OF_WEEK);<br>        System.out.println(<span class="hljs-string">&quot;200天后是：&quot;</span> + y + <span class="hljs-string">&quot;年&quot;</span> + m + <span class="hljs-string">&quot;月&quot;</span> + d + <span class="hljs-string">&quot;日&quot;</span> + getWeek(wk));<br><br>    &#125;<br>    <span class="hljs-comment">//查表法，查询星期几</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getWeek</span><span class="hljs-params">(<span class="hljs-type">int</span> w)</span> &#123;<span class="hljs-comment">//w = 1 --- 7</span><br>        <span class="hljs-comment">//做一个表(数组)</span><br>        String[] weekArray = &#123;<span class="hljs-string">&quot;星期日&quot;</span>, <span class="hljs-string">&quot;星期一&quot;</span>, <span class="hljs-string">&quot;星期二&quot;</span>, <span class="hljs-string">&quot;星期三&quot;</span>, <span class="hljs-string">&quot;星期四&quot;</span>, <span class="hljs-string">&quot;星期五&quot;</span>, <span class="hljs-string">&quot;星期六&quot;</span>&#125;;<br>        <span class="hljs-comment">//            索引      [0]      [1]       [2]      [3]       [4]      [5]      [6]</span><br>        <span class="hljs-comment">//查表</span><br>        <span class="hljs-keyword">return</span> weekArray[w - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="x20-JDK8时间相关类"><a href="#x20-JDK8时间相关类" class="headerlink" title="&#x20;JDK8时间相关类"></a>&#x20;JDK8时间相关类</h1><table><thead><tr><th>JDK8时间类类名</th><th>作用</th></tr></thead><tbody><tr><td>ZoneId</td><td>时区</td></tr><tr><td>Instant</td><td>时间戳</td></tr><tr><td>ZoneDateTime</td><td>带时区的时间</td></tr><tr><td>DateTimeFormatter</td><td>用于时间的格式化和解析</td></tr><tr><td>LocalDate</td><td>年、月、日</td></tr><tr><td>LocalTime</td><td>时、分、秒</td></tr><tr><td>LocalDateTime</td><td>年、月、日、时、分、秒</td></tr><tr><td>Duration</td><td>时间间隔（秒，纳，秒）</td></tr><tr><td>Period</td><td>时间间隔（年，月，日）</td></tr><tr><td>ChronoUnit</td><td>时间间隔（所有单位）</td></tr></tbody></table><h1 id="x20-包装类"><a href="#x20-包装类" class="headerlink" title="&#x20;包装类"></a>&#x20;包装类</h1><h2 id="x20-概述-1"><a href="#x20-概述-1" class="headerlink" title="&#x20;概述"></a>&#x20;概述</h2><p>Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：</p><table><thead><tr><th>基本类型</th><th>对应的包装类（位于java.lang包中）</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>​<strong>Integer</strong></td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>​<strong>Character</strong></td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="x20-Integer类"><a href="#x20-Integer类" class="headerlink" title="&#x20;Integer类"></a>&#x20;Integer类</h2><ul><li>Integer类概述<br>包装一个对象中的原始类型 int 的值</li><li>Integer类构造方法及静态方法</li></ul><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Integer(int   value)</td><td>根据 int 值创建 Integer 对象(过时)</td></tr><tr><td>public Integer(String s)</td><td>根据 String 值创建 Integer 对象(过时)</td></tr><tr><td>public static Integer valueOf(int i)</td><td>返回表示指定的 int 值的 Integer   实例</td></tr><tr><td>public static Integer valueOf(String s)</td><td>返回保存指定String值的 Integer 对象</td></tr><tr><td>static string tobinarystring(int i)</td><td>得到二进制</td></tr><tr><td>static string tooctalstring(int i)</td><td>得到八进制</td></tr><tr><td>static string toHexstring(int i)</td><td>得到十六进制</td></tr><tr><td>static int parseInt(string s)</td><td>将字符串类型的整数转成int类型的整数</td></tr></tbody></table><ul><li>示例代码</li></ul><h2 id="x20-装箱与拆箱"><a href="#x20-装箱与拆箱" class="headerlink" title="&#x20;装箱与拆箱"></a>&#x20;装箱与拆箱</h2><p>基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：</p><ul><li><strong>装箱</strong>：从基本类型转换为对应的包装类对象。</li><li><strong>拆箱</strong>：从包装类对象转换为对应的基本类型。</li></ul><p>用Integer与 int为例：（看懂代码即可）</p><p>基本数值—-&gt;包装对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用构造函数函数</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">iii</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">4</span>);<span class="hljs-comment">//使用包装类中的valueOf方法</span><br></code></pre></td></tr></table></figure><p>包装对象—-&gt;基本数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> i.intValue();<br></code></pre></td></tr></table></figure><h2 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h2><p>由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<span class="hljs-comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span><br>i = i + <span class="hljs-number">5</span>;<span class="hljs-comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;</span><br><span class="hljs-comment">//加法运算完成后，再次装箱，把基本数值转成对象。</span><br></code></pre></td></tr></table></figure><h2 id="x20-基本类型与字符串之间的转换"><a href="#x20-基本类型与字符串之间的转换" class="headerlink" title="&#x20;基本类型与字符串之间的转换"></a>&#x20;基本类型与字符串之间的转换</h2><h3 id="基本类型转换为String"><a href="#基本类型转换为String" class="headerlink" title="基本类型转换为String"></a>基本类型转换为String</h3><ul><li>转换方式</li><li>方式一：直接在数字后加一个空字符串</li><li>方式二：通过String类静态方法valueOf()</li><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>        <span class="hljs-comment">//int --- String</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-comment">//方式1</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> number + <span class="hljs-string">&quot;&quot;</span>;<br>        System.out.println(s1);<br>        <span class="hljs-comment">//方式2</span><br>        <span class="hljs-comment">//public static String valueOf(int i)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> String.valueOf(number);<br>        System.out.println(s2);<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="String转换成基本类型"><a href="#String转换成基本类型" class="headerlink" title="String转换成基本类型"></a>String转换成基本类型</h3><p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：</p><ul><li><code>public static byte parseByte(String s)</code>：将字符串参数转换为对应的byte基本类型。</li><li><code>public static short parseShort(String s)</code>：将字符串参数转换为对应的short基本类型。</li><li><strong><code>public static int parseInt(String s)</code>：将字符串参数转换为对应的int基本类型。</strong></li><li><strong><code>public static long parseLong(String s)</code>：将字符串参数转换为对应的long基本类型。</strong></li><li><code>public static float parseFloat(String s)</code>：将字符串参数转换为对应的float基本类型。</li><li><code>public static double parseDouble(String s)</code>：将字符串参数转换为对应的double基本类型。</li><li><code>public static boolean parseBoolean(String s)</code>：将字符串参数转换为对应的boolean基本类型。</li></ul><p>代码使用（仅以Integer类的静态方法parseXxx为例）如：</p><ul><li>转换方式<ul><li>方式一：先将字符串数字转成Integer，再调用valueOf()方法</li><li>方式二：通过Integer静态方法parseInt()进行转换</li></ul></li><li>示例代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//String --- int</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<br><span class="hljs-comment">//方式1：String --- Integer --- int</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Integer.valueOf(s);<br><span class="hljs-comment">//public int intValue()</span><br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> i.intValue();<br>System.out.println(x);<br><span class="hljs-comment">//方式2</span><br><span class="hljs-comment">//public static int parseInt(String s)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br>System.out.println(y)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>API（2）</title>
    <link href="/2023/01/31/API%EF%BC%882%EF%BC%89/"/>
    <url>/2023/01/31/API%EF%BC%882%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="API（2）"><a href="#API（2）" class="headerlink" title="API（2）"></a>API（2）</h1><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h2 id="正则表达式-字符类"><a href="#正则表达式-字符类" class="headerlink" title="正则表达式-字符类"></a>正则表达式-字符类</h2><ul><li>语法示例：</li></ul><ol><li>[abc]：代表a或者b，或者c字符中的一个。</li><li>[^abc]：代表除a,b,c以外的任何字符。</li><li>[a-z]：代表a-z的所有小写字符中的一个。</li><li>[A-Z]：代表A-Z的所有大写字符中的一个。</li><li>[0-9]：代表0-9之间的某一个数字字符。</li><li>[a-zA-Z0-9]：代表a-z或者A-Z或者0-9之间的任意一个字符。</li><li>[a-dm-p]：a 到 d 或 m 到 p之间的任意一个字符。</li></ol><ul><li>代码示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 只能是a b c</span><br>System.out.println(<span class="hljs-string">&quot;-----------1-------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[abc]&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-string">&quot;z&quot;</span>.matches(<span class="hljs-string">&quot;[abc]&quot;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// 不能出现a b c</span><br>System.out.println(<span class="hljs-string">&quot;-----------2-------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[^abc]&quot;</span>)); <span class="hljs-comment">// false</span><br>System.out.println(<span class="hljs-string">&quot;z&quot;</span>.matches(<span class="hljs-string">&quot;[^abc]&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-string">&quot;zz&quot;</span>.matches(<span class="hljs-string">&quot;[^abc]&quot;</span>)); <span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-string">&quot;zz&quot;</span>.matches(<span class="hljs-string">&quot;[^abc][^abc]&quot;</span>)); <span class="hljs-comment">//true</span><br><span class="hljs-comment">// a到zA到Z(包括头尾的范围)</span><br>System.out.println(<span class="hljs-string">&quot;-----------3-------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-z]&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-string">&quot;z&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-z]&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-string">&quot;aa&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-z]&quot;</span>));<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-string">&quot;zz&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z]&quot;</span>)); <span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-string">&quot;zz&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z][a-zA-Z]&quot;</span>)); <span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;0&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z]&quot;</span>));<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-string">&quot;0&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&quot;</span>));<span class="hljs-comment">//true</span><br><span class="hljs-comment">// [a-d[m-p]] a到d，或m到p</span><br>System.out.println(<span class="hljs-string">&quot;-----------4-------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[a-d[m-p]]&quot;</span>));<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;d&quot;</span>.matches(<span class="hljs-string">&quot;[a-d[m-p]]&quot;</span>)); <span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;m&quot;</span>.matches(<span class="hljs-string">&quot;[a-d[m-p]]&quot;</span>)); <span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;p&quot;</span>.matches(<span class="hljs-string">&quot;[a-d[m-p]]&quot;</span>)); <span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;e&quot;</span>.matches(<span class="hljs-string">&quot;[a-d[m-p]]&quot;</span>)); <span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-string">&quot;0&quot;</span>.matches(<span class="hljs-string">&quot;[a-d[m-p]]&quot;</span>)); <span class="hljs-comment">//false</span><br><span class="hljs-comment">// [a-z&amp;&amp;[def]] a-z和def的交集。为:d，e，f</span><br>System.out.println(<span class="hljs-string">&quot;----------5------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[a-z&amp;[def]]&quot;</span>)); <span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-string">&quot;d&quot;</span>.matches(<span class="hljs-string">&quot;[a-z&amp;&amp;[def]]&quot;</span>)); <span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;0&quot;</span>.matches(<span class="hljs-string">&quot;[a-z&amp;&amp;[def]]&quot;</span>)); <span class="hljs-comment">//false</span><br><span class="hljs-comment">// [a-z&amp;&amp;[^bc]] a-z和非bc的交集。(等同于[ad-z])</span><br>System.out.println(<span class="hljs-string">&quot;-----------6------------_&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>));<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;b&quot;</span>.matches(<span class="hljs-string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-string">&quot;0&quot;</span>.matches(<span class="hljs-string">&quot;[a-z&amp;&amp;[^bc]]&quot;</span>)); <span class="hljs-comment">//false</span><br><span class="hljs-comment">// [a-z&amp;&amp;[^m-p]] a到z和除了m到p的交集。(等同于[a-1q-z])</span><br>System.out.println(<span class="hljs-string">&quot;-----------7-------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;[a-z&amp;&amp;[^m-p]]&quot;</span>)); <span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;m&quot;</span>.matches(<span class="hljs-string">&quot;[a-z&amp;&amp;[^m-p]]&quot;</span>)); <span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-string">&quot;0&quot;</span>.matches(<span class="hljs-string">&quot;[a-z&amp;&amp;[^m-p]]&quot;</span>)); <span class="hljs-comment">//false</span><br><br><br><br></code></pre></td></tr></table></figure><h2 id="x20-正则表达式-逻辑运算符"><a href="#x20-正则表达式-逻辑运算符" class="headerlink" title="&#x20;正则表达式-逻辑运算符"></a>&#x20;正则表达式-逻辑运算符</h2><ul><li>语法示例：<ol><li>&amp;&amp;：并且</li><li>|    ：或者</li><li>\  ：转义字符</li></ol></li><li>代码示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;had&quot;</span>;<br><br><span class="hljs-comment">//1.要求字符串是小写辅音字符开头，后跟ad</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[a-z&amp;&amp;[^aeiou]]ad&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;1.&quot;</span> + str.matches(regex));<br><br><span class="hljs-comment">//2.要求字符串是aeiou中的某个字符开头，后跟ad</span><br>regex = <span class="hljs-string">&quot;[a|e|i|o|u]ad&quot;</span>;<span class="hljs-comment">//这种写法相当于：regex = &quot;[aeiou]ad&quot;;</span><br>System.out.println(<span class="hljs-string">&quot;2.&quot;</span> + str.matches(regex));<br><br><br></code></pre></td></tr></table></figure><h2 id="正则表达式-预定义字符"><a href="#正则表达式-预定义字符" class="headerlink" title="正则表达式-预定义字符"></a>正则表达式-预定义字符</h2><ul><li>语法示例：<ol><li>“.” ： 匹配任何字符。</li><li>“\d”：任何数字[0-9]的简写</li><li>“\D”：任何非数字[^0-9]的简写；</li><li>“\s”： 空白字符：[ \t\n\x0B\f\r] 的简写</li><li>“\S”： 非空白字符：[^\s] 的简写</li><li>“\w”：单词字符：[a-zA-Z_0-9]的简写</li><li>“\W”：非单词字符：[^\w]</li></ol></li><li>代码示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">//.表示任意一个字符</span><br>System.out.println(<span class="hljs-string">&quot;你&quot;</span>.matches(<span class="hljs-string">&quot;..&quot;</span>)); <span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-string">&quot;你&quot;</span>.matches(<span class="hljs-string">&quot;.&quot;</span>)); <span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;你a&quot;</span>.matches(<span class="hljs-string">&quot;..&quot;</span>));<span class="hljs-comment">//true</span><br><br><span class="hljs-comment">// \\d 表示任意的一个数字</span><br><span class="hljs-comment">// \\d只能是任意的一位数字</span><br><span class="hljs-comment">// 简单来记:两个\表示一个\</span><br>System.out.println(<span class="hljs-string">&quot;a&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>)); <span class="hljs-comment">// false</span><br>System.out.println(<span class="hljs-string">&quot;3&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-string">&quot;333&quot;</span>.matches(<span class="hljs-string">&quot;\\d&quot;</span>)); <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">//\\w只能是一位单词字符[a-zA-Z_0-9]</span><br>System.out.println(<span class="hljs-string">&quot;z&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-string">&quot;2&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-string">&quot;21&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>)); <span class="hljs-comment">// false</span><br>System.out.println(<span class="hljs-string">&quot;你&quot;</span>.matches(<span class="hljs-string">&quot;\\w&quot;</span>));<span class="hljs-comment">//false</span><br><br><span class="hljs-comment">// 非单词字符</span><br>System.out.println(<span class="hljs-string">&quot;你&quot;</span>.matches(<span class="hljs-string">&quot;\\W&quot;</span>)); <span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-string">&quot;---------------------------------------------&quot;</span>);<br><span class="hljs-comment">// 以上正则匹配只能校验单个字符。</span><br><br><br><span class="hljs-comment">// 必须是数字 字母 下划线 至少 6位</span><br>System.out.println(<span class="hljs-string">&quot;2442fsfsf&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;6,&#125;&quot;</span>));<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;244f&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;6,&#125;&quot;</span>));<span class="hljs-comment">//false</span><br><br><span class="hljs-comment">// 必须是数字和字符 必须是4位</span><br>System.out.println(<span class="hljs-string">&quot;23dF&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;23 F&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));<span class="hljs-comment">//false</span><br>System.out.println(<span class="hljs-string">&quot;23dF&quot;</span>.matches(<span class="hljs-string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));<span class="hljs-comment">//true</span><br>System.out.println(<span class="hljs-string">&quot;23_F&quot;</span>.matches(<span class="hljs-string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));<span class="hljs-comment">//false</span><br>    <br><br></code></pre></td></tr></table></figure><h2 id="x20-正则表达式-数量词"><a href="#x20-正则表达式-数量词" class="headerlink" title="&#x20;正则表达式-数量词"></a>&#x20;正则表达式-数量词</h2><ul><li>语法示例：<ol><li>X? : 0次或1次</li><li>X* : 0次到多次</li><li>X+ : 1次或多次</li><li>X{n} : 恰好n次</li><li>X{n,} : 至少n次</li><li>X{n,m}: n到m次(n和m都是包含的)</li></ol></li><li>代码示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// 必须是数字 字母 下划线 至少 6位</span><br>   System.out.println(<span class="hljs-string">&quot;2442fsfsf&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;6,&#125;&quot;</span>));<span class="hljs-comment">//true</span><br>   System.out.println(<span class="hljs-string">&quot;244f&quot;</span>.matches(<span class="hljs-string">&quot;\\w&#123;6,&#125;&quot;</span>));<span class="hljs-comment">//false</span><br><br>   <span class="hljs-comment">// 必须是数字和字符 必须是4位</span><br>   System.out.println(<span class="hljs-string">&quot;23dF&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));<span class="hljs-comment">//true</span><br>   System.out.println(<span class="hljs-string">&quot;23 F&quot;</span>.matches(<span class="hljs-string">&quot;[a-zA-Z0-9]&#123;4&#125;&quot;</span>));<span class="hljs-comment">//false</span><br>   System.out.println(<span class="hljs-string">&quot;23dF&quot;</span>.matches(<span class="hljs-string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));<span class="hljs-comment">//true</span><br>   System.out.println(<span class="hljs-string">&quot;23_F&quot;</span>.matches(<span class="hljs-string">&quot;[\\w&amp;&amp;[^_]]&#123;4&#125;&quot;</span>));<span class="hljs-comment">//false</span><br><br></code></pre></td></tr></table></figure><h2 id="String类的replaceAll方法中使用正则表达式"><a href="#String类的replaceAll方法中使用正则表达式" class="headerlink" title="String类的replaceAll方法中使用正则表达式"></a>String类的replaceAll方法中使用正则表达式</h2><ul><li>String类的replaceAll()方法原型：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(String regex,String newStr)</span><br><span class="hljs-comment">//参数regex表示一个正则表达式。可以将当前字符串中匹配regex正则表达式的字符串替换为newStr。</span><br></code></pre></td></tr></table></figure><ul><li>代码示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;张三dodjh李四owfhohs王五&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> s.replaceAll(<span class="hljs-string">&quot;[\\w&amp;&amp;[^_]]+&quot;</span>, <span class="hljs-string">&quot;vs&quot;</span>);<br>System.out.println(result1);<br></code></pre></td></tr></table></figure><h2 id="x20-正则表达式-分组括号"><a href="#x20-正则表达式-分组括号" class="headerlink" title="&#x20;正则表达式-分组括号( )"></a>&#x20;正则表达式-分组括号( )</h2><p>细节：如何识别组号？</p><p>只看左括号，不看有括号，按照左括号的顺序，从左往右，依次为第一组，第二组，第三组等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//判断一个字符串的开始字符和结束字符是否一致?只考虑一个字符</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(.).+\\1&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;a123a&quot;</span>.matches(regex1));<br>System.out.println(<span class="hljs-string">&quot;b456b&quot;</span>.matches(regex1));<br>System.out.println(<span class="hljs-string">&quot;17891&quot;</span>.matches(regex1));<br>System.out.println(<span class="hljs-string">&quot;&amp;abc&amp;&quot;</span>.matches(regex1));<br>System.out.println(<span class="hljs-string">&quot;a123b&quot;</span>.matches(regex1));<br><br><br><br><span class="hljs-comment">//判断一个字符串的开始部分和结束部分是否一致?可以有多个字符</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(.+).+\\1&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;abc123abc&quot;</span>.matches(regex2));<br>System.out.println(<span class="hljs-string">&quot;b456b&quot;</span>.matches(regex2));<br>System.out.println(<span class="hljs-string">&quot;123789123&quot;</span>.matches(regex2));<br>System.out.println(<span class="hljs-string">&quot;&amp;!@abc&amp;!@&quot;</span>.matches(regex2));<br>System.out.println(<span class="hljs-string">&quot;abc123abd&quot;</span>.matches(regex2));<br><br><br><span class="hljs-comment">//判断一个字符串的开始部分和结束部分是否一致?开始部分内部每个字符也需要一致</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;((.)\\2*).+\\1&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;aaa123aaa&quot;</span>.matches(regex3));<br>System.out.println(<span class="hljs-string">&quot;bbb456bbb&quot;</span>.matches(regex3));<br>System.out.println(<span class="hljs-string">&quot;111789111&quot;</span>.matches(regex3));<br>System.out.println(<span class="hljs-string">&quot;&amp;&amp;abc&amp;&amp;&quot;</span>.matches(regex3));<br>System.out.println(<span class="hljs-string">&quot;aaa123aab&quot;</span>.matches(regex3));<br></code></pre></td></tr></table></figure><h2 id="忽略大小写的写法"><a href="#忽略大小写的写法" class="headerlink" title="忽略大小写的写法"></a>忽略大小写的写法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//(?i) ：表示忽略后面数据的大小写</span><br><span class="hljs-comment">//忽略abc的大小写</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(?i)abc&quot;</span>;<br><span class="hljs-comment">//a需要一模一样，忽略bc的大小写</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a(?i)bc&quot;</span>;<br><span class="hljs-comment">//ac需要一模一样，忽略b的大小写</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a((?i)b)c&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="非捕获分组"><a href="#非捕获分组" class="headerlink" title="非捕获分组"></a>非捕获分组</h2><p>非捕获分组：分组之后不需要再用本组数据，仅仅是把数据括起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//身份证号码的简易正则表达式</span><br><span class="hljs-comment">//非捕获分组:仅仅是把数据括起来</span><br><span class="hljs-comment">//特点:不占用组号</span><br><span class="hljs-comment">//(?:) (?=) (?!)都是非捕获分组//更多的使用第一个</span><br><span class="hljs-comment">//String regex1 =&quot;[1-9]\\d&#123;16&#125;(?:\\d|x|x)\\1&quot;;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex2</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;[1-9]\\d&#123;16&#125;(\\d Xx)\\1&quot;</span>;<br><span class="hljs-comment">//^([01]\d|2[0-3]):[0-5]\d:[@-5]\d$</span><br><br>System.out.println(<span class="hljs-string">&quot;41080119930228457x&quot;</span>.matches(regex2));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>API（1）</title>
    <link href="/2023/01/19/API%EF%BC%881%EF%BC%89/"/>
    <url>/2023/01/19/API%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="API（1）"><a href="#API（1）" class="headerlink" title="API（1）"></a>API（1）</h1><h1 id="x20-Math类"><a href="#x20-Math类" class="headerlink" title="&#x20;Math类"></a>&#x20;Math类</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>API文档中关于Math类的定义如下：</p><p><img src="/../image/API%EF%BC%881%EF%BC%89/image_NtdZvaUfIf.png"></p><p>Math类所在包为java.lang包，因此在使用的时候不需要进行导包。并且Math类被final修饰了，因此该类是不能被继承的。</p><h2 id="x20-常见方法"><a href="#x20-常见方法" class="headerlink" title="&#x20;常见方法"></a>&#x20;常见方法</h2><p>Math的常见方法如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">public static int abs(int a)          // 返回参数的绝对值<br>public static double ceil(double a)        // 返回大于或等于参数的最小整数<br>public static double floor(double a)      // 返回小于或等于参数的最大整数<br>public static int round(float a)        // 按照四舍五入返回最接近参数的int类型的值<br>public static int max(int a,int b)        // 获取两个int值中的较大值<br>public static int min(int a,int b)        // 获取两个int值中的较小值<br>public static double pow (double a,double b)  // 计算a的b次幂的值<br>public static double random()          // 返回一个[0.0,1.0)的随机值<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Main &#123;<br>    public static void main(String[] args) &#123;<br>                // public static int abs(int a)         返回参数的绝对值<br>                System.out.println(&quot;-2的绝对值为：&quot; + Math.abs(-2));<br>                System.out.println(&quot;2的绝对值为：&quot; + Math.abs(2));<br><br>                // public static double ceil(double a)  返回大于或等于参数的最小整数<br>                System.out.println(&quot;大于或等于23.45的最小整数位：&quot; + Math.ceil(23.45));<br>                System.out.println(&quot;大于或等于-23.45的最小整数位：&quot; + Math.ceil(-23.45));<br><br>                // public static double floor(double a) 返回小于或等于参数的最大整数<br>                System.out.println(&quot;小于或等于23.45的最大整数位：&quot; + Math.floor(23.45));<br>                System.out.println(&quot;小于或等于-23.45的最大整数位：&quot; + Math.floor(-23.45));<br><br>                // public static int round(float a)     按照四舍五入返回最接近参数的int<br>                System.out.println(&quot;23.45四舍五入的结果为：&quot; + Math.round(23.45));<br>                System.out.println(&quot;23.55四舍五入的结果为：&quot; + Math.round(23.55));<br><br>                // public static int max(int a,int b)   返回两个int值中的较大值<br>                System.out.println(&quot;23和45的最大值为: &quot; + Math.max(23, 45));<br><br>                // public static int min(int a,int b)   返回两个int值中的较小值<br>                System.out.println(&quot;12和34的最小值为: &quot; + Math.min(12 , 34));<br><br>                // public static double pow (double a,double b)返回a的b次幂的值<br>                System.out.println(&quot;2的3次幂计算结果为: &quot; + Math.pow(2,3));<br><br>                // public static double random()返回值为double的正值，[0.0,1.0)<br>                System.out.println(&quot;获取到的0-1之间的随机数为: &quot; + Math.random());<br>            &#125;<br><br>        &#125;<br><br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">-2的绝对值为：2<br>2的绝对值为：2<br>大于或等于23.45的最小整数位：24.0<br>大于或等于-23.45的最小整数位：-23.0<br>小于或等于23.45的最大整数位：23.0<br>小于或等于-23.45的最大整数位：-24.0<br>23.45四舍五入的结果为：23<br>23.55四舍五入的结果为：24<br>23和45的最大值为: 45<br>12和34的最小值为: 12<br>2的3次幂计算结果为: 8.0<br>获取到的0-1之间的随机数为: 0.13374325372180984<br><br></code></pre></td></tr></table></figure><h1 id="x20-System类"><a href="#x20-System类" class="headerlink" title="&#x20;System类"></a>&#x20;System类</h1><h2 id="x20-概述"><a href="#x20-概述" class="headerlink" title="&#x20;概述"></a>&#x20;概述</h2><blockquote></blockquote><p>API文档中关于System类的定义如下：</p><p><img src="/../image/API%EF%BC%881%EF%BC%89/image_SIPfd9DscH.png"></p><p>System类所在包为java.lang包，因此在使用的时候不需要进行导包。并且System类被final修饰了，因此该类是不能被继承的。</p><p>System包含了系统操作的一些常用的方法。比如获取当前时间所对应的毫秒值，再比如终止当前JVM等等。</p><p>在API文档中没有体现可用的构造方法，因此我们就不能直接通过new关键字去创建System类的对象。同时我们发现System类中的方法都是静态的，因此在使用的时候我们可以直接通过类名去调用（Nested</p><p>Class Summary内部类或者内部接口的描述）。</p><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><p>System类中的常见方法如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">public static long currentTimeMillis()      // 获取当前时间所对应的毫秒值<br>public static void exit(int status)        // 终止当前正在运行的Java虚拟机，0表示正常退出，非零表示异常退出<br>public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length); // 进行数值元素copy<br></code></pre></td></tr></table></figure><p>演示currentTimeMillis方法:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Main &#123;<br>    public static void main(String[] args) &#123;<br>        long millis = System.currentTimeMillis();<br>        System.out.println(&quot;当前时间所对应的毫秒值为：&quot; + millis);<br>            &#125;<br>        &#125;<br><br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">当前时间所对应的毫秒值为：1683525821289<br></code></pre></td></tr></table></figure><p>获取到当前时间的毫秒值的意义：我们常常来需要统计某一段代码的执行时间。此时我们就可以在执行这段代码之前获取一次时间，在执行完毕以后再次获取一次系统时间，然后计算两个时间的差值，</p><p>演示exit方法:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Main &#123;<br>    public static void main(String[] args) &#123;<br><br>        System.out.println(&quot;程序开始执行.....&quot;);<br><br>        // 终止JVM<br>        System.exit(0);<br><br>        // 输出<br>        System.out.println(&quot;程序终止..........&quot;);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">程序开始执行.....<br></code></pre></td></tr></table></figure><p>此时可以看到在控制台只输出了”程序开始了…”，由于JVM终止了，因此输出”程序终止了…”这段代码没有被执行。</p><p>演示arraycopy方法:</p><p>方法参数说明：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">// src:    源数组<br>// srcPos：  源数值的开始位置<br>// dest：    目标数组<br>// destPos： 目标数组开始位置<br>// length:   要复制的元素个数<br>public static native void arraycopy(Object src,  int  srcPos, Object dest, int destPos, int length); <br></code></pre></td></tr></table></figure><p><strong>arraycopy方法底层细节：</strong></p><p>1.如果数据源数组和目的地数组都是基本数据类型，那么两者的类型必须保持一致，否则会报错</p><p>2.在拷贝的时候需要考虑数组的长度，如果超出范围也会报错</p><p>3.如果数据源数组和目的地数组都是引用数据类型，那么子类类型可以赋值给父类类型</p><h1 id="x20-Runtime"><a href="#x20-Runtime" class="headerlink" title="&#x20;Runtime"></a>&#x20;Runtime</h1><h2 id="x20-概述-1"><a href="#x20-概述-1" class="headerlink" title="&#x20;概述"></a>&#x20;概述</h2><p>​Runtime表示Java中运行时对象，可以获取到程序运行时设计到的一些信息</p><h2 id="x20-常见方法-1"><a href="#x20-常见方法-1" class="headerlink" title="&#x20;常见方法"></a>&#x20;常见方法</h2><p>Object类中的常见方法如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">public static Runtime getRuntime()    //当前系统的运行环境对象<br>public void exit(int status)      //停止虚拟机<br>public int availableProcessors()    //获得CPU的线程数<br>public long maxMemory()            //JVM能从系统中获取总内存大小（单位byte）<br>public long totalMemory()        //JVM已经从系统中获取总内存大小（单位byte）<br>public long freeMemory()        //JVM剩余内存大小（单位byte）<br>public Process exec(String command)   //运行cmd命令<br></code></pre></td></tr></table></figure><h1 id="x20-Object类"><a href="#x20-Object类" class="headerlink" title="&#x20;Object类"></a>&#x20;Object类</h1><h2 id="x20-概述-2"><a href="#x20-概述-2" class="headerlink" title="&#x20;概述"></a>&#x20;概述</h2><blockquote></blockquote><p>查看API文档，我们可以看到API文档中关于Object类的定义如下：</p><p><img src="/../image/API%EF%BC%881%EF%BC%89/image_Rxq6_raHys.png"></p><p>Object类所在包是java.lang包。Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类；换句话说，该类所具备的方法，其他所有类都继承了。</p><p>但是一般情况下我们很少去主动的创建Object类的对象，调用其对应的方法。更多的是创建Object类的某个子类对象，然后通过子类对象调用Object类中的方法。</p><h2 id="x20-常见方法-2"><a href="#x20-常见方法-2" class="headerlink" title="&#x20;常见方法"></a>&#x20;常见方法</h2><p>Object类中的常见方法如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">public String toString()        //返回该对象的字符串表示形式(可以看做是对象的内存地址值)<br>public boolean equals(Object obj)    //比较两个对象地址值是否相等；true表示相同，false表示不相同<br>protected Object clone()          //对象克隆<br></code></pre></td></tr></table></figure><p><strong>对象克隆的分类：</strong></p><blockquote><p>深克隆和浅克隆</p></blockquote><p><strong>浅克隆：</strong></p><p><img src="/../image/API%EF%BC%881%EF%BC%89/%E6%B5%85%E5%85%8B%E9%9A%86_fQwR6qn_RQ.png"></p><p>​不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来</p><p>​基本数据类型拷贝过来的是具体的数据，引用数据类型拷贝过来的是地址值。</p><p>​Object类默认的是浅克隆</p><p><strong>深克隆：</strong></p><p><img src="/../image/API%EF%BC%881%EF%BC%89/%E6%B7%B1%E5%85%8B%E9%9A%86_jsvwkuB5wN.png"></p><p>​基本数据类型拷贝过来，字符串复用，引用数据类型会重新创建新的</p><h1 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>​平时在存储整数的时候，Java中默认是int类型，int类型有取值范围：-2147483648 ~ 2147483647。如果数字过大，我们可以使用long类型，但是如果long类型也表示不下怎么办呢？</p><p>​就需要用到BigInteger，可以理解为：大的整数。</p><p>​有多大呢？理论上最大到42亿的21亿次方</p><p>​基本上在内存撑爆之前，都无法达到这个上限。</p><h2 id="x20-概述-3"><a href="#x20-概述-3" class="headerlink" title="&#x20; 概述"></a>&#x20; 概述</h2><p>API文档中关于BigInteger类的定义如下：</p><p><img src="/../image/API%EF%BC%881%EF%BC%89/image_k3suJ6zlgU.png"></p><p>BigInteger所在包是在java.math包下，因此在使用的时候就需要进行导包。我们可以使用BigInteger类进行大整数的计算</p><h2 id="x20-常见方法-3"><a href="#x20-常见方法-3" class="headerlink" title="&#x20;常见方法"></a>&#x20;常见方法</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">public BigInteger(int num, Random rnd)     //获取随机大整数，范围：[0 ~ 2的num次方-1]<br>public BigInteger(String val)         //获取指定的大整数<br>public BigInteger(String val, int radix)   //获取指定进制的大整数<br>    <br>下面这个不是构造，而是一个静态方法获取BigInteger对象<br>public static BigInteger valueOf(long val)   //静态方法获取BigInteger的对象，内部有优化<br></code></pre></td></tr></table></figure><p><strong>构造方法小结：</strong></p><ul><li>如果BigInteger表示的数字没有超出long的范围，可以用静态方法获取。</li><li>如果BigInteger表示的超出long的范围，可以用构造方法获取。</li><li>对象一旦创建，BigInteger内部记录的值不能发生改变。</li><li>只要进行计算都会产生一个新的BigInteger对象</li></ul><h2 id="x20-底层存储方式："><a href="#x20-底层存储方式：" class="headerlink" title="&#x20;底层存储方式："></a>&#x20;底层存储方式：</h2><p>对于计算机而言，其实是没有数据类型的概念的，都是0101010101，数据类型是编程语言自己规定的，所以在实际存储的时候，先把具体的数字变成二进制，每32个bit为一组，存储在数组中。</p><p>数组中最多能存储元素个数：21亿多</p><p>数组中每一位能表示的数字：42亿多</p><p>理论上，BigInteger能表示的最大数字为：42亿的21亿次方。</p><p>但是还没到这个数字，电脑的内存就会撑爆，所以一般认为BigInteger是无限的。</p><p>存储方式如图所示：</p><p><img src="/../image/API%EF%BC%881%EF%BC%89/bigInteger%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86_5q_hL7n_-b.png"></p><h1 id="x20-BigDecimal类"><a href="#x20-BigDecimal类" class="headerlink" title="&#x20;BigDecimal类"></a>&#x20;BigDecimal类</h1><h2 id="x20-概述-4"><a href="#x20-概述-4" class="headerlink" title="&#x20;概述"></a>&#x20;概述</h2><p>API文档中关于BigDecimal类的定义如下：</p><p><img src="/../image/API%EF%BC%881%EF%BC%89/image_fh9kt6uMbB.png"></p><p>BigDecimal所在包是在java.math包下，因此在使用的时候就需要进行导包。我们可以使用BigDecimal类进行更加精准的数据计算。</p><p>BigDecimal类中使用最多的还是提供的进行四则运算的方法，如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">public BigDecimal add(BigDecimal value)        // 加法运算<br>public BigDecimal subtract(BigDecimal value)    // 减法运算<br>public BigDecimal multiply(BigDecimal value)    // 乘法运算<br>public BigDecimal divide(BigDecimal value)      // 触发运算<br></code></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public static void main(String[] args) &#123;<br><br>        // 创建两个BigDecimal对象<br>        BigDecimal b1 = new BigDecimal(&quot;2.1&quot;) ;<br>        BigDecimal b2 = new BigDecimal(&quot;0.7&quot;) ;<br>        System.out.println(b1.add(b2));         // 进行加法运算<br>        System.out.println(b1.subtract(b2));    // 进行减法运算<br>        System.out.println(b1.multiply(b2));    // 进行乘法运算<br>        System.out.println(b1.divide(b2));      // 进行除法运算<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">2.8<br>1.4<br>1.47<br>3<br><br></code></pre></td></tr></table></figure><p>此时我们可以看到使用BigDecimal类来完成浮点数的计算不会存在损失精度的问题。</p><p>除法的特殊情况:</p><p>如果使用BigDecimal类型的数据进行除法运算的时候，得到的结果是一个无限循环小数，那么就会报错：ArithmeticException。 如下代码所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Main &#123;<br>    public static void main(String[] args) &#123;<br><br>        BigDecimal b1 = new BigDecimal(&quot;1&quot;) ;<br>        BigDecimal b2 = new BigDecimal(&quot;3&quot;) ;<br>        System.out.println(b1.divide(b2));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">Exception in thread &quot;main&quot; java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.<br>  at java.math.BigDecimal.divide(BigDecimal.java:1690)<br>  at Main.main(Main.java:11)<br></code></pre></td></tr></table></figure><p>针对这个问题怎么解决，此时我们就需要使用到BigDecimal类中另外一个divide方法，如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)<br></code></pre></td></tr></table></figure><p>上述divide方法参数说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">divisor:      除数对应的BigDecimal对象；<br>scale:        精确的位数；<br>roundingMode:    取舍模式；<br><br></code></pre></td></tr></table></figure><p>解决方法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">public class Main &#123;<br>    public static void main(String[] args) &#123;<br>            // 创建两个BigDecimal对象<br>            BigDecimal b1 = new BigDecimal(&quot;1&quot;) ;<br>            BigDecimal b2 = new BigDecimal(&quot;3&quot;) ;<br>            System.out.println(b1.divide(b2 , 2 , RoundingMode.FLOOR));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">0.33<br></code></pre></td></tr></table></figure><p>小结：后期在进行两个数的除法运算的时候，我们常常使用的是可以设置取舍模式的divide方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
