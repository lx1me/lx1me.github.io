

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="高可用集群Keepalived集群简介!!!!    类型 解析    高扩展集群 在当前业务环境集群中，所有的主机节点都处于正常的工作活动状态，它们共同承担起用户的请求带来的工作负载压力，保证用户的正常访问。   高可用集群 将核心业务使用多台 (一般是 2 台) 主机共同工作，支撑并保障核心业务的正常运行，尤其是业务的对外不间断的对外提供服务。核心特点就是 “冗余”，它存在的目的就是为了解决单">
<meta property="og:type" content="article">
<meta property="og:title" content="关于">
<meta property="og:url" content="https://lx1me.github.io/2024/05/10/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4Keepalived/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="高可用集群Keepalived集群简介!!!!    类型 解析    高扩展集群 在当前业务环境集群中，所有的主机节点都处于正常的工作活动状态，它们共同承担起用户的请求带来的工作负载压力，保证用户的正常访问。   高可用集群 将核心业务使用多台 (一般是 2 台) 主机共同工作，支撑并保障核心业务的正常运行，尤其是业务的对外不间断的对外提供服务。核心特点就是 “冗余”，它存在的目的就是为了解决单">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lx1me.github.io/image/image-20250321113325305.png">
<meta property="og:image" content="https://lx1me.github.io/image/image-20250321113635027.png">
<meta property="og:image" content="https://lx1me.github.io/image/image-20250321113724019.png">
<meta property="article:published_time" content="2024-05-09T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-09T03:58:34.105Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="随笔">
<meta property="article:tag" content="记录">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lx1me.github.io/image/image-20250321113325305.png">
  
  
  
  <title>关于 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/scroll.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/gradient.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lx1me.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="关于"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-10 00:00" pubdate>
          2024年5月10日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          37 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="text-center">
  <div class="about-info">
    <div class="about-name">Fluid</div>
    <div class="about-intro">An elegant theme for Hexo</div>
    <div class="about-icons">
      
        
        
        
        <a href=https://github.com class="
           hint--bottom hint--rounded"
           aria-label="GitHub"
           target="_blank"
        >
          <i class="iconfont icon-github-fill" aria-hidden="true"></i>
          
        </a>
      
        
        
        
        <a href=https://douban.com class="
           hint--bottom hint--rounded"
           aria-label="豆瓣"
           target="_blank"
        >
          <i class="iconfont icon-douban-fill" aria-hidden="true"></i>
          
        </a>
      
        
        
        
        <a  class="qr-trigger
           "
           
           target="_self"
        >
          <i class="iconfont icon-wechat-fill" aria-hidden="true"></i>
          
            <img class="qr-img" src="/img/favicon.png" srcset="/img/loading.gif" lazyload alt="qrcode" />
          
        </a>
      
    </div>
  </div>
</div>

<article class="about-content page-content mt-5">
  <div class="markdown-body">
    <h1 id="高可用集群Keepalived"><a href="#高可用集群Keepalived" class="headerlink" title="高可用集群Keepalived"></a>高可用集群Keepalived</h1><h4 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h4><p>!!!!<img src="/../image/image-20250321113325305.png" srcset="/img/loading.gif" lazyload></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>高扩展集群</td>
<td>在当前业务环境集群中，所有的主机节点都处于正常的工作活动状态，它们共同承担起用户的请求带来的工作负载压力，保证用户的正常访问。</td>
</tr>
<tr>
<td>高可用集群</td>
<td>将核心业务使用多台 (一般是 2 台) 主机共同工作，支撑并保障核心业务的正常运行，尤其是业务的对外不间断的对外提供服务。核心特点就是 “冗余”，它存在的目的就是为了解决单点故障 (Single Point of Failure) 问题。</td>
</tr>
<tr>
<td>高性能集群</td>
<td>基于前两种技术实现的集群基础上，高效利用这些主机资源，结合某些特有的技术方案，提供强大的计算能力，从而实现特定用户大型任务的高复杂度数据处理功能，比如生物计算、大场景模拟计算、预测计算等。</td>
</tr>
</tbody></table>
<h4 id="高可用指标"><a href="#高可用指标" class="headerlink" title="高可用指标"></a>高可用指标</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">高可用集群是基于高扩展基础上的一个更高层次的网站稳定性解决方案。网站的稳定性体现在两个方面：网站可用性和恢复能力<br></code></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>序号</th>
<th>描述</th>
<th>简称</th>
<th>可用性级别</th>
<th>年度停机时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>基本的可用性</td>
<td>2 个 9</td>
<td>99%</td>
<td>87.6 小时</td>
</tr>
<tr>
<td>2</td>
<td>较高的可用性</td>
<td>3 个 9</td>
<td>99.9%</td>
<td>8.8 小时</td>
</tr>
<tr>
<td>3</td>
<td>故障自动恢复的可用性</td>
<td>4 个 9</td>
<td>99.99%</td>
<td>53 分钟</td>
</tr>
<tr>
<td>4</td>
<td>极高可用性</td>
<td>5 个 9</td>
<td>99.999%</td>
<td>5 分钟</td>
</tr>
</tbody></table>
<h4 id="恢复能力"><a href="#恢复能力" class="headerlink" title="恢复能力"></a>恢复能力</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell">所谓的恢复能力，指的是一个网站从发生故障到故障修复这个过程的能力，而这个能力涉及到两个子内容：数据恢复能力和业务恢复能力。<br>数据恢复能力 RPO(Recovery Point Obejective)<br> 是指业务系统所允许的在灾难过程中的最大数据丢失量，用来衡量高可用系统的数据冗余备份能力。<br> 例如，恢复到灾难发生前最后一次数据备份的数据状态。<br> <br>系统恢复能力 RTO(Recovery Time Objective)<br> 是指应用系统从灾难状态恢复到物理系统环境可运行状态所需的时间，用来衡量高可用系统的恢复能力。<br> 例如，服务器重启、数据库重启、数据恢复、应用回归正常运行。<br> <br>网络恢复能力 NRO(Network Recovery Objective)<br> 是指网络系统从灾难状态恢复到网络可连接状态所需的时间，用来衡量高可用系统的网络恢复能力。<br> 例如，用户在灾难后可以连接到灾备中心的时间。<br> <br>业务恢复能力 RAO(Recovery Access Objective)<br> 是指业务系统从灾难状态恢复到可运行状态所需的时间，用来衡量高可用系统的业务恢复能力。<br> 例如，用户在灾难后，可以感受到灾难前的业务应用状态。<br></code></pre></td></tr></table></figure>

<p>!!!!<img src="/../image/image-20250321113635027.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="高可用方式"><a href="#高可用方式" class="headerlink" title="高可用方式"></a>高可用方式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">对于集群来说，高可用的最主要的目的就是保证网站接入口的稳定性，通过一个虚拟的接入口，将真实的请求转发到不同地址(一般是两个)的真实接入口出，进而将请求转发到后续高扩展集群主机中。<br>这个虚拟的接入口，我们一般称之为VIP，这个VIP一般附加在后端的真实接入口，二这两个接入口一个做主一个做从，共同负担起VIP传输过来的信息。<br>做主的接口主机我们一般称之为Master或者Active，做备的接口主机我们一般称之为Slave或者Passive。<br></code></pre></td></tr></table></figure>

<p>!!!!<img src="/../image/image-20250321113724019.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><table>
<thead>
<tr>
<th>模式名称</th>
<th>模式解析</th>
</tr>
</thead>
<tbody><tr>
<td>主备模式 (Active&#x2F;Passive)</td>
<td>后端的高可用结点运行一致的服务实例，正常情况下，VIP 配置在主节点上，只有作为主的 Active 结点响应用户的请求，当主节点故障，备用结点 Passive 自动接管一切，当主节点恢复后，通过自动或者手动方式，用户的请求重新有主节点来接管，整个过程用户感受不到任何影响。</td>
</tr>
<tr>
<td>双主模式 (Active&#x2F;Active)</td>
<td>后端的高可用结点运行各自的服务实例，都可以正常接收用户访问请求，当 A 结点故障，他会将访问请求自动转移到正常运行的 B 结点上，从而保证不对用户产生影响。但是有可能在 A 节点出现异常的时候，有可能导致 B 节点因为负载的因素导致整体崩溃。</td>
</tr>
<tr>
<td>集群模式 (N+M)</td>
<td>在这种模式下，当主节点故障时候，后备结点主机会通过某些策略，从中选择一个结点，作为临时主节点，接管所有请求。原来的主节点恢复的时候，通过多种策略来响应。</td>
</tr>
</tbody></table>
<h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">为了实现高可用的效果，后端的高可用结点需要如下几种技术来保证：<br> 时间同步 和 心跳检测<br> <br>时间同步<br>   作为一个集群，他们彼此间进行信息通信的一个前提是，时间状态必须一致，如果出现一个主机在<span class="hljs-number">2018</span>年，一个在<span class="hljs-number">2020</span>年，这种情况下，集群的通信肯定会出现问题，甚至不会传输信息。<br>    我们一般会采用时间协议，从一个专用的时间服务器上获取时间，从而保证同一个集群中的所有主机时间都是一致的，这个协议我们一般使用ntp协议。<br>    <br>心跳检测<br>   对于高可用集群的各种模式来说，有一个关键的点就是：主节点故障了，从节点接管一切。这就涉及到了一种场景：高可用集群节点间需要知道彼此的状态，就类似于我们要知道一个人是否是活的，就看他有没有心跳。<br>    所以我们需要通过一种专用的技术来时刻了解集群节点间的状态，我们一般称这种技术为<span class="hljs-string">&quot;心跳检测&quot;</span>，常见的软件有VRRP。<br></code></pre></td></tr></table></figure>







<h2 id="Keepalived基础"><a href="#Keepalived基础" class="headerlink" title="Keepalived基础"></a><strong>Keepalived</strong>基础</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">vrrp 属于 网络层的一种 协议。<br><br>工作流程<br>keepalived部署在多台主机上(一般是两台)，keepalived服务启动后，会加载专用的配置文件，调用内核的LVS服务以创建虚拟服务器，并根据配置启用对外的统一访问接口，并且基于相关插件脚本对服务进行监控。<br> 为了保证服务对外的统一接口的高可用，VRRP协议将物理Router进行统一管理，并创建一个虚拟路由地址，作为外网的统一出口，物理Router内部通过VRRP机制进行内部通信，保证虚拟路由地址永远可用。<br> <br>通过我们对keepalived软件的结构和官方的介绍，我们可以知道，Keepalived其实就是通过整合和加<br>强LVS和VRRP软件，从而得到的一套适用于高扩展和高可用的软件整合解决方案。<br> 根据Keepalived软件的简单结构，我们可以了解到，我们要实现Keepalived的功能，需要在用户空间<br>安装相应的软件才可以。<br></code></pre></td></tr></table></figure>

<h4 id="vrrp"><a href="#vrrp" class="headerlink" title="vrrp"></a>vrrp</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs powershell">虚拟路由冗余协议(Virtual Router Redundancy Protocol，简称VRRP)是由IETF提出的解决局域网中配置静态网关出现单点故障现象的路由协议，其本质上是一种路由容错协议。<br><br>VRRP将局域网内的一组路由器虚拟为单个路由器。我们称该路由器组为VRRP备份组，它根据 <span class="hljs-string">&quot;优先级&quot;</span>选择一个Master主路由器，承担网关功能，其他路由器称为Backup从路由器。基于VRRP虚拟出来是路由我们称之为虚拟路由，该虚拟路由有独立的IP地址(VIP)。<br><br>工作模式：<br> 主/备：单个虚拟路由器<br> 主/主：主/备（虚拟路由器<span class="hljs-number">1</span>），备/主（虚拟路由器<span class="hljs-number">2</span>）<br> <br> 局域网内主机不知道后端真实的路由器的ip地址，仅仅知道这个虚拟路由的ip地址，让后将VIP设定为其数据包的出网地址，通过该虚拟路由与外部的其他网络进行通信。<br>    在整个过程中，如果Master路由器发生故障时，Backup取代Master继续履行网关职责，从而保证网络呢·`内的主机不间断地与外部网络进行通信。<br>    <br>虚拟路由器：Virtual Router <br>虚拟路由器标识：VRID(<span class="hljs-number">0</span><span class="hljs-literal">-255</span>)，唯一标识虚拟路由器<br>VIP：Virtual IP <br>VMAC：Virutal MAC (<span class="hljs-number">00</span><span class="hljs-literal">-00-5e-00-01-VRID</span>)<br>物理路由器：<br>    master：主设备<br>    backup：备用设备<br>    priority：优先级<br>    <br>通告：心跳，优先级等；周期性<br>工作方式：抢占式，非抢占式<br>安全认证：<br>    无认证 - 互相通信的时候，不需要任何认证信息<br>    简单字符认证：预共享密钥，通信双方使用简单字符进行基本的认证<br> MD5：通信双方使用md5的方式传输认证信息。<br>工作模式：<br>    主/备：单个虚拟路由器<br>    主/主：主/备（虚拟路由器<span class="hljs-number">1</span>），备/主（虚拟路由器<span class="hljs-number">2</span>）<br></code></pre></td></tr></table></figure>

<h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Keepalived 是一个基于 VRRP 协议的实现高可用的软件，在 Keepalived 中，抢占式和非抢占式是两种重要的工作模式<br><br>抢占式<br>工作原理<br>在抢占式模式下，优先级最高的主服务器会一直处于 Master 状态，只要它处于正常运行状态且网络连接正常。当主服务器出现故障或网络问题时，备份服务器会接管其工作，成为 Master 状态。一旦主服务器恢复正常，它会立即抢占回 Master 角色，重新接管工作。<br><br>优缺点<br>快速恢复：主服务器恢复后能迅速重新承担主要工作，确保服务的连续性和稳定性。<br>    资源利用高效：高优先级的服务器能及时获取控制权，充分发挥其性能优势。<br>缺点：<br> 频繁的抢占可能会导致网络抖动或服务短暂中断，对一些对稳定性要求极高的服务可能产生一定影响。<br> <br>适用场景<br>适用于对主服务器性能要求较高，且能容忍短暂服务中断的场景，如一些非关键业务的负载均衡场景。<br><br>非抢占式<br>工作原理<br>在非抢占式模式下，当主服务器出现故障时，备份服务器会接管成为 Master 状态。即使主服务器恢复正常，它也不会主动抢占 Master 角色，而是继续由备份服务器提供服务，直到备份服务器出现故障或其他异常情况，主服务器才会再次成为 Master。<br><br>优缺点<br>优点<br>    稳定性高：避免了频繁抢占带来的网络抖动和服务中断风险，能保持服务的稳定运行。<br>    减少切换次数：减少了服务器角色的切换频率，有利于延长服务器硬件的使用寿命。<br>缺点：<br>    主服务器恢复后不能及时发挥作用，可能造成资源浪费，特别是当主服务器性能远高于备份服务器<br>    <br>适用场景<br>  适用于对服务稳定性要求极高，不容许有任何短暂中断的关键业务场景，如金融交易系统、大型数据库系统等。<br></code></pre></td></tr></table></figure>

<h4 id="非抢占模式"><a href="#非抢占模式" class="headerlink" title="非抢占模式"></a>非抢占模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">注意：要关闭 VIP抢占，必须将各 Keepalived 服务器 state 配置为 BACKUP<br></code></pre></td></tr></table></figure>

<h4 id="nopreempt-属性解析"><a href="#nopreempt-属性解析" class="headerlink" title="nopreempt****属性解析"></a><strong>nopreempt****属性解析</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">在 Keepalived 配置文件的 VRRP 实例部分使用nopreempt参数，就是明确将该 VRRP 实例设置为非抢占式模式。在这种模式下，如果主服务器（具有较高优先级的设备）出现故障，备份服务器会接管并承担起主服务器的工作，转变为 Master 状态来提供服务。<br> 当原本的主服务器恢复正常后，由于nopreempt的设置，它不会主动抢占回 Master 角色，而是继续让备份服务器（当前的 Master）提供服务，直到备份服务器出现故障或其他异常情况，原主服务器才会再次成为 Master。<br> nopreempt的主要目的是为了保持服务的稳定性和连续性，避免由于主服务器的频繁恢复和抢占导致的<br>服务中断和网络抖动。<br> 应用场景<br>nopreempt通常应用于对服务连续性和稳定性要求极高的场景，如金融交易系统、大型数据库系统、电信核心网等关键业务领域。在这些场景中，任何短暂的服务中断都可能导致严重的后果，因此采用非抢占式模式可以确保在主服务器故障恢复后，不会因为抢占操作而引发潜在的服务中断风险，从而保障业务的稳定运行。 <br><br><br></code></pre></td></tr></table></figure>

<h4 id="非抢占延迟模式"><a href="#非抢占延迟模式" class="headerlink" title="非抢占延迟模式"></a>非抢占延迟模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell">工作原理<br>在非抢占延时模式下，当主服务器出现故障时，备份服务器会在等待一个特定的延时时间后，才会接管成为 Master 状态来提供服务。<br> 同样，当主服务器恢复正常后，它也不会立即抢占 Master 角色，而是要等待一段预先设置好的延时时间，确认当前的 Master（即原备份服务器）确实出现异常或故障，或者经过延时后网络状况等条件满足切换要求，才会重新成为 Master。这个延时时间可以通过配置参数来设定，一般以秒为单位。<br> <br>优缺点<br>优点:<br>    增强稳定性：进一步减少了不必要的切换操作，避免因网络瞬间波动或主服务器短暂故障恢复等情况导致的频繁切换，使系统更加稳定。<br>    避免资源浪费：可以防止备份服务器在主服务器只是短暂故障，很快就能恢复的情况下，不必要地接管服务，从而避免了资源的浪费和可能出现的服务质量下降。<br>缺点:<br>    响应速度相对较慢：由于增加了延时等待，在主服务器出现故障时，备份服务器不能立即接管服务，可能会导致服务中断时间相对较长。<br>    配置复杂：需要合理设置延时时间，若设置不当，可能无法达到预期效果，甚至可能影响系统的正常运行。<br>    <br>适用场景<br>适用于对稳定性要求极高，且能容忍一定服务中断时间的场景。例如大型数据中心的核心服务，数据同步和一致性要求很高，不希望因为偶尔的网络波动或服务器小故障就进行切换，通过设置非抢占延时模式，可以在确保服务稳定的前提下，减少不必要的切换带来的风险和数据不一致问题。还有一些工业控制系统，对可靠性要求高，但对实时性要求不是特别苛刻，也可以采用这种模式来保证系统的稳定运行。<br><br></code></pre></td></tr></table></figure>

<h4 id="消息传播"><a href="#消息传播" class="headerlink" title="消息传播"></a>消息传播</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs powershell">单播和多播<br>单播：<br> 是一种点到点的通信方式，数据从发送方发送到特定的一个接收方。就像打电话时，通话双方是一对一的关系，信息只在这两者之间传递。<br>多播：<br> 是一种点到多点的通信方式，数据从发送方发送到一组特定的接收方，这些接收方构成一个多播组。类似于在一个群组通话中，说话者的声音可以同时被群组中的多个成员听到。<br> <br>地址类型<br>单播：<br> 使用单播地址来标识网络中的单个主机。每个主机都有唯一的单播地址，如 IPv4 或 IPv6 地址，数据根据目标单播地址进行精确传输。 <br>多播：<br> 使用多播地址来标识一组接收者。多播地址是一个特殊的地址范围，用于标识不同的多播组，发送到多播地址的数据会被该组内的所有成员接收。<br> <br>网络资源占用<br>单播：<br> 当需要向多个目标发送相同数据时，发送方需要为每个目标单独发送一份数据，会占用较多的网络带宽和服务器资源。比如服务器向 <span class="hljs-number">10</span> 个客户端发送相同的文件，就需要发送 <span class="hljs-number">10</span> 次。<br>多播：<br> 发送方只需发送一份数据，网络中的路由器会根据多播组的成员信息，在必要的节点处对数据进行复制和转发，从而节省了网络带宽和服务器资源。同样是服务器向 <span class="hljs-number">10</span> 个客户端发送相同文件，采用多播只需发送一次数据。<br> <br>应用场景<br>单播：<br> 适用于需要一对一精确通信的场景，如远程登录、文件传输、视频点播等，这些应用需要确保数据准确无误地传输到特定的接收方。 <br>多播：<br> 适用于一对多或多对多的通信场景，如在线直播、视频会议、网络游戏中的多人对战、网络电视等，这些应用需要将相同的数据同时发送给多个接收方<br></code></pre></td></tr></table></figure>


  </div>

  
    <!-- Comments -->
    <article id="comments" lazyload>
      
      
        
      
      

    </article>
  
</article>





  



  



  



  



  





    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicRibbon.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/runtime.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/snowflake.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/Cherry.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
