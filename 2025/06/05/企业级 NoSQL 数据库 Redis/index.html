<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Hexo | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Hexo"><meta name="application-name" content="Hexo"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Hexo"><meta property="og:url" content="https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Redis/index.html"><meta property="og:site_name" content="Hexo"><meta property="og:description" content="企业级 NoSQL 数据库 RedisNoSQL 数据库什么是 NoSQL12345数据库主要分为两大类：关系型数据库与 NoSQL 数据库。关系型数据库，是建立在关系模型基础上的数据库，其借助于集合代数等数学概念和方法来处理数据库中的数据。主流的 MySQL、Oracle、MS SQL Serve"><meta property="og:locale" content="en"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="John Doe"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="企业级 NoSQL 数据库 RedisNoSQL 数据库什么是 NoSQL12345数据库主要分为两大类：关系型数据库与 NoSQL 数据库。关系型数据库，是建立在关系模型基础上的数据库，其借助于集合代数等数学概念和方法来处理数据库中的数据。主流的 MySQL、Oracle、MS SQL Serve"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Redis/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: John Doe","link":"Link: ","source":"Source: Hexo","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Hexo',
  title: 'Hexo',
  postAI: '',
  pageFillDescription: '企业级 NoSQL 数据库 Redis, NoSQL 数据库, 什么是 NoSQL, RDBMS和NOSQL对比, NoSQL的优点x2F缺点, CAP定理, Redis 简介, Redis 特性, 单线程, Redis 对比 Memcached, Redis 常见应用场景, 缓存的实现流程, 数据更新操作流程：, 数据读操作流程：, 缓存穿透缓存击穿和缓存雪崩, 缓存 crash, Pipeline 流水线, 未使用pipeline执行N条命令如下图, 使用了pipeline执行N条命令如下图, 两者性能对比, Redis 安装, Redis 持久化, RDB 工作原理, save 执行过程会使用主进程进行快照并生成临时文件temp-lt主进程PIDgt.rdb文件, RDB bgsave 实现快照, 实现 RDB 方法, RDB 模式的优缺点, AOF 工作原理, AOF 模式优缺点, RDB和AOF 的选择, Redis 数据类型, 列表 list, 集合 set, 有序集合 sorted set, 哈希 hash, 消息队列, 生产者消费者模式, 发布者订阅模式, Redis 集群与高可用, Redis 主从复制, 主从复制实现, Redis Cluster, Redis Cluster 架构, 数据分区, 虚拟槽分区, 集群扩容, 槽的迁移, 集群缩容, 下线节点的流程, 故障转移, Redis Cluster 部署架构说明, 生产环境：6台服务器分别是三组masterx2Fslave适用于生产环境, 集群扩容企业级数据库数据库什么是数据库主要分为两大类关系型数据库与数据库关系型数据库是建立在关系模型基础上的数据库其借助于集合代数等数学概念和方法来处理数据库中的数据主流的和都属于这类传统数据库数据库全称为意思就是适用关系型数据库的时候就使用关系型数据库不适用的时候可以考虑使用更加合适的数据存储是对不同于传统的关系型数据库的数据库管理系统的统称和对比高度组织化结构化数据结构化查询语言数据和关系都存储在单独的表中数据操纵语言数据定义语言严格的一致性基础事务代表着不仅仅是没有声明性查询语言没有预定义的模式最终一致性而非属性非结构化和不可预知的数据定理高性能高可用性和可伸缩性的优点缺点对比维度关系型数据库数据库特点数据关系模型基于关系模型结构化存储完整性约束基于二维表及其之间的联系需要连接并交差除等数据操作采用结构化的查询语言做数据读写操作需要数据的一致性需要事务甚至是强一致性非结构化的存储基于多维关系模型具有特有的使用场景优点保持数据的一致性事务处理可以进行等复杂查询通用化技术成熟高并发大数据下读写能力较强基本支持分布式易于扩展可伸缩简单弱结构化存储缺点数据读写必须经过解析大量数据高并发下读写性能不足对数据做读写或修改数据结构时需要加锁影响并发操作无法适应非结构化存储扩展困难昂贵复杂等复杂操作能力较弱事务支持较弱通用性差无完整约束复杂业务场景支持较差定理对于一个分布式计算系统不可能同时满足以下三点即一致性所有节点在同一时间具有相同的数据视图即可用性所有的节点都保持高可用性要求服务在接收到客户端请求后都能够给出响应分区是指系统中的节点由于网络故障无法相互通信导致系统被分成多个孤立的子系统遵循原理一个数据分布式系统不可能同时满足和和这个条件在服务器之间的网络出现异常的情况下一致性和可用性是不可能同时满足的必须要放弃一个来保证另一个这也正是定理所说的在分布式系统中总是存在的在发生的前提下一致性和可用性不能同时满足这种情况在做架构设计的时候就要考虑到要评估对业务的影响进行权衡决定放弃哪一个在通常的业务场景下系统不可用是不能接受的所以要优先保证可用性暂时放弃一致性根据原理将数据库分成了满足原则满足原则和满足原则三大类单点集群满足一致性可用性的系统通常在可扩展性上不太强大放弃分区容忍性即不进行分区不考虑由于网络不通或结点挂掉的问题则可以实现一致性和可用性那么系统将不是一个标准的分布式系统比如单一数据中心数据库所有节点都位于同一个数据中心并且节点之间的通信是高可靠的满足一致性分区容忍性的系统通常性能不是特别高放弃可用性追求强一致性和分区容错性例如的等集群就是追求的强一致再比如跨行转账一次转账请求要等待双方银行系统都完成整个事务才算完成满足可用性分区容忍性的系统通常可能对一致性要求低一些放弃一致性追求分区容忍性和可用性这是很多分布式系统设计时的选择例如主从复制默认是异步机制就可以实现但是用户接受所查询的到数据在一定时间内不是最新的简介远程字典服务是一个遵循开源协议的高性能的特性速度快基于内存语言实现单线程引号的单线程单线程为何如此快纯内存非阻塞避免线程切换和竞态消耗基于实现多路复用持久化支持多种数据类型支持多种编程语言功能丰富支持脚本发布订阅事务等功能简单代码短小精悍单机核心代码只有行左右单线程开发容易不依赖外部库使用简单主从复制支持高可用和分布式单线程一次只运行一条命令避免执行长慢命令其实不是单线程早期版本是单进程单线程版本后实际还有其它的线程实现特定功能如对比比较类别支持的数据结构哈希列表集合有序集合纯持久化支持有无高可用支持支持集群功能可以实现主动复制读写分离官方提供了集群管理工具能够实现主从服务监控故障自动转移这一切对于客户端都是透明的无需程序改动也无需人工介入需要二次开发存储容量最大最大内存分配临时申请空间可能导致碎片预分配内存池的方式管理内存能够省去内存分配时间虚拟内存使用有自己的机制理论上能够存储比物理内存更多的数据当数据超量时会引发把冷数据刷到磁盘上所有的数据存储在物理内存里网络模型非阻塞复用模型提供一些非存储之外的排序聚合功能在执行这些功能时复杂的计算会阻塞整个调度非阻塞复用模型水平扩展的支持可以横向扩展暂无多线程之前是只支持单线程支持多线程利用方面优于过期策略有专门线程清除缓存数据懒淘汰机制每次往缓存放入数据的时候都会存一个时间在读取的时候要和设置的时间做比较来判断是否过期单机约约源代码可读性代码清爽简洁可能是考虑了太多的扩展性多系统的兼容性代码不清爽适用场景复杂数据结构有持久化高可用需求存储内容较大纯数据量非常大并发量非常大的业务常见应用场景缓存缓存中数据比如网站的查询结果商品信息微博新闻消息共享实现集群中的多服务器间的共享计数器商品访问排行榜浏览数粉丝数关注点赞评论等和次数相关的数值统计场景社交朋友圈共同好友可能认识他们等地理位置基于地理信息系统实现摇一摇附近的人外卖等功能消息队列等日志系统缓存业务的订阅发布系统缓存的实现流程数据更新操作流程数据读操作流程缓存穿透缓存击穿和缓存雪崩缓存穿透缓存穿透是指缓存和数据库中都没有的数据而用户不断发起请求比如发起为为的数据或为特别大不存在的数据这时的用户很可能是攻击者攻击会导致数据库压力过大解决方法接口层增加校验如用户鉴权校验做基础校验的直接拦截从缓存取不到的数据在数据库中也没有取到这时也可以将对写为缓存有效时间可以设置短点如秒设置太长会导致正常情况也没法使用这样可以防止攻击用户反复用同一个暴力攻击缓存击穿缓存击穿是指缓存中没有但数据库中有的数据比如热点数据的缓存时间到期后这时由于并发用户特别多同时读缓存没读到数据又同时去数据库去取数据引起数据库压力瞬间增大造成过大压力解决方法设置热点数据永远不过期缓存雪崩缓存雪崩是指缓存中数据大批量到过期时间而查询数据量巨大引起数据库压力过大甚至机和缓存击穿不同的是缓存击穿指并发查同一条数据缓存雪崩是不同数据都过期了很多数据都查不到从而查数据库解决方法缓存数据的过期时间设置随机防止同一时间大量数据过期现象发生如果缓存数据库是分布式部署将热点数据均匀分布在不同搞得缓存数据库中设置热点数据永远不过期缓存缓存服务宕机造成缓存服务失效解决方法高可用集群流水线客户端执行一条命令分个过程发送命令网络传输命令排队命令执行网络传输返回结果这个过程称为简称往返时间指令可以一次性的批量对多个数据的执行操作所以有效节约了但大部分命令如不支持批量操作需要消耗次利用技术可以解决这一问题未使用执行条命令如下图使用了执行条命令如下图两者性能对比网络延迟非本机内网服务器异地机房安装安装方法包安装源码编译容器运行持久化是基于内存型的和是不同的使用内存进行数据保存如果想实现数据的持久化也也可支持将内存数据保存到硬盘文件中支持两种数据持久化保存方法工作原理是基于某个时间点的快照注意只保留当前最新版本的一个快照相当于中的完全备份持久化功能所生成的文件是一个经过压缩的二进制文件通过该文件可以还原生成该文件时数据库的状态因为文件是保存在磁盘中的所以即便服务进程甚至服务器宕机只要磁盘中文件存在就能将数据恢复支持和两种命令实现数据文件的持久化注意指令使用主进程进行备份而不生成新的子进程但是也会生成临时文件主进程文件执行过程会使用主进程进行快照并生成临时文件主进程文件实现快照首先从主进程先生成一个新的子进程此子进程负责将内存数据保存为一个临时文件子进程当数据保存完成后再将此临时文件改名为文件如果有前一次保存的文件则会被替换最后关闭此子进程由于只保留最后一个版本的文件如果想实现保存多个版本的数据需要人为实现实现方法同步不推荐使用使用主进程完成快照因此会阻塞其它命令执行异步后台执行不影响其它命令的执行会开启独立的子进程因此不会阻赛其它命令执行配置文件实现自动保存在配置文件中制定规则自动执行模式的优缺点优点快照只保存某个时间点的数据恢复的时候直接加载到内存即可不用做其他处理这种文件适合用于做灾备处理可以通过自定义时间点执行指令或者保存快照实现多个版本的备份比如可以在最近的小时内每小时备份一次文件并且在每个月的每一天也备份一个文件这样的话即使遇上问题也可以随时将数据集还原到指定的不同的版本在大数据集时恢复的速度比方式要快缺点不能实时保存数据可能会丢失自上一次执行备份到当前的内存数据如果需要尽量避免在服务器故障时丢失数据那么并不适合虽然允许设置不同的保存点来控制保存文件的频率但是因为文件需要保存整个数据集的状态所以它可能并不是一个非常快速的操作因此一般会超过分钟以上才保存一次文件在这种情况下一旦发生故障停机就可能会丢失较长时间的数据在数据集比较庞大时子进程可能会非常耗时造成服务器在一定时间内停止处理客户端请求如果数据集非常巨大并且时间非常紧张的话那么这种停止时间甚至可能会长达整整一秒或更久另外子进程完成生成文件的时间也会花更长时间工作原理即和都采有机制可以指定不同的保存策略默认为每秒钟执行一次按照操作的顺序地将变更命令追加至指定的日志文件尾部在第一次启用功能时会做一次完全备份后续将执行增量性备份相当于完全数据备份增量变化如果同时启用和进行恢复时默认文件优先级高于文件即会使用文件进行恢复在第一次开启功能时会自动备份所有数据到文件中后续只会记录数据的更新指令注意模式默认是关闭的第一次开启后并重启服务生效后会因为的优先级高于而默认没有数据文件存在从而导致所有数据丢失模式优缺点优点数据安全性相对较高根据所使用的策略是同步内存中所有已经修改的文件到存储设备默认是即每秒执行一次在这种配置下仍然可以保持良好的性能并且就算发生故障停机也最多只会丢失一秒钟的数据会在后台线程执行所以主线程可以继续努力地处理命令请求由于该机制对日志文件的写入操作采用的是模式因此在写入过程中不需要即使出现宕机现象也不会破坏日志文件中已经存在的内容然而如果本次操作只是写入了一半数据就出现了系统崩溃问题不用担心在下一次启动之前可以通过工具来解决数据一致性的问题可以在文件体积变得过大时自动地在后台对进行重写重写后的新文件包含了恢复当前数据集所需的最小命令集合整个重写操作是绝对安全的因为在创建新文件的过程中模式不断的将修改数据追加到现有的文件里面即使重写过程中发生停机现有的文件也不会丢失而一旦新文件创建完毕就会从旧文件切换到新文件并开始对新文件进行追加操作包含一个格式清晰易于理解的日志文件用于记录所有的修改操作事实上也可以通过该文件完成数据的重建文件有序地保存了对数据库执行的所有写入操作这些写入操作以协议的格式保存因此文件的内容非常容易被人读懂对文件进行分析也很轻松导出文件也非常简单举个例子如果不小心执行了命令但只要文件未被重写那么只要停止服务器移除文件末尾的命令并重启就可以将数据集恢复到执行之前的状态缺点即使有些操作是重复的也会全部记录的文件大小一般要大于格式的文件在恢复大数据集时的速度比的恢复速度要慢如果策略是保存到磁盘的速度甚至会可能会慢于出现的可能性更多和的选择如果主要充当缓存功能或者可以承受较长时间比如数分钟数据的丢失通常生产环境一般只需启用即可此也是默认值如果一点数据都不能丢失可以选择同时开启和一般不建议只开启数据类型字符串命令含义复杂度设置获取删除根据是否存在设置计数批量操作列表列表实际就是简单的字符串数组按照插入顺序进行排序支持双向读写可以添加一个元素到列表的头部左边或者尾部右边一个列表最多可以包含个元素每个列表元素用下标来标识下标表示列表的第一个元素以表示列表的第二个元素以此类推也可以使用负数下标以表示列表的最后一个元素表示列表的倒数第二个元素元素值可以重复常用于存入日志等场景此数据类型比较常用列表特点有序可重复左右都可以操作集合是一个无序的字符串合集同一个集合中的每个元素是唯一无重复的支持在两个不同的集合中对数据进行逻辑处理常用于取交集并集统计等场景例如实现共同的朋友集合特点无序无重复集合间操作集合间操作有序集合有序集合和集合类似是不包含相同字符串的合集它们的差别是每个有序集合的成员都关联着一个双精度浮点型的评分这个评分用于把有序集合中的成员按最低分到最高分排序有序集合的成员不能重复但评分可以重复一个有序集合中最多的成员数为个经常用于排行榜的场景有序集合特点有序无重复元素每个元素是由和组成可以重复不可以重复哈希即字典用于保存字符串字段和字符串值之间的映射即做为数据部分特别适合用于存储对象场景一个最多可以包含个键值对哈希特点无序对适用于存放相关的数据消息队列消息队列把要传输的数据放在队列中从而实现应用之间的数据交换常用功能可以实现多个应用系统之间的解耦异步削峰限流等常用的消息队列应用消息队列分为两种生产者消费者模式发布者订阅者模式生产者消费者模式生产者消费者模式下多个消费者同时监听一个频道用队列实现但是生产者产生的一个消息只能被最先抢到消息的一个消费者消费一次队列中的消息由可以多个生产者写入也可以有不同的消费者取出进行消费处理此模式应用广泛发布者订阅模式在发布者订阅者模式下发布者将消息发布到指定的频道事先监听此的一个或多个订阅者都会收到相同的消息即一个消息可以由多个订阅者获取到对于社交应用中的群聊群发群公告等场景适用于此模式集群与高可用主从复制主从复制架构和的主从模式类似也支持主从模式可以实现数据的跨主机的远程备份常见客户端连接主从的架构程序先连接到高可用性集群提供的虚拟再由调度将用户的请求至后端服务器来真正提供服务主从复制的特点一个可以有多个一个只能有一个数据流向是从到单向的可读可写只读主从复制实现当出现故障后可以自动提升一个节点变成新的因此需要设置和相同的连接密码此外当一个提升为新的时需要通过持久化实现数据的恢复当配置复制功能时强烈建议打开主服务器的持久化功能否则主节点服务应该要避免自动启动使用哨兵只能解决高可用问题实现的自动故障转移但仍然无法解决单节点的性能瓶颈问题为了解决单机性能的瓶颈提高服务整体性能可以使用分布式集群的解决方案架构需要至少个节点才能实现节点数量不限节点必须要超过半数以上可用否则集群将不可用即数据访问和选举将无法实现因此节点的数据一般为奇数当然一般每个都至少对应的有一个节点如果有三个主节点采用哈希槽的方式来分配个槽位此三个节点分别承担的区间可以是如以下方式分配节点节点节点数据分区如果是单机存储的话直接将数据存放在单机就行了但是如果是集群存储就需要考虑到数据分区了虚拟槽分区设置有的槽每个槽映射一个数据子集通过函数将数据存放在不同的槽位中每个集群的节点保存一部分的槽每个存储时先经过算法函数得到一个整数然后整数与取余得到槽的数值然后找到对应的节点将数据存放入对应的槽中集群扩容当有新的节点准备好加入集群时这个新的节点还是孤立节点加入有两种方式一个是通过集群节点执行命令来和孤立节点握手另一个则是使用脚本来添加节点通常这个新的节点有两种身份要么作为主节点要么作为从节点主节点分摊槽和数据从节点作故障转移备份槽的迁移集群缩容下线节点的流程判断该节点是否持有槽如果未持有槽就跳转到下一步持有槽则先迁移槽到其他节点通知其他节点忘记该下线节点关闭下线节点的服务需要注意的是如果先下线主节点再下线从节点会进行故障转移所以要先下线从节点故障转移集群同样具备了自动转移故障的功能和哨兵有些类似在进行客观下线之后就开始准备让故障节点的从节点上任了首先是进行资格检查只有具备资格的从节点才能参加选举故障节点的所有从节点检查和故障主节点之间的断线时间超过默认则取消选举资格然后是准备选举顺序不同偏移量的节点参与选举的顺位不同最大的节点选举顺位最高最优先选举而较低的节点要延迟选举部署架构说明注意建立的节点需要清空数据另外网络中不要有哨兵的主从否则也可能会干扰集群的创建及扩缩容生产环境台服务器分别是三组适用于生产环境集群扩容当前客户量激增现有的架构已经无法满足越来越高的并发访问请求为解决此问题新购置两台服务器要求将其动态添加到现有集群但不能影响业务的正常访问新版支持集群中有旧数据的情况进行扩容注意生产环境一般建议节点为奇数个比如以防止脑裂现象',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-08 11:15:57',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Hexo</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">June 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">No title</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-06-05T01:52:55.103Z" title="Created 2025-06-05 09:52:55">2025-06-05</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-04-08T03:15:57.897Z" title="Updated 2025-04-08 11:15:57">2025-04-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Redis/"><header><h1 id="CrawlerTitle" itemprop="name headline">No title</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">John Doe</span><time itemprop="dateCreated datePublished" datetime="2025-06-05T01:52:55.103Z" title="Created 2025-06-05 09:52:55">2025-06-05</time><time itemprop="dateCreated datePublished" datetime="2025-04-08T03:15:57.897Z" title="Updated 2025-04-08 11:15:57">2025-04-08</time></header><h1 id="企业级-NoSQL-数据库-Redis"><a href="#企业级-NoSQL-数据库-Redis" class="headerlink" title="企业级 NoSQL 数据库 Redis"></a>企业级 NoSQL 数据库 Redis</h1><h2 id="NoSQL-数据库"><a href="#NoSQL-数据库" class="headerlink" title="NoSQL 数据库"></a>NoSQL 数据库</h2><h4 id="什么是-NoSQL"><a href="#什么是-NoSQL" class="headerlink" title="什么是 NoSQL"></a>什么是 NoSQL</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据库主要分为两大类：关系型数据库与 NoSQL 数据库。</span><br><span class="line"></span><br><span class="line">关系型数据库，是建立在关系模型基础上的数据库，其借助于集合代数等数学概念和方法来处理数据库中的数据。主流的 MySQL、Oracle、MS SQL Server 和 DB2 都属于这类传统数据库。</span><br><span class="line"></span><br><span class="line">NoSQL 数据库，全称为 Not Only SQL，意思就是适用关系型数据库的时候就使用关系型数据库，不适用的时候可以考虑使用更加合适的数据存储。NoSQL 是对不同于传统的关系型数据库的数据库管理系统的统称。</span><br></pre></td></tr></table></figure>



<h4 id="RDBMS和NOSQL对比"><a href="#RDBMS和NOSQL对比" class="headerlink" title="RDBMS和NOSQL对比"></a>RDBMS和NOSQL对比</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RDBMS</span><br><span class="line">高度组织化结构化数据</span><br><span class="line">结构化查询语言（SQL）</span><br><span class="line">数据和关系都存储在单独的表中。</span><br><span class="line">数据操纵语言，数据定义语言</span><br><span class="line">严格的一致性</span><br><span class="line">基础事务</span><br><span class="line">NoSQL</span><br><span class="line">代表着不仅仅是SQL, 没有声明性查询语言</span><br><span class="line">没有预定义的模式</span><br><span class="line">最终一致性，而非ACID属性</span><br><span class="line">非结构化和不可预知的数据</span><br><span class="line">CAP定理</span><br><span class="line">高性能，高可用性和可伸缩性</span><br></pre></td></tr></table></figure>



<h4 id="NoSQL的优点-缺点"><a href="#NoSQL的优点-缺点" class="headerlink" title="NoSQL的优点&#x2F;缺点"></a>NoSQL的优点&#x2F;缺点</h4><table>
<thead>
<tr>
<th>对比维度</th>
<th>关系型数据库</th>
<th>NoSQL 数据库</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>- 数据关系模型基于关系模型，结构化存储，完整性约束 - 基于二维表及其之间的联系，需要连接、并、交、差、除等数据操作 - 采用结构化的查询语言（SQL）做数据读写 - 操作需要数据的一致性，需要事务甚至是强一致性</td>
<td>- 非结构化的存储 - 基于多维关系模型 - 具有特有的使用场景</td>
</tr>
<tr>
<td>优点</td>
<td>- 保持数据的一致性（事务处理） - 可以进行 join 等复杂查询 - 通用化，技术成熟</td>
<td>- 高并发，大数据下读写能力较强 - 基本支持分布式，易于扩展，可伸缩 - 简单，弱结构化存储</td>
</tr>
<tr>
<td>缺点</td>
<td>- 数据读写必须经过 sql 解析，大量数据、高并发下读写性能不足 - 对数据做读写，或修改数据结构时需要加锁，影响并发操作 - 无法适应非结构化存储 - 扩展困难 - 昂贵、复杂</td>
<td>- join 等复杂操作能力较弱 - 事务支持较弱 - 通用性差 - 无完整约束复杂业务场景支持较差</td>
</tr>
</tbody></table>
<h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">对于一个分布式计算系统，不可能同时满足以下三点:</span><br><span class="line">C：Consistency</span><br><span class="line">即一致性， 所有节点在同一时间具有相同的数据视图</span><br><span class="line"></span><br><span class="line">A：Availability</span><br><span class="line">即可用性，所有的节点都保持高可用性,要求服务在接收到客户端请求后，都能够给出响应</span><br><span class="line"></span><br><span class="line">P：Partiton tolerance</span><br><span class="line">分区是指系统中的节点由于网络故障无法相互通信，导致系统被分成多个孤立的子系统</span><br><span class="line"></span><br><span class="line">遵循CAP原理，一个数据分布式系统不可能同时满足C和A和P这<span class="number">3</span>个条件。</span><br><span class="line"></span><br><span class="line">在服务器之间的网络出现异常的情况下，一致性和可用性是不可能同时满足的，必须要放弃一个，来保证另一个。这也正是CAP定理所说的，在分布式系统中，P总是存在的。在P发生的前提下，C(一致性)和A（可用性）不能同时满足。这种情况在做架构设计的时候就要考虑到，要评估对业务的影响，进行权衡决定放弃哪一个。在通常的业务场景下，系统不可用是不能接受的，所以要优先保证可用性，暂时放弃一致性。</span><br><span class="line"></span><br><span class="line">根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 <span class="built_in">CP</span> 原则和满足 AP 原则三大类：</span><br><span class="line">CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统将不是一个标准的分布式系统</span><br><span class="line">比如:单一数据中心数据库,所有节点都位于同一个数据中心，并且节点之间的通信是高可靠的</span><br><span class="line"><span class="built_in">CP</span> - 满足一致性，分区容忍性的系统，通常性能不是特别高。 放弃可用性，追求强一致性和分区容错性</span><br><span class="line">例如: Zookeeper,ETCD,Consul,MySQL的PXC等集群就是追求的强一致，再比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。</span><br><span class="line">AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</span><br><span class="line">放弃一致性，追求分区容忍性和可用性。这是很多分布式系统设计时的选择。</span><br><span class="line">例如：MySQL主从复制，默认是异步机制就可以实现AP，但是用户接受所查询的到数据在一定时间内不是最新的.</span><br></pre></td></tr></table></figure>

<h4 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis (Remote Dictionary Server 远程字典服务)是一个遵循BSD MIT开源协议的高性能的NoSQL</span><br></pre></td></tr></table></figure>

<h4 id="Redis-特性"><a href="#Redis-特性" class="headerlink" title="Redis 特性"></a>Redis 特性</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">速度快: <span class="number">10</span>W QPS,基于内存,C语言实现</span><br><span class="line">单线程：引号的”单线程“</span><br><span class="line">     单线程为何如此快?</span><br><span class="line">       纯内存</span><br><span class="line">       非阻塞</span><br><span class="line">       避免线程切换和竞态消耗</span><br><span class="line">       基于Epoll实现IO多路复用</span><br><span class="line">持久化：RDB，AOF</span><br><span class="line">支持多种数据类型</span><br><span class="line">支持多种编程语言</span><br><span class="line">功能丰富: 支持Lua脚本,发布订阅,事务,pipeline等功能</span><br><span class="line">简单: 代码短小精悍(单机核心代码只有<span class="number">23000</span>行左右),单线程开发容易,不依赖外部库,使用简单</span><br><span class="line">主从复制</span><br><span class="line">支持高可用和分布式</span><br></pre></td></tr></table></figure>

<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一次只运行一条命令</span><br><span class="line">避免执行长(慢)命令:keys *, flushall, flushdb, slow lua script, mutil/exec, operate bigvalue(collection)</span><br><span class="line">其实不是单线程: 早期版本是单进程单线程,<span class="number">3.0</span> 版本后实际还有其它的线程, 实现特定功能,如: fysncfile descriptor,close file descriptor</span><br></pre></td></tr></table></figure>

<h4 id="Redis-对比-Memcached"><a href="#Redis-对比-Memcached" class="headerlink" title="Redis 对比 Memcached"></a>Redis 对比 Memcached</h4><table>
<thead>
<tr>
<th>比较类别</th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>支持的数据结构</td>
<td>哈希、列表、集合、有序集合</td>
<td>纯 key-value</td>
</tr>
<tr>
<td>持久化支持</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>高可用支持</td>
<td>redis 支持集群功能，可以实现主动复制，读写分离。官方提供了 Sentinel 集群管理工具，能够实现主从服务监控，故障自动转移，这一切，对于客户端都是透明的，无需程序改动，也无需人工介入</td>
<td>需要二次开发</td>
</tr>
<tr>
<td>存储 value 容量</td>
<td>最大 512M</td>
<td>最大 1M</td>
</tr>
<tr>
<td>内存分配</td>
<td>临时申请空间，可能导致碎片</td>
<td>预分配内存池的方式管理内存，能够省去内存分配时间</td>
</tr>
<tr>
<td>虚拟内存使用</td>
<td>有自己的 VM 机制，理论上能够存储比物理内存更多的数据，当数据超量时，会引发 swap，把冷数据刷到磁盘上</td>
<td>所有的数据存储在物理内存里</td>
</tr>
<tr>
<td>网络模型</td>
<td>非阻塞 IO 复用模型，提供一些非 KV 存储之外的排序，聚合功能，在执行这些功能时，复杂的 CPU 计算，会阻塞整个 IO 调度</td>
<td>非阻塞 IO 复用模型</td>
</tr>
<tr>
<td>水平扩展的支持</td>
<td>redis cluster 可以横向扩展</td>
<td>暂无</td>
</tr>
<tr>
<td>多线程</td>
<td>Redis6.0 之前是只支持单线程</td>
<td>Memcached 支持多线程，CPU 利用方面 Memcache 优于 Redis</td>
</tr>
<tr>
<td>过期策略</td>
<td>有专门线程，清除缓存数据</td>
<td>懒淘汰机制：每次往缓存放入数据的时候，都会存一个时间，在读取的时候要和设置的时间做 TTL 比较来判断是否过期</td>
</tr>
<tr>
<td>单机 QPS</td>
<td>约 10W</td>
<td>约 60W</td>
</tr>
<tr>
<td>源代码可读性</td>
<td>代码清爽简洁</td>
<td>可能是考虑了太多的扩展性，多系统的兼容性，代码不清爽</td>
</tr>
<tr>
<td>适用场景</td>
<td>复杂数据结构、有持久化、高可用需求、value 存储内容较大</td>
<td>纯 KV，数据量非常大，并发量非常大的业务</td>
</tr>
</tbody></table>
<h4 id="Redis-常见应用场景"><a href="#Redis-常见应用场景" class="headerlink" title="Redis 常见应用场景"></a>Redis 常见应用场景</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250331195955711.png" alt="image-20250331195955711"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">缓存：缓存RDBMS中数据,比如网站的查询结果、商品信息、微博、新闻、消息</span><br><span class="line">Session 共享：实现Web集群中的多服务器间的 session 共享</span><br><span class="line">计数器：商品访问排行榜、浏览数、粉丝数、关注、点赞、评论等和次数相关的数值统计场景</span><br><span class="line">社交：朋友圈、共同好友、可能认识他们等</span><br><span class="line">地理位置: 基于地理信息系统GIS（Geographic Information System)实现摇一摇、附近的人、外卖等功能</span><br><span class="line">消息队列：ELK等日志系统缓存、业务的订阅/发布系统</span><br></pre></td></tr></table></figure>

<h3 id="缓存的实现流程"><a href="#缓存的实现流程" class="headerlink" title="缓存的实现流程"></a>缓存的实现流程</h3><h5 id="数据更新操作流程："><a href="#数据更新操作流程：" class="headerlink" title="数据更新操作流程："></a>数据更新操作流程：</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250331200116061.png" alt="image-20250331200116061"></p>
<h5 id="数据读操作流程："><a href="#数据读操作流程：" class="headerlink" title="数据读操作流程："></a>数据读操作流程：</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250331200133734.png" alt="image-20250331200133734"></p>
<h4 id="缓存穿透-缓存击穿和缓存雪崩"><a href="#缓存穿透-缓存击穿和缓存雪崩" class="headerlink" title="缓存穿透,缓存击穿和缓存雪崩"></a>缓存穿透,缓存击穿和缓存雪崩</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透 Cache Penetration</span><br><span class="line">缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，比如： 发起为id为 “<span class="literal">-1</span>” 的数据或id为特别大不存在的数据。</span><br><span class="line">这时的用户很可能是攻击者，攻击会导致数据库压力过大。</span><br><span class="line">解决方法：</span><br><span class="line">接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=<span class="number">0</span>的直接拦截</span><br><span class="line">从缓存取不到的数据，在数据库中也没有取到，这时也可以将key<span class="literal">-value</span>对写为key<span class="literal">-null</span>，缓存有效时间可以设置短点，如<span class="number">30</span>秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</span><br><span class="line"></span><br><span class="line">缓存击穿 Cache breakdown</span><br><span class="line">缓存击穿是指缓存中没有但数据库中有的数据，比如：热点数据的缓存时间到期后，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</span><br><span class="line">解决方法：</span><br><span class="line">设置热点数据永远不过期。</span><br><span class="line"></span><br><span class="line">缓存雪崩 Thunder Hurd Problem</span><br><span class="line">缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</span><br><span class="line">解决方法：</span><br><span class="line">缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</span><br><span class="line">如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中</span><br><span class="line">设置热点数据永远不过期</span><br></pre></td></tr></table></figure>

<h4 id="缓存-crash"><a href="#缓存-crash" class="headerlink" title="缓存 crash"></a>缓存 crash</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis 缓存服务宕机，造成 缓存服务失效</span><br><span class="line">解决方法：Redis高可用集群</span><br></pre></td></tr></table></figure>

<h4 id="Pipeline-流水线"><a href="#Pipeline-流水线" class="headerlink" title="Pipeline 流水线"></a>Pipeline 流水线</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Redis 客户端执行一条命令分<span class="number">6</span>个过程：</span><br><span class="line">发送命令－-〉网络传输－-〉 命令排队－-〉命令执行－-〉网络传输－-〉 返回结果</span><br><span class="line">这个过程称为Round trip time(简称RTT, 往返时间)，mget,mset指令可以一次性的批量对多个数据的执</span><br><span class="line">行操作,所以有效节约了RTT</span><br><span class="line">但大部分命令（如hgetall）不支持批量操作，需要消耗N次RTT ，利用 Pipeline 技术可以解决这一问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="未使用pipeline执行N条命令如下图"><a href="#未使用pipeline执行N条命令如下图" class="headerlink" title="未使用pipeline执行N条命令如下图"></a>未使用pipeline执行N条命令如下图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250331201524132.png" alt="image-20250331201524132"></p>
<h5 id="使用了pipeline执行N条命令如下图"><a href="#使用了pipeline执行N条命令如下图" class="headerlink" title="使用了pipeline执行N条命令如下图"></a>使用了pipeline执行N条命令如下图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250331201544163.png" alt="image-20250331201544163"></p>
<h5 id="两者性能对比"><a href="#两者性能对比" class="headerlink" title="两者性能对比"></a>两者性能对比</h5><table>
<thead>
<tr>
<th>网络</th>
<th>延迟</th>
<th>非 Pipeline</th>
<th>Pipeline</th>
</tr>
</thead>
<tbody><tr>
<td>本机</td>
<td>0.17ms</td>
<td>573ms</td>
<td>134ms</td>
</tr>
<tr>
<td>内网服务器</td>
<td>0.41ms</td>
<td>1610ms</td>
<td>240ms</td>
</tr>
<tr>
<td>异地机房</td>
<td>7ms</td>
<td>80000ms</td>
<td>1104ms</td>
</tr>
</tbody></table>
<h4 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装方法</span><br><span class="line">包安装</span><br><span class="line">源码编译</span><br><span class="line">容器运行</span><br></pre></td></tr></table></figure>

<h4 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Redis 是基于内存型的NoSQL, 和MySQL是不同的,使用内存进行数据保存</span><br><span class="line">如果想实现数据的持久化,Redis也也可支持将内存数据保存到硬盘文件中</span><br><span class="line">Redis支持两种数据持久化保存方法</span><br><span class="line">RDB:Redis DataBase</span><br><span class="line">AOF:AppendOnlyFile</span><br></pre></td></tr></table></figure>

<h5 id="RDB-工作原理"><a href="#RDB-工作原理" class="headerlink" title="RDB 工作原理"></a>RDB 工作原理</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是基于某个时间点的快照，注意RDB只保留当前最新版本的一个快照相当于MySQL中的完全备份</span><br><span class="line">RDB 持久化功能所生成的 RDB 文件是一个经过压缩的二进制文件，通过该文件可以还原生成该 RDB 文件时数据库的状态。因为 RDB 文件是保存在磁盘中的，所以即便 Redis 服务进程甚至服务器宕机，只要磁盘中 RDB 文件存在，就能将数据恢复</span><br><span class="line">RDB 支持save和bgsave两种命令实现数据文件的持久化</span><br><span class="line">注意： save 指令使用主进程进行备份，而不生成新的子进程，但是也会生成临时文件temp-&lt;主进程PID&gt;.rdb文件</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250402192923373.png" alt="image-20250402192923373"></p>
<h6 id="save-执行过程会使用主进程进行快照，并生成临时文件temp-rdb文件"><a href="#save-执行过程会使用主进程进行快照，并生成临时文件temp-rdb文件" class="headerlink" title="save 执行过程会使用主进程进行快照，并生成临时文件temp-&lt;主进程PID&gt;.rdb文件"></a>save 执行过程会使用主进程进行快照，并生成临时文件temp-&lt;主进程PID&gt;.rdb文件</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>]   Done                    redis<span class="literal">-cli</span> <span class="literal">-a</span> <span class="number">123456</span> save</span><br><span class="line">total <span class="number">1492</span></span><br><span class="line">drwxr<span class="literal">-xr-x</span> <span class="number">2</span> redis redis    <span class="number">4096</span> Apr  <span class="number">2</span> <span class="number">11</span>:<span class="number">41</span> ./</span><br><span class="line">drwxr<span class="literal">-xr-x</span> <span class="number">7</span> redis redis    <span class="number">4096</span> Apr  <span class="number">2</span> <span class="number">11</span>:<span class="number">38</span> ../</span><br><span class="line"><span class="literal">-rw-r--r--</span> <span class="number">1</span> redis redis <span class="number">1477877</span> Apr  <span class="number">2</span> <span class="number">11</span>:<span class="number">41</span> dump.rdb</span><br><span class="line"><span class="literal">-rw-r--r--</span> <span class="number">1</span> redis redis   <span class="number">40960</span> Apr  <span class="number">2</span> <span class="number">11</span>:<span class="number">41</span> temp<span class="literal">-7391</span>.rdb</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="RDB-bgsave-实现快照"><a href="#RDB-bgsave-实现快照" class="headerlink" title="RDB bgsave 实现快照"></a>RDB bgsave 实现快照</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先从redis 主进程先fork生成一个新的子进程,此子进程负责将Redis内存数据保存为一个临时文件tmp-</span><br><span class="line">&lt;子进程pid&gt;.rdb</span><br><span class="line">当数据保存完成后,再将此临时文件改名为RDB文件,如果有前一次保存的RDB文件则会被替换，最后关闭</span><br><span class="line">此子进程</span><br><span class="line">由于Redis只保留最后一个版本的RDB文件,如果想实现保存多个版本的数据,需要人为实现</span><br></pre></td></tr></table></figure>

<h4 id="实现-RDB-方法"><a href="#实现-RDB-方法" class="headerlink" title="实现 RDB 方法"></a>实现 RDB 方法</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save: 同步,不推荐使用，使用主进程完成快照，因此会阻塞其它命令执行</span><br><span class="line">bgsave: 异步后台执行,不影响其它命令的执行，会开启独立的子进程，因此不会阻赛其它命令执行</span><br><span class="line">配置文件实现自动保存: 在配置文件中制定规则,自动执行bgsave</span><br></pre></td></tr></table></figure>

<h4 id="RDB-模式的优缺点"><a href="#RDB-模式的优缺点" class="headerlink" title="RDB 模式的优缺点"></a>RDB 模式的优缺点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line">RDB快照只保存某个时间点的数据，恢复的时候直接加载到内存即可，不用做其他处理，这种文件适合用于做灾备处理.可以通过自定义时间点执行redis指令bgsave或者save保存快照，实现多个版本的备份</span><br><span class="line">比如: 可以在最近的<span class="number">24</span>小时内，每小时备份一次RDB文件，并且在每个月的每一天，也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到指定的不同的版本。</span><br><span class="line">RDB在大数据集时恢复的速度比AOF方式要快</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line">不能实时保存数据，可能会丢失自上一次执行RDB备份到当前的内存数据</span><br><span class="line">如果需要尽量避免在服务器故障时丢失数据，那么RDB并不适合。虽然Redis允许设置不同的保存点（save point）来控制保存RDB文件的频率，但是，因为RDB文件需要保存整个数据集的状态，所以它可能并不是一个非常快速的操作。因此一般会超过<span class="number">5</span>分钟以上才保存一次RDB文件。在这种情况下，一旦发生故障停机，就可能会丢失较长时间的数据。</span><br><span class="line">在数据集比较庞大时，fork()子进程可能会非常耗时，造成服务器在一定时间内停止处理客户端请求,如果数据集非常巨大，并且CPU时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒或更久。另外子进程完成生成RDB文件的时间也会花更长时间.</span><br></pre></td></tr></table></figure>

<h4 id="AOF-工作原理"><a href="#AOF-工作原理" class="headerlink" title="AOF 工作原理"></a>AOF 工作原理</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AOF 即 AppendOnlyFile，AOF 和 RDB 都采有COW机制</span><br><span class="line">AOF 可以指定不同的保存策略,默认为每秒钟执行一次 fsync,按照操作的顺序地将变更命令追加至指定的AOF日志文件尾部</span><br><span class="line">在第一次启用AOF功能时，会做一次完全备份，后续将执行增量性备份，相当于完全数据备份+增量变化</span><br><span class="line">如果同时启用RDB和AOF,进行恢复时,默认AOF文件优先级高于RDB文件,即会使用AOF文件进行恢复</span><br><span class="line">在第一次开启AOF功能时,会自动备份所有数据到AOF文件中,后续只会记录数据的更新指令</span><br><span class="line">注意: AOF 模式默认是关闭的,第一次开启AOF后,并重启服务生效后,会因为AOF的优先级高于RDB,而AOF默认没有数据文件存在,从而导致所有数据丢失</span><br></pre></td></tr></table></figure>

<h4 id="AOF-模式优缺点"><a href="#AOF-模式优缺点" class="headerlink" title="AOF 模式优缺点"></a>AOF 模式优缺点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line">数据安全性相对较高，根据所使用的fsync策略(fsync是同步内存中redis所有已经修改的文件到存储设备)，默认是appendfsync everysec，即每秒执行一次 fsync,在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据( fsync会在后台线程执行，所以主线程可以继续努力地处理命令请求)</span><br><span class="line"></span><br><span class="line">由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中不需要seek, 即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，可以通过 redis<span class="literal">-check-aof</span> 工具来解决数据一致性的问题</span><br><span class="line"></span><br><span class="line">Redis可以在 AOF文件体积变得过大时，自动地在后台对AOF进行重写,重写后的新AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis在创建新 AOF文件的过程中，append模式不断的将修改数据追加到现有的 AOF文件里面，即使重写过程中发生停机，现有的 AOF文件也不会丢失。而一旦新AOF文件创建完毕，Redis就会从旧AOF文件切换到新AOF文件，并开始对新AOF文件进行追加操作。</span><br><span class="line"></span><br><span class="line">AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，也可以通过该文件完成数据的重建</span><br><span class="line"></span><br><span class="line">AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此 AOF文件的内容非常容易被人读懂，对文件进行分析(parse)也很轻松。导出（export)AOF文件也非常简单:举个例子，如果不小心执行了FLUSHALL.命令，但只要AOF文件未被重写，那么只要停止服务器，移除 AOF文件末尾的FLUSHAL命令，并重启Redis ,就可以将数据集恢复到FLUSHALL执行之前的状态。</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line">即使有些操作是重复的也会全部记录，AOF 的文件大小一般要大于 RDB 格式的文件</span><br><span class="line">AOF 在恢复大数据集时的速度比 RDB 的恢复速度要慢</span><br><span class="line">如果 fsync 策略是appendfsync no, AOF保存到磁盘的速度甚至会可能会慢于RDB</span><br><span class="line">bug 出现的可能性更多</span><br></pre></td></tr></table></figure>

<h4 id="RDB和AOF-的选择"><a href="#RDB和AOF-的选择" class="headerlink" title="RDB和AOF 的选择"></a>RDB和AOF 的选择</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果主要充当缓存功能,或者可以承受较长时间,比如数分钟数据的丢失, 通常生产环境一般只需启用RDB即可,此也是默认值</span><br><span class="line">如果一点数据都不能丢失,可以选择同时开启RDB和AOF</span><br><span class="line">一般不建议只开启AOF</span><br></pre></td></tr></table></figure>

<h4 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">![<span class="type">image</span>-<span class="number">20250403102953994</span>](E:\biji\image\image<span class="literal">-20250403102953994</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 字符串 string</span></span><br><span class="line"></span><br><span class="line">```powershell</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>set key value</td>
<td>设置 key-value</td>
<td>o(1)</td>
</tr>
<tr>
<td>get key</td>
<td>获取 key-value</td>
<td>o(1)</td>
</tr>
<tr>
<td>del key</td>
<td>删除 key-value</td>
<td>o(1)</td>
</tr>
<tr>
<td>setnx setxx</td>
<td>根据 key 是否存在设置 key-value</td>
<td>o(1)</td>
</tr>
<tr>
<td>Incr decr</td>
<td>计数</td>
<td>o(1)</td>
</tr>
<tr>
<td>mget mset</td>
<td>批量操作 key-value</td>
<td>o(n)</td>
</tr>
</tbody></table>
<h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Redis列表实际就是简单的字符串数组，按照插入顺序进行排序.</span><br><span class="line">支持双向读写,可以添加一个元素到列表的头部（左边）或者尾部（右边），一个列表最多可以包含</span><br><span class="line"><span class="number">2</span>^<span class="number">32</span><span class="literal">-1</span>=<span class="number">4294967295</span>个元素</span><br><span class="line">每个列表元素用下标来标识,下标 <span class="number">0</span> 表示列表的第一个元素，以 <span class="number">1</span> 表示列表的第二个元素，以此类推。</span><br><span class="line">也可以使用负数下标，以 <span class="literal">-1</span> 表示列表的最后一个元素， <span class="literal">-2</span> 表示列表的倒数第二个元素，元素值可以重复，常用于存入日志等场景，此数据类型比较常用</span><br><span class="line">列表特点</span><br><span class="line">有序</span><br><span class="line">value可重复</span><br><span class="line">左右都可以操作</span><br></pre></td></tr></table></figure>

<h4 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span> 是一个无序的字符串合集</span><br><span class="line">同一个集合中的每个元素是唯一无重复的</span><br><span class="line">支持在两个不同的集合中对数据进行逻辑处理，常用于取交集,并集,统计等场景,例如: 实现共同的朋友</span><br><span class="line">集合特点</span><br><span class="line">无序</span><br><span class="line">无重复</span><br><span class="line">集合间操作</span><br></pre></td></tr></table></figure>

<p>集合间操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250403144145286.png" alt="image-20250403144145286"></p>
<h4 id="有序集合-sorted-set"><a href="#有序集合-sorted-set" class="headerlink" title="有序集合 sorted set"></a>有序集合 sorted set</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Redis有序集合和Redis集合类似，是不包含相同字符串的合集。</span><br><span class="line">它们的差别是，每个有序集合的成员都关联着一个双精度浮点型的评分</span><br><span class="line">这个评分用于把有序集合中的成员按最低分到最高分排序。</span><br><span class="line">有序集合的成员不能重复,但评分可以重复,一个有序集合中最多的成员数为 <span class="number">2</span>^<span class="number">32</span> - <span class="number">1</span>=<span class="number">4294967295</span>个，经常用于排行榜的场景</span><br><span class="line"></span><br><span class="line">有序集合特点</span><br><span class="line">有序</span><br><span class="line">无重复元素</span><br><span class="line">每个元素是由score和value组成</span><br><span class="line">score 可以重复</span><br><span class="line">value 不可以重复</span><br></pre></td></tr></table></figure>

<h4 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 hash"></a>哈希 hash</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hash 即字典, 用于保存字符串字段field和字符串值value之间的映射，即key/value做为数据部分</span><br><span class="line">hash特别适合用于存储对象场景.</span><br><span class="line">一个hash最多可以包含<span class="number">2</span>^<span class="number">32</span><span class="literal">-1</span> 个key/value键值对</span><br><span class="line">哈希特点</span><br><span class="line">无序</span><br><span class="line">K/V 对</span><br><span class="line">适用于存放相关的数据</span><br></pre></td></tr></table></figure>

<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">消息队列: 把要传输的数据放在队列中,从而实现应用之间的数据交换</span><br><span class="line">常用功能: 可以实现多个应用系统之间的解耦,异步,削峰/限流等</span><br><span class="line">常用的消息队列应用: Kafka,RabbitMQ,Redis</span><br><span class="line"></span><br><span class="line">消息队列分为两种</span><br><span class="line">生产者/消费者模式: Producer/Consumer</span><br><span class="line">发布者/订阅者模式: Publisher/Subscriber</span><br></pre></td></tr></table></figure>

<h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者消费者模式下，多个消费者同时监听一个频道(redis用队列实现)，但是生产者产生的一个消息只能被最先抢到消息的一个消费者消费一次,队列中的消息由可以多个生产者写入，也可以有不同的消费者取出进行消费处理.此模式应用广泛</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250403150503960.png" alt="image-20250403150503960"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250403150507961.png" alt="image-20250403150507961"></p>
<h4 id="发布者订阅模式"><a href="#发布者订阅模式" class="headerlink" title="发布者订阅模式"></a>发布者订阅模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在发布者订阅者Publisher/Subscriber模式下，发布者Publisher将消息发布到指定的频道channel，事先监听此channel的一个或多个订阅者Subscriber都会收到相同的消息。即一个消息可以由多个订阅者获取到. 对于社交应用中的群聊、群发、群公告等场景适用于此模式</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250403150805071.png" alt="image-20250403150805071"></p>
<h4 id="Redis-集群与高可用"><a href="#Redis-集群与高可用" class="headerlink" title="Redis 集群与高可用"></a>Redis 集群与高可用</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250403160351355.png" alt="image-20250403160351355"></p>
<h4 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250403160414640.png" alt="image-20250403160414640"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">主从复制架构</span><br><span class="line">Redis和MySQL的主从模式类似，也支持主从模式（master/slave），可以实现Redis数据的跨主机的远程备份</span><br><span class="line">常见客户端连接主从的架构:</span><br><span class="line">程序APP先连接到高可用性 LB 集群提供的虚拟IP，再由LB调度将用户的请求至后端Redis 服务器来真正提供服务</span><br><span class="line"></span><br><span class="line">主从复制的特点:</span><br><span class="line">一个master可以有多个slave</span><br><span class="line">一个slave只能有一个master</span><br><span class="line">数据流向是从master到slave单向的</span><br><span class="line">master 可读可写</span><br><span class="line">slave 只读</span><br></pre></td></tr></table></figure>

<h4 id="主从复制实现"><a href="#主从复制实现" class="headerlink" title="主从复制实现"></a>主从复制实现</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当master出现故障后,可以自动提升一个slave节点变成新的Mster,因此Redis Slave 需要设置和master相同的连接密码</span><br><span class="line">此外当一个Slave提升为新的master时需要通过持久化实现数据的恢复</span><br><span class="line">当配置Redis复制功能时，强烈建议打开主服务器的持久化功能。否则主节点Redis服务应该要避免自动启动。</span><br></pre></td></tr></table></figure>

<h4 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用哨兵 Sentinel 只能解决Redis高可用问题，实现Redis的自动故障转移,但仍然无法解决Redis Master单节点的性能瓶颈问题</span><br><span class="line">为了解决单机性能的瓶颈，提高Redis 服务整体性能，可以使用分布式集群的解决方案</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Redis-Cluster-架构"><a href="#Redis-Cluster-架构" class="headerlink" title="Redis Cluster 架构"></a>Redis Cluster 架构</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Redis cluster 需要至少 <span class="number">3</span>个master节点才能实现,slave节点数量不限</span><br><span class="line">Master节点必须要超过半数以上可用,否则集群将不可用,即数据访问和选举将无法实现</span><br><span class="line">因此Master节点的数据一般为奇数</span><br><span class="line">当然一般每个master都至少对应的有一个slave节点</span><br><span class="line">如果有三个主节点采用哈希槽 hash slot 的方式来分配<span class="number">16384</span>个槽位 slot</span><br><span class="line">此三个节点分别承担的slot 区间可以是如以下方式分配</span><br><span class="line">节点M1 <span class="number">0</span>－<span class="number">5460</span></span><br><span class="line">节点M2 <span class="number">5461</span>－<span class="number">10922</span></span><br><span class="line">节点M3 <span class="number">10923</span>－<span class="number">16383</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250408092030864.png" alt="image-20250408092030864"></p>
<h4 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果是单机存储的话，直接将数据存放在单机redis就行了。但是如果是集群存储，就需要考虑到数据分区了。</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250408092223317.png" alt="image-20250408092223317"></p>
<h5 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis cluster设置有<span class="number">0</span>~<span class="number">16383</span>的槽，每个槽映射一个数据子集，通过hash函数，将数据存放在不同的槽位中，每个集群的节点保存一部分的槽。</span><br><span class="line">每个key存储时，先经过算法函数CRC16(key)得到一个整数，然后整数与<span class="number">16384</span>取余，得到槽的数值，然后找到对应的节点，将数据存放入对应的槽中。</span><br></pre></td></tr></table></figure>

<h4 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当有新的节点准备好加入集群时，这个新的节点还是孤立节点，加入有两种方式。一个是通过集群节点</span><br><span class="line">执行命令来和孤立节点握手，另一个则是使用脚本来添加节点。</span><br><span class="line"><span class="number">1</span>. cluster_node_ip:port: cluster meet ip port new_node_ip:port</span><br><span class="line"><span class="number">2</span>. redis<span class="literal">-trib</span>.rb <span class="built_in">add-node</span> new_node_ip:port cluster_node_ip:port</span><br><span class="line">通常这个新的节点有两种身份，要么作为主节点，要么作为从节点：</span><br><span class="line">主节点：分摊槽和数据</span><br><span class="line">从节点：作故障转移备份</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250408092613912.png" alt="image-20250408092613912"></p>
<h4 id="槽的迁移"><a href="#槽的迁移" class="headerlink" title="槽的迁移"></a>槽的迁移</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250408092629280.png" alt="image-20250408092629280"></p>
<h4 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250408092647812.png" alt="image-20250408092647812"></p>
<h4 id="下线节点的流程"><a href="#下线节点的流程" class="headerlink" title="下线节点的流程"></a>下线节点的流程</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 判断该节点是否持有槽，如果未持有槽就跳转到下一步，持有槽则先迁移槽到其他节点</span><br><span class="line"><span class="number">2</span>. 通知其他节点（cluster forget）忘记该下线节点</span><br><span class="line"><span class="number">3</span>. 关闭下线节点的服务</span><br><span class="line"></span><br><span class="line">需要注意的是如果先下线主节点，再下线从节点，会进行故障转移，所以要先下线从节点。</span><br></pre></td></tr></table></figure>

<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">集群同样具备了自动转移故障的功能，和哨兵有些类似，在进行客观下线之后，就开始准备让故障节点的从节点“上任”了。</span><br><span class="line">首先是进行资格检查，只有具备资格的从节点才能参加选举：</span><br><span class="line">故障节点的所有从节点检查和故障主节点之间的断线时间</span><br><span class="line">超过cluster<span class="literal">-node-timeout</span> * cluster<span class="literal">-slave-validati-factor</span>(默认<span class="number">10</span>)则取消选举资格</span><br><span class="line">然后是准备选举顺序，不同偏移量的节点，参与选举的顺位不同。offset最大的slave节点，选举顺位最</span><br><span class="line">高，最优先选举。而offset较低的slave节点，要延迟选举。</span><br></pre></td></tr></table></figure>

<h4 id="Redis-Cluster-部署架构说明"><a href="#Redis-Cluster-部署架构说明" class="headerlink" title="Redis Cluster 部署架构说明"></a>Redis Cluster 部署架构说明</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意: 建立Redis Cluster 的节点需要清空数据，另外网络中不要有Redis哨兵的主从，否则也可能会干扰集群的创建及扩缩容</span><br></pre></td></tr></table></figure>

<h6 id="生产环境：6台服务器，分别是三组master-slave，适用于生产环境"><a href="#生产环境：6台服务器，分别是三组master-slave，适用于生产环境" class="headerlink" title="生产环境：6台服务器，分别是三组master&#x2F;slave，适用于生产环境"></a>生产环境：6台服务器，分别是三组master&#x2F;slave，适用于生产环境</h6><h4 id="集群扩容-1"><a href="#集群扩容-1" class="headerlink" title="集群扩容"></a>集群扩容</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前客户量激增，现有的Redis cluster架构已经无法满足越来越高的并发访问请求，为解决此问题,新购置两台服务器，要求将其动态添加到现有集群，但不能影响业务的正常访问。</span><br><span class="line">新版支持集群中有旧数据的情况进行扩容</span><br><span class="line">注意: 生产环境一般建议master节点为奇数个,比如:<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,以防止脑裂现象</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250408111540336.png" alt="image-20250408111540336"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="E:\biji\image\image-20250408111555862.png" alt="image-20250408111555862"></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">John Doe</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Redis/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Redis/')">Hexo</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Redis/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Hexo&amp;url=https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Redis/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/06/05/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4Keepalived/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E7%BA%A7-NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93-Redis"><span class="toc-number">1.</span> <span class="toc-text">企业级 NoSQL 数据库 Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NoSQL-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.</span> <span class="toc-text">NoSQL 数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-NoSQL"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">什么是 NoSQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDBMS%E5%92%8CNOSQL%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">RDBMS和NOSQL对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NoSQL%E7%9A%84%E4%BC%98%E7%82%B9-%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">NoSQL的优点&#x2F;缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAP%E5%AE%9A%E7%90%86"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">CAP定理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.0.5.</span> <span class="toc-text">Redis 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.0.6.</span> <span class="toc-text">Redis 特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.0.7.</span> <span class="toc-text">单线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%AF%B9%E6%AF%94-Memcached"><span class="toc-number">1.1.0.8.</span> <span class="toc-text">Redis 对比 Memcached</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%B8%B8%E8%A7%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.0.9.</span> <span class="toc-text">Redis 常见应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">缓存的实现流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.1.1.0.1.</span> <span class="toc-text">数据更新操作流程：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.1.1.0.2.</span> <span class="toc-text">数据读操作流程：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">缓存穿透,缓存击穿和缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98-crash"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">缓存 crash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pipeline-%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">Pipeline 流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%AA%E4%BD%BF%E7%94%A8pipeline%E6%89%A7%E8%A1%8CN%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%A6%82%E4%B8%8B%E5%9B%BE"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">未使用pipeline执行N条命令如下图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%86pipeline%E6%89%A7%E8%A1%8CN%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%A6%82%E4%B8%8B%E5%9B%BE"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">使用了pipeline执行N条命令如下图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.1.3.3.</span> <span class="toc-text">两者性能对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">Redis 安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">Redis 持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RDB-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.5.1.</span> <span class="toc-text">RDB 工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#save-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%BB%E8%BF%9B%E7%A8%8B%E8%BF%9B%E8%A1%8C%E5%BF%AB%E7%85%A7%EF%BC%8C%E5%B9%B6%E7%94%9F%E6%88%90%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6temp-rdb%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.1.5.1.1.</span> <span class="toc-text">save 执行过程会使用主进程进行快照，并生成临时文件temp-&lt;主进程PID&gt;.rdb文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RDB-bgsave-%E5%AE%9E%E7%8E%B0%E5%BF%AB%E7%85%A7"><span class="toc-number">1.1.1.5.1.2.</span> <span class="toc-text">RDB bgsave 实现快照</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-RDB-%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">实现 RDB 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB-%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">RDB 模式的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">AOF 工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF-%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.1.9.</span> <span class="toc-text">AOF 模式优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB%E5%92%8CAOF-%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.1.1.10.</span> <span class="toc-text">RDB和AOF 的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.11.</span> <span class="toc-text">Redis 数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8-list"><span class="toc-number">1.1.1.12.</span> <span class="toc-text">列表 list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88-set"><span class="toc-number">1.1.1.13.</span> <span class="toc-text">集合 set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-sorted-set"><span class="toc-number">1.1.1.14.</span> <span class="toc-text">有序集合 sorted set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C-hash"><span class="toc-number">1.1.1.15.</span> <span class="toc-text">哈希 hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.1.1.16.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.17.</span> <span class="toc-text">生产者消费者模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%80%85%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.1.18.</span> <span class="toc-text">发布者订阅模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E9%9B%86%E7%BE%A4%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">1.1.1.19.</span> <span class="toc-text">Redis 集群与高可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.1.1.20.</span> <span class="toc-text">Redis 主从复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.1.21.</span> <span class="toc-text">主从复制实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-Cluster"><span class="toc-number">1.1.1.22.</span> <span class="toc-text">Redis Cluster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-Cluster-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.1.23.</span> <span class="toc-text">Redis Cluster 架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA"><span class="toc-number">1.1.1.24.</span> <span class="toc-text">数据分区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%A7%BD%E5%88%86%E5%8C%BA"><span class="toc-number">1.1.1.24.1.</span> <span class="toc-text">虚拟槽分区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%89%A9%E5%AE%B9"><span class="toc-number">1.1.1.25.</span> <span class="toc-text">集群扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A7%BD%E7%9A%84%E8%BF%81%E7%A7%BB"><span class="toc-number">1.1.1.26.</span> <span class="toc-text">槽的迁移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E7%BC%A9%E5%AE%B9"><span class="toc-number">1.1.1.27.</span> <span class="toc-text">集群缩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E7%BA%BF%E8%8A%82%E7%82%B9%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.1.28.</span> <span class="toc-text">下线节点的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">1.1.1.29.</span> <span class="toc-text">故障转移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis-Cluster-%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.1.30.</span> <span class="toc-text">Redis Cluster 部署架构说明</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%EF%BC%9A6%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E4%B8%89%E7%BB%84master-slave%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.1.30.0.1.</span> <span class="toc-text">生产环境：6台服务器，分别是三组master&#x2F;slave，适用于生产环境</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%89%A9%E5%AE%B9-1"><span class="toc-number">1.1.1.31.</span> <span class="toc-text">集群扩容</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/05/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/" title="No title">No title</a><time datetime="2025-06-05T01:52:55.118Z" title="Created 2025-06-05 09:52:55">2025-06-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%20ZABBIX/" title="No title">No title</a><time datetime="2025-06-05T01:52:55.113Z" title="Created 2025-06-05 09:52:55">2025-06-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%20Docker/" title="No title">No title</a><time datetime="2025-06-05T01:52:55.113Z" title="Created 2025-06-05 09:52:55">2025-06-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%A0%A1%E5%9E%92%E6%9C%BA%20JumpServer/" title="No title">No title</a><time datetime="2025-06-05T01:52:55.108Z" title="Created 2025-06-05 09:52:55">2025-06-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/" title="No title">No title</a><time datetime="2025-06-05T01:52:55.108Z" title="Created 2025-06-05 09:52:55">2025-06-05</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="John Doe" target="_blank">John Doe</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">13</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 John Doe 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>