

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="MySQL 数据库-1MySQL 架构和性能优化123456789101112131415161718192021222324252627282930313233343536373839mysql的查询过程1 客户端发送查询请求：  用户通过客户端（如命令行工具、数据库管理工具等）发送SQL查询语句到MySQL服务器。2 服务器接收并处理连接：  MySQL服务器通过连接器接收客户端的连接请求，并">
<meta property="og:type" content="article">
<meta property="og:title" content="关于">
<meta property="og:url" content="https://lx1me.github.io/2025/06/05/MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93-1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="MySQL 数据库-1MySQL 架构和性能优化123456789101112131415161718192021222324252627282930313233343536373839mysql的查询过程1 客户端发送查询请求：  用户通过客户端（如命令行工具、数据库管理工具等）发送SQL查询语句到MySQL服务器。2 服务器接收并处理连接：  MySQL服务器通过连接器接收客户端的连接请求，并">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-05T01:52:55.088Z">
<meta property="article:modified_time" content="2025-06-09T02:29:36.439Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>关于 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/scroll.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/gradient.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lx1me.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="关于"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-06-05 09:52" pubdate>
          2025年6月5日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          79 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="text-center">
  <div class="about-info">
    <div class="about-name">Fluid</div>
    <div class="about-intro">An elegant theme for Hexo</div>
    <div class="about-icons">
      
        
        
        
        <a href=https://github.com class="
           hint--bottom hint--rounded"
           aria-label="GitHub"
           target="_blank"
        >
          <i class="iconfont icon-github-fill" aria-hidden="true"></i>
          
        </a>
      
        
        
        
        <a href=https://douban.com class="
           hint--bottom hint--rounded"
           aria-label="豆瓣"
           target="_blank"
        >
          <i class="iconfont icon-douban-fill" aria-hidden="true"></i>
          
        </a>
      
        
        
        
        <a  class="qr-trigger
           "
           
           target="_self"
        >
          <i class="iconfont icon-wechat-fill" aria-hidden="true"></i>
          
            <img class="qr-img" src="/img/favicon.png" srcset="/img/loading.gif" lazyload alt="qrcode" />
          
        </a>
      
    </div>
  </div>
</div>

<article class="about-content page-content mt-5">
  <div class="markdown-body">
    <h1 id="MySQL-数据库-1"><a href="#MySQL-数据库-1" class="headerlink" title="MySQL 数据库-1"></a><strong>MySQL</strong> <strong>数据库</strong>-1</h1><h2 id="MySQL-架构和性能优化"><a href="#MySQL-架构和性能优化" class="headerlink" title="MySQL 架构和性能优化"></a><strong>MySQL</strong> <strong>架构和性能优化</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mysql的查询过程<br><span class="hljs-number">1</span> 客户端发送查询请求：<br>  用户通过客户端（如命令行工具、数据库管理工具等）发送SQL查询语句到MySQL服务器。<br><br><span class="hljs-number">2</span> 服务器接收并处理连接：<br>  MySQL服务器通过连接器接收客户端的连接请求，并进行身份认证和权限验证。<br>  如果验证成功，服务器为客户端分配一个独立的线程来处理后续的查询请求。<br><br><span class="hljs-number">3</span> 查询缓存（MySQL <span class="hljs-number">8.0</span>后已移除该功能）：<br>  在早期版本的MySQL中，服务器会检查查询缓存，看是否存在已经执行过且结果未过期的相同查询。<br>  如果缓存命中，则直接返回缓存的结果，跳过后续的解析和执行步骤。<br>注意：<br>  由于查询缓存的局限性（如更新操作会导致缓存失效），在MySQL <span class="hljs-number">8.0</span>及以后版本中，查询缓存功能已被移除。<br> 原因：<br>  维护成本高：在早期版本中，每当数据发生变化，如执行插入、更新或删除操作时，相关的查询缓存就可能会失效，需要进行清理或更新。随着数据量和更新频率的增加，这种维护操作的开销会变得非常大，甚至可能超过查询缓存带来的性能提升。<br>  缓存命中率不稳定：查询缓存的效果依赖于查询的重复性和数据的稳定性。在实际应用中，如果查询语句变化多样，或者数据更新频繁，查询缓存的命中率可能会很低，导致查询缓存占用了内存资源却不能有效提高性能。<br>  内存管理复杂：管理查询缓存需要额外的内存空间，并且要解决内存碎片等问题。在高并发环境下，内存管理的复杂性会进一步增加，可能导致性能问题和内存泄漏等风险。<br><br><span class="hljs-number">4</span> SQL解析：<br>    服务器对接收到的SQL查询语句进行解析，生成解析树（或称为语法树）。<br>    解析过程包括词法分析和语法分析，确保SQL语句的语法正确，并识别出SQL语句中的关键字、表名、列名等。<br>    随后进行语义分析，检查表名、列名是否存在，以及用户是否有相应的权限。<br><br><span class="hljs-number">5</span> 查询优化optimizer：<br>    优化器对解析后的查询语句进行优化，生成最优的执行计划。<br>    优化过程包括选择最佳的索引、确定表的连接顺序、重写查询等，以提高查询效率。<br>    优化器会计算不同执行计划的预测成本值，并选择成本最小的计划作为最终执行计划。<br><br><span class="hljs-number">6</span> 执行计划生成：<br>    根据优化器生成的执行计划，服务器确定具体的查询执行步骤。<br>    执行计划包括选择索引、读取顺序、数据过滤、排序、聚合等操作。<br><br><span class="hljs-number">7</span> 执行查询并返回结果：<br>    执行器根据执行计划调用存储引擎的API来执行查询操作。<br>    存储引擎负责具体的数据存储和读取操作，根据执行计划读取数据并返回给执行器。<br>    执行器对读取到的数据进行处理（如过滤、排序、聚合等），然后生成结果集。<br><br>最终，服务器将处理后的结果集返回给客户端。<br><br></code></pre></td></tr></table></figure>

<h2 id="mysql组件"><a href="#mysql组件" class="headerlink" title="mysql组件"></a>mysql组件</h2><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">连接器对  Native，JDBC，ODBC，NET，PHP，Perl，Python，Ruby，Cobol 等客户端工具或编程语言的 API 对MySQL 的连接功能进行管理。连接器是 Server 端的第一个模块。<br> 每种编程语言软件几乎都有适合自己的连接器软件插件。<br></code></pre></td></tr></table></figure>



<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL的线程池是一种重要的技术，旨在提高数据库的性能和资源利用效率。<br>作用<br>MySQL的线程池在提高资源利用效率、减少线程创建和销毁的开销、实现负载均衡以及提高并发处理能力等方面发挥着重要作用。它是数据库性能优化的重要手段之一，特别适用于高并发环境下的数据库访问。同时，线程池还可以与连接池结合使用，以进一步提高数据库性能。<br><span class="hljs-number">1</span> 资源复用：<br>    线程池复用线程，减少了线程的创建和销毁开销。<br>    连接池复用连接，减少了连接的创建和销毁开销。<br><span class="hljs-number">2</span> 提高并发处理能力：<br>    线程池可以处理多个并发请求，而不需要为每个请求创建新的线程。<br>    连接池可以管理多个数据库连接，确保在高并发情况下，应用程序能够迅速获取到数据库连接。<br><span class="hljs-number">3</span> 优化资源分配：<br> 通过线程池和连接池的结合使用，可以更合理地分配系统资源。例如，可以根据系统的负载情况动态调整线程池和连接池的大小，以平衡性能和资源利用率。<br><span class="hljs-number">4</span> 简化管理：<br> 线程池和连接池都提供了对资源和连接的管理功能，使得开发人员可以更加专注于业务逻辑的实现，而不需要过多关注底层资源的管理。<br></code></pre></td></tr></table></figure>

<h4 id="SQL语句解析"><a href="#SQL语句解析" class="headerlink" title="SQL语句解析"></a>SQL语句解析</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SQL Interface：SQL 语句接口<br>  完整的 sql 命令的解释器，对 SQL 语句进行检查，是否有错误，并且进行词法分析，语法分析，识别出具体操作，对象，参数等。 <br><br>Parser：查询解析器 <br>  解析器会根据己经检查过的SQL语句生成一个数据结构，一般是树形结构，我们称其为解析树。在这个过程中也会校验当前连接的客户端是否有权限操作库和表等。<br>  在 MySQL 中，语法树（Syntax Tree），更准确地说是抽象语法树（Abstract Syntax Tree，AST），是对 SQL 语句进行解析后得到的一种树形结构表示.<br>  当你向 MySQL 服务器发送一条 SQL 语句时，服务器首先会对该语句进行词法分析和语法分析。词法分析将 SQL 语句拆分成一个个的词法单元（Token），例如关键字、标识符、操作符等；语法分析则根据 SQL 的语法规则，将这些词法单元组织成一个树形结构，即抽象语法树。<br><br>Optimizer：查询优化器<br>  优化器可以通过分析抽象语法树来理解 SQL 语句的逻辑结构和语义，从而确定如何以最有效的方式执行查询。例如，它可以识别出哪些条件可以提前过滤数据，哪些表连接可以采用更高效的算法<br>  根据解析器生成的解析树中的各个节点，生成不同的执行计划，然后决定一个最优的执行顺序路径，Mysql里面使用基于开销的优化器，哪种计划开销最小，就用哪种，从而保证在使用最少的开销的情况下返回正确的结果。<br>  SQL语句在执行的时候，会先判断一下连接用户是否对特定表具有查询的权限，然后根据表的引擎定义，去使用这个引擎提供的接口。  <br></code></pre></td></tr></table></figure>

<h4 id="其它组件"><a href="#其它组件" class="headerlink" title="其它组件"></a>其它组件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">存储引擎<br>  存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据，如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法。<br>  MySQL 数据库中的数据，本质上来讲，是存在于硬盘上的物理文件，不同的存储引擎有不同的特性，实际上就是使用不同的技术和方式来管理文件中的数据。<br>  存储引擎将存于硬盘上的物理文件，加载到内存中，然后再有上面的语句对内存中的数据，进行各种各样<br>的操作。  <br></code></pre></td></tr></table></figure>

<h2 id="存储引擎-默认是InnoDB"><a href="#存储引擎-默认是InnoDB" class="headerlink" title="存储引擎(默认是InnoDB)"></a>存储引擎(默认是InnoDB)</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力，此种技术称为存储引擎，MySQL 支持多种存储引擎，其中目前应用最广泛的是 InnoDB 和 MyISAM 两种。<br><br>存储引擎决定了数据如何存储在磁盘上，以及如何被访问。它提供了数据的存储机制、索引技巧、锁定水平，并最终提供不同的功能和能力。具体的数据库里面的输入，如何存储到物理的数据文件里面，是由存储引擎来实现的。<br><br>在 MySQL5.<span class="hljs-number">5</span> 之后默认存储引擎是 InnoDB，在之前是 MyISAM。<br><br>Mysql<span class="hljs-literal">-server</span> <span class="hljs-number">8.0</span> 默认情况下存储引擎有 <span class="hljs-number">9</span>个，Mariadb <span class="hljs-number">10</span> 默认情况下存储引擎数量有 <span class="hljs-number">11</span>个。<br></code></pre></td></tr></table></figure>

<h4 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a><strong>MyISAM</strong> <strong>存储引擎</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MyISAM 存储引擎特点<br>- 不支持事务<br>- 表级锁定<br>- 读写相互阻塞，写入不能读，读时不能写<br>- 只缓存索引<br>- 不支持外键约束<br>- 不支持聚簇索引<br>- 支持全文索引<br>- 读取数据较快，占用资源较少<br>- 不支持MVCC（多版本并发控制机制）高并发<br>- 崩溃恢复性较差<br>- MySQL5.<span class="hljs-number">5.5</span> 前默认的数据库引擎<br><br>MyISAM 存储引擎适用场景<br>- 读多写少的业务（或者只读的业务）<br>- 不需要事务支持的业务（比如转账，充值这种业务就不行）<br>- 并发访问低的业务<br>- 对数据一致性要求不高的业务<br>- 表较小（可以接受长时间进行修复操作）<br><br>MyISAM 存储引擎相关文件<br>- tbl_name.frm 表格式定义<br>- tbl_name.sdi 表格式定义（mysql8.<span class="hljs-number">0</span>开始，但是MariaDB目前依然在使用frm）<br>- tbl_name.MYD 数据文件<br>- tbl_name.MYI 索引文件<br></code></pre></td></tr></table></figure>

<h4 id="InnoDB-存储引擎"><a href="#InnoDB-存储引擎" class="headerlink" title="InnoDB 存储引擎"></a><strong>InnoDB</strong> <strong>存储引擎</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs powershell">InnoDB 存储引擎特点<br>- 支持事务，适合处理大量短期事务<br>- 行级锁定<br>- 读写阻塞与事务隔离级别相关<br>- 可缓存数据和索引<br>- 支持聚簇索引<br>- 崩溃恢复性更好<br>- 支持MVCC高并发<br>- 支持表分区，支持表空间<br>- 从MySQL5.<span class="hljs-number">5</span> 后支持全文索引<br>- 从MySQL5.<span class="hljs-number">5.5</span> 开始为默认的数据库引擎<br><br>InnoDB 存储引擎适用场景<br>- 数据读写都较为频繁的业务<br>- 需要事务支持的业务<br>- 对并发要求较高的业务<br>- 对数据一致性要求较高的业务<br><br>InnoDB 存储引擎相关文件<br>- tbl_name.frm 表格式定义<br>- tbl_name.ibd 数据和索引文件<br></code></pre></td></tr></table></figure>





<p><strong>MySQL****中常见的存储引擎特性说明</strong></p>
<table>
<thead>
<tr>
<th>特性（Feature）</th>
<th>MyISAM 存储引擎</th>
<th>Memory 存储引擎</th>
<th>InnoDB 存储引擎</th>
<th>Archive 存储引擎</th>
<th>NDB 存储引擎</th>
</tr>
</thead>
<tbody><tr>
<td>B 树索引（B - tree indexes）</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>备份时间点恢复（Backup&#x2F;point - in - time recovery）</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>集群模式（Cluster database support）</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>聚集索引（Clustered indexes）</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>数据压缩（Compressed data）</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>数据缓存（Data caches）</td>
<td>No</td>
<td>N&#x2F;A</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>数据加密（Encrypted data）</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>外键（Foreign key support）</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>全文检索（Full - text search indexes）</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>地理空间数据类型（Geospatial data type support）</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>地理空间数据索引（Geospatial indexing support）</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>HASH 索引（Hash indexes）</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>索引缓存（Index caches）</td>
<td>Yes</td>
<td>N&#x2F;A</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>锁颗粒度（Locking granularity）</td>
<td>Table</td>
<td>Table</td>
<td>Row</td>
<td>Row</td>
<td>Row</td>
</tr>
<tr>
<td>多版本并发控制（MVCC）</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>数据同步（Replication support）</td>
<td>Yes</td>
<td>Limited</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>表空间上限（Storage limits）</td>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>None</td>
<td>384EB</td>
</tr>
<tr>
<td>T 树索引（T - tree indexes）</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>事务（Transactions）</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>元数据静态更新（Update statistics for data dictionary）</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<h4 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">锁是计算机协调多个进程或线程并发访问某一资源的机制。<br>在关系型数据库中，按数据操作的颗粒度划分，分为表锁，行锁和页锁<br><br>表锁：<br>  表锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁（哪怕只操作表里面的一行数据），它实现简单，消耗资源少，被大部份 MySQL 存储引擎支持，MyISAM 存储引擎使用表锁，表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。<br>  表锁的特点是开销小，加锁快，不会出现死锁，锁定颗粒度大，发生锁冲突的概率高，并发性差。<br><br>行锁：<br>  行锁是 MySQL 中锁定粒度最小的一种锁，表示只对当前操作的行加锁，行锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。InnoDB存储引擎默认采用行锁。<br>  行锁的特点是开销大，加锁慢，会出现死锁，锁定颗粒度最小，发生锁冲突的概率最低，并发性好。<br></code></pre></td></tr></table></figure>

<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">共享表空间<br>  共享表空间是指表结构文件单独放在以数据命名的文件夹中，格式为 tbl_name.frm，所有 InnoDB 引擎表的数据都放在一个文件中 (ibdata1,ibdata2,...)。<br>  <br>独立表空间<br>  独立表空间是指用独立文件存放每个表的表结构 tbl_name.frm 和数据及索引  tbl_name.ibd，在独立表空间的前提下，共享表空间中的 ibdata 文件还是存在，独立表空间文件只存储该表的数据，索引和插入缓冲的BITMAP等信息，其它信息还是存放在共享表空间中。<br></code></pre></td></tr></table></figure>

<h4 id="表结构与数据存储的分离"><a href="#表结构与数据存储的分离" class="headerlink" title="表结构与数据存储的分离"></a>表结构与数据存储的分离</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">表结构存储：<br>   在 MySQL 数据库中，对于使用 InnoDB 引擎的表，其表结构文件是以.frm为后缀的，并且单独存放在以数据库名命名的文件夹中。比如有一个数据库叫mydb，里面有一张表mytable，那么mytable的表结构文件mytable.frm就会存放在mydb这个文件夹下。这种存储方式使得表结构的管理和维护相对独立，便于数据库系统快速定位和读取表的定义信息，比如表的列结构、索引结构等。<br>数据存储：<br>   所有 InnoDB 引擎表的数据并没有跟随各自的表结构文件分散存储，而是集中存放在ibdata1、ibdata2等这样的文件中。这意味着不同表的数据在物理存储上是聚合在一起的，形成了一个共享的空间来存储所有相关表的数据。<br></code></pre></td></tr></table></figure>

<h4 id="InnoDB-存储引擎中的-MVCC"><a href="#InnoDB-存储引擎中的-MVCC" class="headerlink" title="InnoDB 存储引擎中的 MVCC"></a><strong>InnoDB</strong> <strong>存储引擎中的</strong> <strong>MVCC</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MVCC（Multi<span class="hljs-literal">-Version</span> Concurrency Control）：多版本并发控制<br>MVCC 是一种实现并发控制的方法，一般用在数据库管理系统中，实现对数据库的并发访问。<br>    MVCC 使得大部份支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，而是把数据库的行锁与数据版本结合起来，只需要很小的开销，就可以实现非锁定读，从而大大提高了数据库系统的并发性能。<br></code></pre></td></tr></table></figure>

<h5 id="InnoDB-中的-MVCC"><a href="#InnoDB-中的-MVCC" class="headerlink" title="InnoDB 中的 MVCC"></a>InnoDB 中的 MVCC</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">在MySQL中，使用 InnoDB 存储引擎的表，在创建时，系统会自动给表加上两个版本控制字段，这是两个隐藏列，这两个字段不显示在表结构中。<br>其中一个字段保存了行的创建时间，一个保存了行的过期时间（或删除时间），（实际上存储的并不是时间，而是版本号，为了方便理解，我们认为记录的是时间）。<br>当客户端要执行SQL语句时，会根据当前的时间与数据表中记录的时间进行比较，确保不会让客户端得到非法数据。<br></code></pre></td></tr></table></figure>

<h2 id="数据库服务配置"><a href="#数据库服务配置" class="headerlink" title="数据库服务配置"></a>数据库服务配置</h2><h3 id="数据库基本信息"><a href="#数据库基本信息" class="headerlink" title="数据库基本信息"></a>数据库基本信息</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">mysql 数据库<br>类似于Sql Server中的master库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。<br><br>information_schema 数据库<br><br>performance_schema 数据库<br>主要用于收集数据库服务器性能参数，库里表的存储引擎均为PERFORMANCE_SCHEMA，用户不能创建存储引擎为 PERFORMANCE_SCHEMA 的表<br></code></pre></td></tr></table></figure>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="1-服务器系统变量"><a href="#1-服务器系统变量" class="headerlink" title="1 服务器系统变量"></a><strong>1</strong> <strong>服务器系统变量</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">服务器系统变量分为全局变量和会话变量两种，全局变量表示可以影响到所有连接终端，所有会话，会话变量只影响当前会话。<br><br>全局变量在MySQL服务器启动时被初始化，并且对所有会话都有效。全局变量的值可以被所有会话共享，并且可以通过<span class="hljs-built_in">SET</span> GLOBAL语句进行修改（需要适当的权限）。一些全局变量定义了服务器的属性、特征，例如max_connections用于限制服务器的最大连接数。<br><br>会话变量是特定于当前会话（连接）的变量。每个会话都有自己的一组会话变量，这些变量的值在会话期间是有效的，并且对其他会话是不可见的。会话变量可以通过<span class="hljs-built_in">SET</span> SESSION语句或<span class="hljs-built_in">SET</span>（不带GLOBAL或SESSION关键字，默认为会话级别）语句进行修改。一些会话变量可以复制全局变量的值作为其初始值，但之后可以在会话中独立修改。<br><br>全局变量：数量相对较少，因为它们定义了服务器的整体行为和属性。<br>会话变量：数量可能更多，因为每个会话都可以有自己的会话变量集合，并且这些变量可以在会话期间被动态创建和修改。<br></code></pre></td></tr></table></figure>

<h4 id="查看变量"><a href="#查看变量" class="headerlink" title="查看变量"></a>查看变量</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">查看全局所有变量<br>show global status\G<br><br>查看指定变量<br>show status like <span class="hljs-string">&#x27;Com_select&#x27;</span>;<br><br>查看全局变量<br>show global status like <span class="hljs-string">&#x27;Com_select&#x27;</span>;<br></code></pre></td></tr></table></figure>





<h4 id="会话变量修改"><a href="#会话变量修改" class="headerlink" title="会话变量修改"></a><strong>会话变量修改</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">修改会话变量：仅对当前会话有影响<br><span class="hljs-built_in">SET</span> [<span class="hljs-type">SESSION</span>] system_var_name=value;<br><span class="hljs-built_in">SET</span> <span class="hljs-selector-tag">@</span><span class="hljs-selector-tag">@</span>[<span class="hljs-type">session.</span>]system_var_name=value;<br><br>只读变量无法修改<br>变量无法实现永久保存，重启服务后会被重置<br></code></pre></td></tr></table></figure>

<h3 id="服务器状态变量"><a href="#服务器状态变量" class="headerlink" title="服务器状态变量"></a>服务器状态变量</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">服务器状态变量：分全局和会话两种，其中许多变量有双重域，既是全局变量，也是会话变量，有相同的名字<br>状态变量用于保存 MySQL 运行中的统计数据的变量，只读，不可修改。<br></code></pre></td></tr></table></figure>

<h4 id="服务器变量-sql-mode"><a href="#服务器变量-sql-mode" class="headerlink" title="服务器变量 sql_mode"></a><strong>服务器变量</strong> <strong>sql_mode</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">sql_mode 是服务器选项，也是变量，其值会影响 SQL 语句执行的工作模式。<br><br>服务器变量 sql_mode 是 MySQL 数据库中的一个重要系统变量，它用于控制 MySQL 如何处理 SQL 语句和数据校验。sql_mode 可以看作是一组约束和规范，用于确保数据的准确性、完整性和一致性。<br>通过设置不同的 sql_mode 选项，可以改变 MySQL 的执行和处理方式，以适应不同的需求或标准。<br><br>作用<br>控制数据的插入、更新和删除操作，确保数据符合表的定义。<br>对插入数据进行校验，如日期格式、数据类型长度等。<br>改变 MySQL 对于字符串和数字之间的隐式转换规则。<br>使 MySQL 的语法更加严格，符合 ANSI SQL 标准。<br>提高 MySQL 的安全性，避免一些潜在的安全漏洞。<br><br></code></pre></td></tr></table></figure>

<h2 id="INDEX-索引"><a href="#INDEX-索引" class="headerlink" title="INDEX 索引"></a><strong>INDEX</strong> <strong>索引</strong></h2><h3 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">索引是 帮助 MySQL高效获取数据的 数据结构<br>MySQL索引是一种特殊的数据库结构，由数据库表中一列或多列组合而成，主要用于加快数据的查询和检索速度。它类似于书籍的目录或字典的音序表，可以帮助数据库系统快速定位和获取所需的数据，从而提高查询性能。<br><br>优点<br>- 大大加快数据的检索速度;<br>- 创建唯一性索引，保证数据库表中每一行数据的唯一性;<br>- 加速表和表之间的连接;<br>- 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。<br><br>缺点<br>- 索引需要占物理空间。<br>- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度<br><br></code></pre></td></tr></table></figure>

<h4 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a><strong>索引数据结构</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL索引的算法和结构主要取决于存储引擎。对于InnoDB存储引擎，最常用的索引结构是B+树索引。<br>B+树索引具有以下特点：<br>    所有数据都会出现在叶子节点：叶子节点形成一个单向链表，便于范围搜索和排序。<br>    非叶子节点仅起到索引数据作用：不存储实际数据，只存储索引，使得树的层级更低，性能更高。<br><br>索引结构-树<br>树的分类<br>- 无序树：树中任意节点的子结点之间没有顺序关系<br>- 有序树：树中任意节点的子结点之间有顺序关系<br><br>- 二叉树：每个节点最多含有两个子树的树称为二叉树<br>- 二叉查找树：<br> 首先它是一颗二叉树，<br> - 若左子树不空，则左子树上所有结点的值均小于它的根结点的值，<br> - 若右子树不空，则右子树上所有结点的值均大于它的根结点的值，<br> - 左、右子树也分别为二叉排序树<br>- 满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树<br>- 完全二叉树：如果一颗二叉树除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布<br>- 霍夫曼树：带权路径最短的二叉树<br>- 红黑树：<br> 红黑树是一颗特殊的二叉查找树，<br> - 每个节点都是黑色或者红色，根节点、叶子节点是黑色。<br> - 如果一个节点是红色的，则它的子节点必须是黑色的<br>- 平衡二叉树(AVL)：一 棵空树或它的左右两个子树的高度差的绝对值不超过<span class="hljs-number">1</span>，并且左右两个子树都是一棵平衡二叉树<br></code></pre></td></tr></table></figure>

<h4 id="B-树"><a href="#B-树" class="headerlink" title="**B-**树"></a>**B-**树</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">B-树，读作B树，中间的横线是连字符，不是减号，B树将一个节点的大小设置为每个数据页(Page，也可以称为块，block)的大小，一般是<span class="hljs-number">16</span>KB，并且，B树中是将数据和索引放在一起的，以减少IO次数，加快查询速度，一个节点能放多少数据，通常取决于一条数据占用的空间大小。<br></code></pre></td></tr></table></figure>

<h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="**B+**树索引"></a>**B+**树索引</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">B+树是B-树的变体，也是一棵多路搜索树，MySQL普遍使用B+树来实现索引。<br><br>B+树和B-树的主要区别：<br>B-树内部节点是保存数据的，而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。<br>B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。<br>查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束<br>B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。<br></code></pre></td></tr></table></figure>

<h4 id="B-树和B-树的主要区别"><a href="#B-树和B-树的主要区别" class="headerlink" title="B+树和B-树的主要区别"></a>B+树和B-树的主要区别</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">B-树内部节点是保存数据的，而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保<br>存数据。<br>B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。<br>查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束<br>B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。<br></code></pre></td></tr></table></figure>

<h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a><strong>查看索引</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SHOW INDEX FROM [<span class="hljs-type">db_name.</span>]tbl_name;<br></code></pre></td></tr></table></figure>

<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell">CREATE [<span class="hljs-type">UNIQUE</span>] INDEX index_name ON tbl_name (index_col_name[(<span class="hljs-type">length</span>)],...);<br>ALTER TABLE tbl_name ADD INDEX index_name(index_col_name[(<span class="hljs-type">length</span>)]);<br><br>语法示例：<br> CREATE INDEX idx_name ON student(name); <br> 创建一个索引，该索引包含 name 列的完整值。<br> 这意味着，无论 name 列中的字符串有多长，整个字符串都会被包含在索引中。<br> <br> CREATE INDEX idx_name ON student(name(<span class="hljs-number">10</span>)); <br> 创建一个前缀索引，该索引仅包含 name 列的前 <span class="hljs-number">10</span> 个字符。<br> 这意味着，索引是基于 name 列值的前 <span class="hljs-number">10</span> 个字符创建的<br></code></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">DROP INDEX index_name ON tbl_name;<br>ALTER TABLE tbl_name DROP INDEX index_name(index_col_name);<br></code></pre></td></tr></table></figure>

<h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">所谓并发控制：是指多个进程同时读写一条数据的时候数据库对此情况的处理方式。<br><br>锁机制<br>读锁   共享锁，也称为 S 锁，只读不可写（包括当前事务），多个读互不阻塞<br>写锁   独占锁，排它锁，也称为 X 锁，写锁会阻塞其它事务（不包括当前事务）的读和写<br><br></code></pre></td></tr></table></figure>

<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">锁是加在索引上的,不是加在数据上的.<br><br></code></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>类别</th>
<th>详情</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>存储引擎</td>
<td>锁粒度</td>
<td>锁的实现</td>
<td>锁类型</td>
<td>说明</td>
</tr>
<tr>
<td>MyISAM</td>
<td>表级锁</td>
<td>存储引擎自行实现该引擎的锁策略和锁粒度</td>
<td>隐式锁</td>
<td>由存储引擎自动施加锁</td>
</tr>
<tr>
<td>MyISAM</td>
<td>表级锁</td>
<td>自行实现（在程序中或命令行下用命令显式实现）</td>
<td>显式锁</td>
<td>用户手动请求</td>
</tr>
<tr>
<td>InnoDB</td>
<td>行级锁</td>
<td>存储引擎自行实现该引擎的锁策略和锁粒度</td>
<td>隐式锁</td>
<td>由存储引擎自动施加锁</td>
</tr>
<tr>
<td>InnoDB</td>
<td>行级锁</td>
<td>自行实现（在程序中或命令行下用命令显式实现）</td>
<td>显式锁</td>
<td>用户手动请求</td>
</tr>
</tbody></table>
<h4 id="锁命令"><a href="#锁命令" class="headerlink" title="锁命令"></a>锁命令</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs powershell">加读锁<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; lock tables student read;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.000</span> sec)<br><br>释放读锁<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; unlock tables;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.001</span> sec)<br><br>加写锁<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; lock table student <span class="hljs-built_in">write</span>;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.000</span> sec)<br><br>释放写锁<br>连接或进程只能释放其自身施加的锁。一个session只能为自己获取锁和释放锁，不能为其他session获取锁，也不能释放由其他session保持的锁。<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; unlock tables ;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.000</span> sec)<br><br><br></code></pre></td></tr></table></figure>

<h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">关闭正在打开的表（清除查询缓存），通常在备份前加全局读锁<br>FLUSH TABLES [<span class="hljs-type">tb_name</span>[,<span class="hljs-type">...</span>]] [<span class="hljs-type">WITH</span> <span class="hljs-type">READ</span> <span class="hljs-type">LOCK</span>]<br><br>关闭所有打开的表，强制关闭所有正在使用的表，并刷新查询缓存和预准备语句缓存，不会刷新脏块<br>FLUSH TABLES<br><br>关闭所有打开的表并使用全局读锁锁定所有数据库的所有表，不会刷新脏块,也不阻塞日志表写入，例如查询日志，慢日志等<br>FLUSH TABLES WITH READ LOCK<br><br>操作指定表<br>FLUSH TABLES tbl_name tb_name[,<span class="hljs-type">...</span>] WITH READ LOCK<br><br>刷新脏块, 脏块也称为脏页，当内存数据页和磁盘数据页上的内容不一致时，我们称这个内存页为脏页<br>FLUSH TABLES tbl_name [<span class="hljs-type">tb_name</span>[,<span class="hljs-type">...</span>]] <span class="hljs-keyword">FOR</span> EXPORT<br></code></pre></td></tr></table></figure>

<h4 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs powershell">事务<br>事务是一组具有原子性的 SQL 语句，或者说一个独立单元。可以理解为一个事务对应的是一组完整的业务，这个业务有一条或多条 SQL 语句组成。所谓原子性是指，这一组业务中的 SQL 语句不可分割，所以，要么全部 SQL 语句都执行成功，事务也就执行成功；只要有一条 SQL 语句执行失败，则整个事务都要回滚到事务开始前。<br><br>事务特性<br>原子性( Atomicity )<br>  原子性又称不可分割性。一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br><br>一致性( Consistency )<br>   事务的执行结果，必须是符合预期的，这表示在事务中进行的数据读写，完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。<br><br>隔离性( Isolation )<br>  隔离性又称独立性。MySQL 允许多个事务并发，同时进行写操作，隔离性用于实现事务的并发控制，防止多个事务并发执行时的交叉执行而导致的数据不一致。<br>  事务的隔离分为不同的级别，包括读未提交( Read uncommitted )，读提交( read committed )，可重复读( repeatable read )，串行化( Serializable )。<br>  <br>持久性( Durability )<br>事务执行成功后，其对于数据的修改会永久保存于数据库中。<br><br></code></pre></td></tr></table></figure>

<h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">显式启动事务 语法解读<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">BEGIN</span> WORK<br><span class="hljs-built_in">START</span> TRANSACTION<br><br>结束事务<br><span class="hljs-comment">#提交执行</span><br>COMMIT<br><span class="hljs-comment">#回滚</span><br>ROLLBACK<br></code></pre></td></tr></table></figure>

<h4 id="自动提交能力"><a href="#自动提交能力" class="headerlink" title="自动提交能力"></a><strong>自动提交能力</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs powershell">对于mysql来说，每一个对于数据的增删改的动作，都是一个事务，为什么我们操作过数据之后，另外的终端可以立刻生效呢？<br>原因是，mysql对于这种操作，启用了 自动提交的能力。<br><br>默认开始自动提交<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; <span class="hljs-built_in">select</span> <span class="hljs-selector-tag">@</span>@autocommit;<br>+<span class="hljs-literal">--------------</span>+<br>| <span class="hljs-selector-tag">@</span>@autocommit |<br>+<span class="hljs-literal">--------------</span>+<br>|            <span class="hljs-number">1</span> |<br>+<span class="hljs-literal">--------------</span>+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br>关闭自动提交<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; <span class="hljs-built_in">set</span> autocommit=<span class="hljs-number">0</span>;<br>Query OK, <span class="hljs-number">0</span> rows affected (<span class="hljs-number">0.000</span> sec)<br><br>MariaDB [<span class="hljs-type">testdb</span>]&gt; <span class="hljs-built_in">select</span> <span class="hljs-selector-tag">@</span>@autocommit;<br>+<span class="hljs-literal">--------------</span>+<br>| <span class="hljs-selector-tag">@</span>@autocommit |<br>+<span class="hljs-literal">--------------</span>+<br>|            <span class="hljs-number">0</span> |<br>+<span class="hljs-literal">--------------</span>+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br></code></pre></td></tr></table></figure>

<h4 id="查看事务"><a href="#查看事务" class="headerlink" title="查看事务"></a>查看事务</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#查看当前正在进行的事务</span><br><span class="hljs-built_in">SELECT</span> * FROM INFORMATION_SCHEMA.INNODB_TRX;<br></code></pre></td></tr></table></figure>

<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs powershell">死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等的进程称为死锁进程。<br><br>死锁语法解析<br>查看innodb状态，可以查看锁信息<br>show engine innodb status;<br>查看正在进行中的事务<br><span class="hljs-built_in">SELECT</span> * FROM information_schema.INNODB_TRX;<br>查看锁<br><span class="hljs-built_in">SELECT</span> * FROM information_schema.INNODB_LOCKS;<br>MySQL8.<span class="hljs-number">0.13</span> 及以后使用此语句查看锁<br><span class="hljs-built_in">SELECT</span> * FROM performance_schema.data_locks;<br>查看锁等待<br><span class="hljs-built_in">SELECT</span> * FROM information_schema.INNODB_LOCK_WAITS;<br>MySQL8.<span class="hljs-number">0.13</span>及以后使用此语句查看锁等待<br><span class="hljs-built_in">SELECT</span> * FROM performance_schema.data_lock_waits;<br></code></pre></td></tr></table></figure>

<h4 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL 的事务隔离级别一共有四个，分别是 读未提交、读已提交、可重复读 以及 可串行化。MySQL 的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。<br><br>读未提交（READ UNCOMMITTED）<br>  在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。可能发生 脏读、不可重复读和 幻读问题，一般很少使用此隔离级别。<br>  简单来说：你没有提交的时候，我就看到你修改的数据<br><br>读已提交（READ COMMITTED）<br>  在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。<br>  简单来说：你提交后，我才可以看到你修改的数据。<br><br>可重复读（REPEATABLE READ）<br>  在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。<br>  简单来说，你提交了，我也提交了，我才有能力读自己的数据。<br><br>可串行化（SERIALIZABLE）<br>  可串行化，又称序列化。各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。<br>  简单来说；咱们俩，谁先开始【另外一个人处于等待状态】，谁后开始的问题。<br>  <br>以上四种隔离级别，从上往下，隔离强度逐渐增强，性能逐渐变差，需要消耗的 MySQL 的资源越多，<br>所以并不是隔离强度越高越好，采用哪种隔离级别要根据系统需求权衡决定，MySQL 中默认的隔离级<br>别是可重复读。<br></code></pre></td></tr></table></figure>

<h4 id="事务并发中可能出现的问题"><a href="#事务并发中可能出现的问题" class="headerlink" title="事务并发中可能出现的问题"></a><strong>事务并发中可能出现的问题</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs powershell">脏读（Dirty Read） - 只在 读未提交 隔离级别才会出现<br>脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并不一定最终存在的数据，这就是脏读。<br><br>不可重复读（Non<span class="hljs-literal">-Repeatable</span> Read） - 在 读未提交 和 读已提交 隔离级别都可能会出现<br>不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。<br><br>幻读（Phantom）-在 读未提交、读已提交、可重复读 隔离级别都可能会出现<br>一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。<br></code></pre></td></tr></table></figure>

<h4 id="MVCC和事务的隔离级别"><a href="#MVCC和事务的隔离级别" class="headerlink" title="MVCC和事务的隔离级别"></a><strong>MVCC</strong>和事务的隔离级别</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MVCC（多版本并发控制机制）只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。<br><br></code></pre></td></tr></table></figure>

<h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><h4 id="MySQL的日志类型"><a href="#MySQL的日志类型" class="headerlink" title="MySQL的日志类型"></a><strong>MySQL</strong>的日志类型</h4><p>MySQL 支持丰富的日志类型，主要有以下六种：</p>
<table>
<thead>
<tr>
<th>日志类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>事务日志</td>
<td>记录 InnoDB 等支持事务的存储引擎执行事务时产生的日志，其写入类型为顺序 IO</td>
</tr>
<tr>
<td>错误日志</td>
<td>记录 MySQL 服务的启动、运行或停止 MySQL 服务时出现的问题，通常也会记录 Warning</td>
</tr>
<tr>
<td>通用日志</td>
<td>又称查询日志，记录建立的客户端连接和执行的语句</td>
</tr>
<tr>
<td>慢查询日志</td>
<td>记录所有执行时间超过 long_query_time 的所有查询或不使用索引的查询，有助于定位性能问题</td>
</tr>
<tr>
<td>二进制日志</td>
<td>记录所有更改数据的语句，主要用于复制和即时点恢复</td>
</tr>
<tr>
<td>中继日志</td>
<td>从主服务器的二进制日志文件中复制而来的事件，并保存为的日志文件，与二进制日志几乎相同</td>
</tr>
</tbody></table>
<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs powershell">Mariadb 查看日志信息<br><span class="hljs-comment">#MariaDB中的相关变量</span><br>MariaDB [<span class="hljs-type">testdb</span>]&gt; show variables like <span class="hljs-string">&#x27;%innodb_log%&#x27;</span>;<br>+<span class="hljs-literal">-----------------------------</span>+<span class="hljs-literal">-----------</span>+<br>| Variable_name               | Value     |<br>+<span class="hljs-literal">-----------------------------</span>+<span class="hljs-literal">-----------</span>+<br>| innodb_log_buffer_size      | <span class="hljs-number">16777216</span>  |<br>| innodb_log_checksums        | ON        |<br>| innodb_log_compressed_pages | ON        |<br>| innodb_log_file_size        | <span class="hljs-number">100663296</span> |<br>| innodb_log_files_in_group   | <span class="hljs-number">1</span>         |<br>| innodb_log_group_home_dir   | ./        |<br>| innodb_log_optimize_ddl     | OFF       |<br>| innodb_log_write_ahead_size | <span class="hljs-number">8192</span>      |<br>+<span class="hljs-literal">-----------------------------</span>+<span class="hljs-literal">-----------</span>+<br><span class="hljs-number">8</span> rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br>确认日志所处的位置<br>MariaDB [<span class="hljs-type">testdb</span>]&gt; show variables like <span class="hljs-string">&#x27;%datadir%&#x27;</span>;<br>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">-------------------</span>+<br>| Variable_name | Value             |<br>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">-------------------</span>+<br>| datadir       | /mysql/<span class="hljs-number">3306</span>/<span class="hljs-keyword">data</span>/ |<br>+<span class="hljs-literal">---------------</span>+<span class="hljs-literal">-------------------</span>+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.001</span> sec)<br><br></code></pre></td></tr></table></figure>

<h4 id="事务日志性能优化"><a href="#事务日志性能优化" class="headerlink" title="事务日志性能优化"></a>事务日志性能优化</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">redo log 包含日志缓冲（redo log buffer）和磁盘上的日志文件（redo logfile）两部分。<br>MySQL 每执行新一条 DML 语句都会先将日志记录在 redo log buffer 中，然后再根据不同的配置项，使用不同的规则将 redo log buffer 中的数据落盘（写入到 redo log file）。<br>但是，redo log buffer 是用户空间的数据，无法直接写入磁盘，中间必须经过操作系统缓冲区（OS Buffer），因此，从 redo log buffer 到 redo log file，实际上会先写 OS Buffer，再调用fsync() 将其刷人入到 redo log file 中。<br></code></pre></td></tr></table></figure>

<h4 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MySQL 中错误日志中记录的主要内容<br>- mysqld 启动和关闭过程中输出的事件信息<br>- mysqld 运行中产生的错误信息<br>- event scheduler 运行一个 event 时产生的日志信息<br>- 在主从复制架构中的从服务器上启动从服务器线程时产生的信息<br></code></pre></td></tr></table></figure>

<h4 id="通用日志"><a href="#通用日志" class="headerlink" title="通用日志"></a>通用日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">通用日志<br>  通用日志，又称通用查询日志（General Query Log），用来记录对数据库的所有操作，包括启动和关闭 MySQL 服务、更新语句和查询语句等。默认情况下，通用查询日志功能是关闭的。<br>  可以通过配置开启此日志，并决定将日志存储到文件或数据表中。如果选择记录到数据表中，则具体的表是 mysql.general_log<br></code></pre></td></tr></table></figure>

<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs powershell">  慢查询日志用来记录在 MySQL 中执行时间超过指定时间的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率低，以便进行优化。<br>  慢查询日志默认不开启。<br><br>Mariadb环境查看<br>MariaDB [<span class="hljs-type">mysql</span>]&gt; <span class="hljs-built_in">select</span> <span class="hljs-selector-tag">@</span>@slow_query_log,<span class="hljs-selector-tag">@</span>@slow_query_log_file,<span class="hljs-selector-tag">@</span>@long_query_time;<br>+<span class="hljs-literal">------------------</span>+<span class="hljs-literal">-----------------------</span>+<span class="hljs-literal">-------------------</span>+<br>| <span class="hljs-selector-tag">@</span>@slow_query_log | <span class="hljs-selector-tag">@</span>@slow_query_log_file | <span class="hljs-selector-tag">@</span>@long_query_time |<br>+<span class="hljs-literal">------------------</span>+<span class="hljs-literal">-----------------------</span>+<span class="hljs-literal">-------------------</span>+<br>|                <span class="hljs-number">0</span> | bogon<span class="hljs-literal">-slow</span>.log        |         <span class="hljs-number">10.000000</span> |<br>+<span class="hljs-literal">------------------</span>+<span class="hljs-literal">-----------------------</span>+<span class="hljs-literal">-------------------</span>+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br>开启慢查询日志<br><br></code></pre></td></tr></table></figure>

<h4 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs powershell">   二进制日志（Binary Log）也可叫作变更日志（Update Log），是 MySQL 中非常重要的日志。主要用于记录数据库的变化情况，即 SQL 语句的 DDL 和 DML 语句，但不包含查询操作语句，因为查询语句并不会改变数据库中的数据。<br>   如果 MySQL 数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。<br>   <br>事务日志和二进制区别<br>- 事务日志可以看作是在线日志，二进制日志可以看作是离线日志<br>- 事务日志记录事务执行的过程，包括提交和未提交，二进制日志记录只记提交的过程<br>- 事务日志只支持 InnoDB 存储引擎，二进制支持 InnoDB 和 MyISAM 存储引擎<br>- 事务日志的容量是<span class="hljs-number">100</span>M的大小，会滚动覆盖式更新，二进制的容量大小没有限制。<br><br>二进制日志记录三种格式<br>- Statement：基于语句的记录模式，日志中会记录原生执行的 SQL 语句，对于某些函数或变量，不会替换。<br>- Row：基于行的记录模式，会将 SQL 语句中的变量和函数进行替换后再记录。<br>- Mixed：混合记录模式，在此模式下，MySQL 会根据具体的 SQL 语句来分析采用哪种模式记录日志。<br></code></pre></td></tr></table></figure>

<h4 id="查看二进制文件"><a href="#查看二进制文件" class="headerlink" title="查看二进制文件"></a>查看二进制文件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs powershell">MariaDB [<span class="hljs-type">db2</span>]&gt; <span class="hljs-built_in">select</span> <span class="hljs-selector-tag">@</span>@binlog_format;<br>+<span class="hljs-literal">-----------------</span>+<br>| <span class="hljs-selector-tag">@</span>@binlog_format |<br>+<span class="hljs-literal">-----------------</span>+<br>| MIXED           |<br>+<span class="hljs-literal">-----------------</span>+<br><span class="hljs-number">1</span> row <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (<span class="hljs-number">0.000</span> sec)<br><br>查看当前服务的二进制文件列表<br>SHOW &#123;BINARY | MASTER&#125; LOGS<br>查看正在使用的二进制文件<br>SHOW MASTER STATUS<br></code></pre></td></tr></table></figure>


  </div>

  
    <!-- Comments -->
    <article id="comments" lazyload>
      
      
        
      
      

    </article>
  
</article>





  



  



  



  



  





    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>




  
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/DynamicRibbon.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/runtime.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/snowflake.min.js"></script>
<script src="//cdn.jsdelivr.net/gh/EmoryHuang/BlogBeautify@1.1/Cherry.min.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
