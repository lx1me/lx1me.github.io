<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://lx1me.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lx1me.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-网络安全技术基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/05/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2025-06-05T01:52:55.118Z" itemprop="datePublished">2025-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="网络安全技术基础"><a href="#网络安全技术基础" class="headerlink" title="网络安全技术基础"></a>网络安全技术基础</h1><hr>
<h2 id="title-网络安全技术基础date-2025-06-05categories-网络安全-tags-IDS-防火墙-网络攻击-description-网络安全技术中的基本概念和防御机制概述"><a href="#title-网络安全技术基础date-2025-06-05categories-网络安全-tags-IDS-防火墙-网络攻击-description-网络安全技术中的基本概念和防御机制概述" class="headerlink" title="title: 网络安全技术基础date: 2025-06-05categories: [网络安全]tags: [IDS, 防火墙, 网络攻击]description: 网络安全技术中的基本概念和防御机制概述"></a>title: 网络安全技术基础<br>date: 2025-06-05<br>categories: [网络安全]<br>tags: [IDS, 防火墙, 网络攻击]<br>description: 网络安全技术中的基本概念和防御机制概述</h2><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-IDS：入侵检测系统-Intrusion-Detection-Systems"><a href="#1-1-IDS：入侵检测系统-Intrusion-Detection-Systems" class="headerlink" title="1.1 IDS：入侵检测系统 (Intrusion Detection Systems)"></a>1.1 IDS：入侵检测系统 (Intrusion Detection Systems)</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 特点：</span><br><span class="line">  - 不阻断网络访问，而是依据安全策略对网络和系统运行状况进行监控。</span><br><span class="line">  - 尽可能发现各种攻击企图、攻击行为或攻击结果。</span><br><span class="line">  - 保障机密性、完整性和可用性，是安全防护的重要监测手段。</span><br></pre></td></tr></table></figure>

<h3 id="1-2-IPS：入侵防御系统-Intrusion-Prevention-System"><a href="#1-2-IPS：入侵防御系统-Intrusion-Prevention-System" class="headerlink" title="1.2 IPS：入侵防御系统 (Intrusion Prevention System)"></a>1.2 IPS：入侵防御系统 (Intrusion Prevention System)</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 特点：</span><br><span class="line">  - 以串行方式接入系统，能深度感知并检测经过的数据报文。</span><br><span class="line">  - 根据预设安全策略对报文进行深度检测（协议分析、特征匹配、流量统计、事件关联等）。</span><br><span class="line">  - 如发现网络攻击，立即采取措施（中断连接、丢弃报文、隔离文件、告警等），实现主动防御。</span><br></pre></td></tr></table></figure>

<h3 id="1-3-防火墙-Firewall"><a href="#1-3-防火墙-Firewall" class="headerlink" title="1.3 防火墙 (Firewall)"></a>1.3 防火墙 (Firewall)</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 功能与作用：</span><br><span class="line">  - 在内部网络与外部网络、专用网络与公共网络、可信网络与不可信网络之间建立安全屏障。</span><br><span class="line">  - 通过访问控制允许经许可的数据进出，同时阻断非法流量。</span><br><span class="line">  - 支持规则配置，既可禁止本地网络向外发送数据，也可根据需要转发网络流量。</span><br></pre></td></tr></table></figure>

<h3 id="1-4-防水墙-Waterwall"><a href="#1-4-防水墙-Waterwall" class="headerlink" title="1.4 防水墙 (Waterwall)"></a>1.4 防水墙 (Waterwall)</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 功能与特点：</span><br><span class="line">  - 防止内部信息泄漏，保护涉密信息、重要业务数据和技术专利。</span><br><span class="line">  - 利用透明加解密、身份认证、访问控制和审计跟踪等技术手段实现安全保护。</span><br><span class="line">  - 最大限度防止信息泄漏、破坏或违规外传，并完整记录操作日志以便日后审计。</span><br></pre></td></tr></table></figure>

<h3 id="1-5-网络解决方案的常见样式"><a href="#1-5-网络解决方案的常见样式" class="headerlink" title="1.5 网络解决方案的常见样式"></a>1.5 网络解决方案的常见样式</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 两层防火墙：内层防火墙限制极高，只允许特定网络访问。</span><br><span class="line"><span class="number">2</span>. 单层防火墙：一套防火墙配备三个网卡接口，但存在一定安全隐患。</span><br><span class="line"><span class="number">3</span>. 多层防火墙：在靠近互联网的外部部署更多防火墙，增强防护深度。</span><br><span class="line"><span class="number">4</span>. 禁止网络访问：完全封闭网络通信，适用于高安全性场景。</span><br></pre></td></tr></table></figure>

<h2 id="2-防火墙的分类与实现方式"><a href="#2-防火墙的分类与实现方式" class="headerlink" title="2. 防火墙的分类与实现方式"></a>2. 防火墙的分类与实现方式</h2><h3 id="2-1-按照保护范围划分"><a href="#2-1-按照保护范围划分" class="headerlink" title="2.1 按照保护范围划分"></a>2.1 按照保护范围划分</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 主机防火墙：</span><br><span class="line">  - 针对单个主机进行防护，运行在终端设备上。</span><br><span class="line">  - 能阻止未授权程序和数据的进出（Windows和Linux均内置防火墙）。</span><br><span class="line"></span><br><span class="line">- 网络防火墙：</span><br><span class="line">  - 部署在整个系统的主干网络上，过滤所有进出数据包。</span><br></pre></td></tr></table></figure>

<h3 id="2-2-按实现方式划分"><a href="#2-2-按实现方式划分" class="headerlink" title="2.2 按实现方式划分"></a>2.2 按实现方式划分</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 硬件防火墙：</span><br><span class="line">  - 独立硬件设备，具备独立供电与部署。</span><br><span class="line">  - 软件独立运行，专用硬件资源使其在功能和性能上均表现优异。</span><br><span class="line">  - 常基于Linux内核二次开发，针对特定场景进行深度优化。</span><br><span class="line"></span><br><span class="line">- 软件防火墙：</span><br><span class="line">  - 以应用程序形式提供服务，运行于通用硬件平台并寄生于操作系统中。</span><br><span class="line">  - 通过纯软件实现防护，灵活性较高，便于管理和更新。</span><br></pre></td></tr></table></figure>

<h3 id="2-3-按网络协议划分"><a href="#2-3-按网络协议划分" class="headerlink" title="2.3 按网络协议划分"></a>2.3 按网络协议划分</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 网络层防火墙：</span><br><span class="line">  - 分析数据包的源地址、目标地址、端口号及协议，依据访问控制列表（ACL）执行规则。</span><br><span class="line">  - 仅基于数据包头部信息过滤，无法解析应用层数据。</span><br><span class="line"></span><br><span class="line">- 应用层防火墙：</span><br><span class="line">  - 针对特定网络应用服务协议设计数据过滤逻辑。</span><br><span class="line">  - 部署在内外部网络隔离点，作为中间转接控制数据通信。</span><br></pre></td></tr></table></figure>

<h3 id="2-4-按实现细节划分"><a href="#2-4-按实现细节划分" class="headerlink" title="2.4 按实现细节划分"></a>2.4 按实现细节划分</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- 包过滤防火墙：</span><br><span class="line">  - 根据用户定制关键字检查数据包的网络信息，不解析具体数据。</span><br><span class="line">  - 应用层控制较弱，适用于基本过滤需求。</span><br><span class="line"></span><br><span class="line">- 应用网关防火墙：</span><br><span class="line">  - 检查数据包的具体数据信息（如IP、TCP报头），实现较为细致的控制。</span><br><span class="line">  - 网络层控制较弱，但可针对特定应用场景进行配置。</span><br><span class="line"></span><br><span class="line">- 状态检测防火墙：</span><br><span class="line">  - 在包过滤基础上增加数据包状态检测，判断连接状态。</span><br><span class="line">  - 能够动态控制连接，提供更强的安全性，但应用层控制依然有限。</span><br><span class="line"></span><br><span class="line">- 复合型防火墙：</span><br><span class="line">  - 综合网络层与应用层控制，并具备会话层控制能力。</span><br><span class="line">  - 实现更全面的防护，适用于高安全性要求的环境。</span><br></pre></td></tr></table></figure>

<h2 id="3-Linux-防火墙基础知识"><a href="#3-Linux-防火墙基础知识" class="headerlink" title="3. Linux 防火墙基础知识"></a>3. Linux 防火墙基础知识</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 封装数据：</span><br><span class="line">  - 应用数据从上层进入传输层，添加源/目标端口形成数据段（TCP/UDP首部），</span><br><span class="line">    然后进入网络层，加上源/目标IP形成数据包，</span><br><span class="line">    最后进入链路层，加上源/目标MAC地址构成数据帧，形成完整数据包。</span><br><span class="line"></span><br><span class="line">- 解封装数据：</span><br><span class="line">  - 数据到达目标主机后，按照封装的反向顺序逐层解包，最终还原出真实的应用内容。</span><br><span class="line"></span><br><span class="line">- 数据包过滤：</span><br><span class="line">  - 在数据传输过程中对数据包进行严格过滤，</span><br><span class="line">    确保只有符合安全策略的流量能够通过。</span><br></pre></td></tr></table></figure>

<h2 id="4-防火墙工具"><a href="#4-防火墙工具" class="headerlink" title="4. 防火墙工具"></a>4. 防火墙工具</h2><h3 id="4-1-iptables"><a href="#4-1-iptables" class="headerlink" title="4.1 iptables"></a>4.1 iptables</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 由iptables软件包提供的命令行工具，运行于用户空间。</span><br><span class="line">- 用于编写防火墙规则，规则传递给netfilter指导内核处理数据包。</span><br><span class="line">- 默认安装于多数操作系统，如需扩展功能可开发专用模块。</span><br></pre></td></tr></table></figure>

<h3 id="4-2-xtables-nft-multi"><a href="#4-2-xtables-nft-multi" class="headerlink" title="4.2 xtables-nft-multi"></a>4.2 xtables-nft-multi</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 过渡工具，旨在帮助用户从传统iptables平滑迁移至nftables体系。</span><br><span class="line">- 管理iptables、arptables及ebtables规则，基于nftables后端实现。</span><br></pre></td></tr></table></figure>

<h3 id="4-3-firewalld"><a href="#4-3-firewalld" class="headerlink" title="4.3 firewalld"></a>4.3 firewalld</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Linux中用于动态管理防火墙规则的系统守护进程。</span><br><span class="line">- 支持定义网络区域（Zone）和接口安全等级，可实时更改规则而无需重启服务。</span><br></pre></td></tr></table></figure>

<h3 id="4-4-nftables"><a href="#4-4-nftables" class="headerlink" title="4.4 nftables"></a>4.4 nftables</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 新一代Linux防火墙技术，旨在取代传统iptables。</span><br><span class="line">- 在性能、功能及易用性方面有显著提升，适合现代网络需求。</span><br></pre></td></tr></table></figure>

<h3 id="4-5-ufw-Uncomplicated-Firewall"><a href="#4-5-ufw-Uncomplicated-Firewall" class="headerlink" title="4.5 ufw (Uncomplicated Firewall)"></a>4.5 ufw (Uncomplicated Firewall)</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 主机级防火墙配置工具，Ubuntu默认提供。</span><br><span class="line">- 简化iptables配置，兼顾易用性和灵活性。</span><br><span class="line">- 核心原理：</span><br><span class="line">  - 底层依然使用iptables，通过简单语法和默认配置进行管理。</span><br><span class="line">  - 提供便捷的命令行接口，方便规则添加、删除和管理。</span><br></pre></td></tr></table></figure>

<h2 id="5-iptables命令格式与匹配条件"><a href="#5-iptables命令格式与匹配条件" class="headerlink" title="5. iptables命令格式与匹配条件"></a>5. iptables命令格式与匹配条件</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 命令格式：</span><br><span class="line">  iptables -子命令 &lt;链&gt; &lt;规则策略&gt;</span><br><span class="line"></span><br><span class="line">- 匹配条件（多条件默认“与”关系）：</span><br><span class="line">  - [!] -s|<span class="comment">--source address[/mask][,...]    # 匹配源IP地址或网段（逗号分隔多个地址）</span></span><br><span class="line">  - [!] -d|<span class="comment">--destination address[/mask][,...]  # 匹配目标IP地址或网段</span></span><br><span class="line">  - [!] -p|<span class="comment">--protocol protocol                # 匹配具体协议（协议号或名称，0代表所有协议）</span></span><br><span class="line">  - [!] -i|<span class="comment">--in-interface name                # 匹配数据包输入接口（适用于INPUT/FORWARD/PREROUTING链）</span></span><br><span class="line">  - [!] -o|<span class="comment">--out-interface name               # 匹配数据包输出接口（适用于OUTPUT/FORWARD/POSTROUTING链）</span></span><br><span class="line">- “!” 表示规则取反。</span><br></pre></td></tr></table></figure>

<h2 id="6-网络防火墙与NAT技术"><a href="#6-网络防火墙与NAT技术" class="headerlink" title="6. 网络防火墙与NAT技术"></a>6. 网络防火墙与NAT技术</h2><h3 id="6-1-NAT原理解析"><a href="#6-1-NAT原理解析" class="headerlink" title="6.1 NAT原理解析"></a>6.1 NAT原理解析</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- NAT (Network Address Translation) 网络地址转换：</span><br><span class="line">  - 局域网内主机通常分配私有IP地址，这些地址在互联网中不可路由。</span><br><span class="line">  - 当局域网主机访问互联网时，私有IP地址经NAT转换为公网IP，</span><br><span class="line">    数据包出站进行源地址转换，入站进行目标地址转换，实现内外通信。</span><br></pre></td></tr></table></figure>

<h3 id="6-2-SNAT-实现源IP地址转换"><a href="#6-2-SNAT-实现源IP地址转换" class="headerlink" title="6.2 SNAT 实现源IP地址转换"></a>6.2 SNAT 实现源IP地址转换</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- SNAT (Source NAT)：</span><br><span class="line">  - 基于nat表，在POSTROUTING链上工作，将数据包的源IP转换为指定的公网IP。</span><br><span class="line">- 配置示例：</span><br><span class="line">  iptables -t nat -A POSTROUTING -s LocalNet ! -d LocalNet -j SNAT <span class="comment">--to-source ExtIP [--random]</span></span><br><span class="line">  - <span class="comment">--to-source：指定转换后的IP或IP范围及端口（可选）。</span></span><br><span class="line">  - <span class="comment">--random：基于hash算法实现端口映射随机化。</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-MASQUERADE-实现源IP地址转换"><a href="#6-3-MASQUERADE-实现源IP地址转换" class="headerlink" title="6.3 MASQUERADE 实现源IP地址转换"></a>6.3 MASQUERADE 实现源IP地址转换</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- MASQUERADE：</span><br><span class="line">  - 用于出口设备IP可能变化（如拨号上网）的场景，</span><br><span class="line">    自动获取网卡IP作为出口IP进行地址转换。</span><br><span class="line">- 配置示例：</span><br><span class="line">  iptables -t nat -A POSTROUTING -s LocalNet ! -d LocalNet -j MASQUERADE [<span class="comment">--to-ports port[-port]] [--random]</span></span><br><span class="line">  - <span class="comment">--to-ports：指定端口范围（可选）。</span></span><br><span class="line">  - <span class="comment">--random：随机化端口映射.</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-DNAT-实现目标IP地址转换"><a href="#6-4-DNAT-实现目标IP地址转换" class="headerlink" title="6.4 DNAT 实现目标IP地址转换"></a>6.4 DNAT 实现目标IP地址转换</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- DNAT (Destination NAT)：</span><br><span class="line">  - 用于将内网私有IP地址转换为公网IP，使内网服务在公网可见。</span><br><span class="line">  - 基于nat表，在PREROUTING链上工作。</span><br><span class="line">- 配置示例：</span><br><span class="line">  iptables -t nat -A PREROUTING -d ExtIP -p tcp|udp|icmp <span class="comment">--dport PORT -j DNAT --to-destination InterSeverIP[:PORT]</span></span><br><span class="line">  - -d ExtIP：指定固定公网IP。</span><br><span class="line">  - <span class="comment">--to-destination：转换为指定内网IP（及端口可选）。</span></span><br><span class="line">- 注意：</span><br><span class="line">  - DNAT规则仅能重定向到单台后端主机，无法实现负载均衡。</span><br><span class="line">  - 防火墙作为内核模块，其监听端口可能不通过netstat或ss显示。</span><br></pre></td></tr></table></figure>

<h3 id="6-5-REDIRECT-实现本机端口转换"><a href="#6-5-REDIRECT-实现本机端口转换" class="headerlink" title="6.5 REDIRECT 实现本机端口转换"></a>6.5 REDIRECT 实现本机端口转换</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- REDIRECT：</span><br><span class="line">  - 将数据包重定向到同一主机的其他端口，无需开启内核ip_forward转发。</span><br><span class="line">- 配置示例：</span><br><span class="line">  iptables -t nat -A PREROUTING -d ExtIP -p tcp|udp <span class="comment">--dport PORT -j REDIRECT --to-ports PORT</span></span><br><span class="line">  - <span class="comment">--to-ports：指定新的目标端口。</span></span><br></pre></td></tr></table></figure>

<h2 id="7-FORWARD链转发机制"><a href="#7-FORWARD链转发机制" class="headerlink" title="7. FORWARD链转发机制"></a>7. FORWARD链转发机制</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- FORWARD链：</span><br><span class="line">  - 处理需转发至其他主机的数据包（目的地址非本机）。</span><br><span class="line">  - 通过规则决定数据包是否允许、拒绝或丢弃。</span><br><span class="line">- 应用场景：</span><br><span class="line">  - 路由器或网关设备：转发不同网络间的数据包。</span><br><span class="line">  - 防火墙：通过规则允许或拒绝特定IP地址或端口范围的数据包。</span><br></pre></td></tr></table></figure>

<h2 id="8-自定义链"><a href="#8-自定义链" class="headerlink" title="8. 自定义链"></a>8. 自定义链</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 除系统自带链外，iptables支持自定义链以便分组规则及重复调用。</span><br><span class="line">- 添加自定义链后，需将其作为系统链的target关联，才能生效。</span><br></pre></td></tr></table></figure>

<h2 id="9-firewalld"><a href="#9-firewalld" class="headerlink" title="9. firewalld"></a>9. firewalld</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- firewalld是用于管理netfilter的用户空间工具，支持iptables、ip6tables及ebtables。</span><br><span class="line">- 通过守护进程实现防火墙规则的动态配置与监控。</span><br><span class="line">- 内置多个Zone，每个Zone对应一套防火墙规则，支持自定义修改。</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="总结与要点"><a href="#总结与要点" class="headerlink" title="总结与要点"></a>总结与要点</h1><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- IDS与IPS：</span><br><span class="line">  - IDS主要用于监控与检测，不直接干预网络访问；</span><br><span class="line">  - IPS则在检测到异常时采取主动防御措施，确保网络安全。</span><br><span class="line"></span><br><span class="line">- 防火墙：</span><br><span class="line">  - 作为网络安全的第一道防线，防火墙通过多种技术和策略过滤网络流量，</span><br><span class="line">    分为主机防火墙和网络防火墙，硬件和软件实现各有优劣。</span><br><span class="line">  - 依据网络协议和实现细节进一步细分，以适应不同安全需求。</span><br><span class="line"></span><br><span class="line">- NAT技术：</span><br><span class="line">  - NAT在实现私有IP与公网IP转换中起关键作用，</span><br><span class="line">    包括SNAT、MASQUERADE、DNAT和REDIRECT等多种实现方式，各自适用于不同场景。</span><br><span class="line"></span><br><span class="line">- FORWARD链与自定义链：</span><br><span class="line">  - FORWARD链用于转发非本机目的地的数据包，是路由器和防火墙的重要组成部分。</span><br><span class="line">  - 自定义链有助于规则管理和复用，提升配置灵活性。</span><br><span class="line"></span><br><span class="line">- firewalld：</span><br><span class="line">  - 提供现代化、动态化的防火墙管理，简化规则配置和监控，适用于多种Linux发行版。</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://lx1me.github.io/2025/06/05/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/" data-id="cmbof5pge000bm0v6f576em1i" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-企业级监控系统 ZABBIX" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%20ZABBIX/" class="article-date">
  <time class="dt-published" datetime="2025-06-05T01:52:55.113Z" itemprop="datePublished">2025-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="企业级监控系统-ZABBIX"><a href="#企业级监控系统-ZABBIX" class="headerlink" title="企业级监控系统 ZABBIX"></a><strong>企业级监控系统</strong> <strong>ZABBIX</strong></h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">#### **数据流程**</span></span><br><span class="line"></span><br><span class="line">![<span class="type">image</span>-<span class="number">20250324192436841</span>](E:\biji\image\image<span class="literal">-20250324192436841</span>.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```powershell</span><br><span class="line"><span class="number">1</span> 数据采集：根据业务的特性，采取多种方式，进行对一些针对性的数据进行采集</span><br><span class="line"><span class="number">2</span> 数据整理：对上报后的数据源进行收集、清晰、整理</span><br><span class="line"><span class="number">3</span> 实时分析：对某些重要的核心的业务数据，进行实时分析。</span><br><span class="line"><span class="number">4</span> 离线分析：对普通的数据、非紧急的业务数据进行存储，后续进行响应的分析。</span><br><span class="line"><span class="number">5</span> 结果输出：将实时分析和离线分析后的数据结果展现出来，供决策参考。</span><br><span class="line"><span class="number">6</span> 问题决策：根据当前业务情况，人工或者自动方式对输出的结构进行分析，并判定下一步的行动(警告或修复)，同时将其决策记录保存下来，以便为后序决策提供依据。</span><br><span class="line">也就是说：采集、传输、存储、分析、警告这几部分是非常必要的。</span><br><span class="line">核心目标:</span><br><span class="line">监控的核心目标就是维持网站的可用性</span><br></pre></td></tr></table></figure>

<h4 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a><strong>监控方式</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">划分为基于Metrics（指标）监控、基于Logging（日志）、 基于Tracing（调用</span><br><span class="line">链）监控的监控。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="监控功能"><a href="#监控功能" class="headerlink" title="监控功能"></a>监控功能</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在需要的时刻，提前预警即将出问题,避免故障发生。</span><br><span class="line">实时监控系统和业务,当出问题之后，通过发出告警,提醒相关人员,快速可以找到问题的根源,从而及时处理问题。</span><br><span class="line">可以实现网站,应用或者服务器的故障自愈, 保证高可用性。</span><br><span class="line">以图形或易观察的方式呈现当前以及过往的状态,便于分析和预测系统发展趋势。</span><br></pre></td></tr></table></figure>

<h4 id="监控方法"><a href="#监控方法" class="headerlink" title="监控方法"></a>监控方法</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用率较高的有四种:</span><br><span class="line">软件层面：</span><br><span class="line"> agent: 专用的软件的一种应用机制。</span><br><span class="line"> ssh: 系统常见的一种应用通信机制，但是并非所有。</span><br><span class="line"> SNMP: 简单网络管理协议(Simple Network Management Protocol),是工作在各种网络设备中的</span><br><span class="line">一种机制。</span><br><span class="line">硬件层面：</span><br><span class="line"> IPMI: 智慧平台管理接口(Intelligent Platform Management Interface)是一种工业标准用</span><br><span class="line">于采集硬件设备的各种物理健康状态数据，如温度、电压、风扇工作状态、电源状态等。</span><br><span class="line"></span><br><span class="line">实现方法:</span><br><span class="line">主要有系统命令,开源软件,监控平台</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="开源软件"><a href="#开源软件" class="headerlink" title="开源软件"></a>开源软件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Cacti:</span><br><span class="line">Cacti是基于LAMP平台展现的网络流量监测及分析工具,通过SNMP技术或自定义脚本从目标设备/主机获取监控指标信息. 其次还可以进行数据存储，调用模板将数据存到数据库，使用rrdtool存储和更新数据，通过rrdtoo1绘制结果图形,最后进行数据展现，通过web方式将监控结果呈现出来，常用于在数据中心监控网络设备,比如交换机和路由器。</span><br><span class="line"> cacti是很老的一款监控工具，其实说它是一款流量监控工具更合适，对流量监控比较精准，但缺点很多，出图不好看，不支持分布式，也没有告警功能，所以当前使用的用户越来越少。缺点:告警不及时。</span><br><span class="line"></span><br><span class="line">Nagios:</span><br><span class="line">  Nagios是一款开源的免费监控工具，可以有效地监控Windows、Linux和Unix的主机状态，交换机路由器等网络设置，打印机等。在系统或服务状态异常时发出邮件或短信报警第一时间通知网站运维人员，在状态恢复后发出正常的邮件或短信通知。</span><br><span class="line">  nagios主要的特征是监控告警，最强大的就是告警功能，可支持多种告警方式，但缺点是没有强大的数据收集机制，并且数据出图也很简陋，当监控的主机越来越多时，添加主机也非常麻烦，配置文件都是基于文本配置的，不支持web方式管理和配置，这样很容易出错，不易维护。</span><br><span class="line">  分层告警机制及自定义监控相对薄弱。监控主机数量有限，承载能力较低</span><br><span class="line"></span><br><span class="line"><span class="built_in">open-falcon</span>:</span><br><span class="line"><span class="built_in">open-falcon</span>(猎鹰)是一款用golang和python写的监控系统，由小米公司启动了这个项目相对zabbix在性能、扩展性、和用户的使用效率方面，都有较大优势。</span><br><span class="line"> 发布时间较短，不支持很多基础的服务监控插件,如Tomcat、 apache等。</span><br><span class="line"> 功能不完善,更新较缓慢，无专门运维支撑，社区运营有欠缺 <span class="literal">--</span> 目前很长时间不维护了。</span><br><span class="line"></span><br><span class="line">夜莺:</span><br><span class="line"> 夜莺（Nightingale）是滴滴基础平台联合滴滴云研发和开源的企业级监控解决方案。旨在满足云原生时代企业级的监控需求。Nightingale 在<span class="built_in">Open-Falcon</span> 的基础上，结合滴滴的最佳实践，在性能、可维护性、易用性方面做了大量的改进。</span><br><span class="line"> Nightingale 在产品完成度、系统高可用、以及用户体验方面，达到了企业级的要求，可满足不同规模用户的场景，小到几台机器，大到数十万都可以完美支撑。兼顾云原生和裸金属，支持应用监控和系统监控，插件机制灵活，插件丰富完善，具有高度的灵活性和可扩展性。</span><br><span class="line"> Nightingale 作为集团统一的监控解决方案，支撑了滴滴内部数十亿监控指标，覆盖了从系统、容器、到应用等各层面的监控需求，周活跃用户数千。五年磨一剑，取之开源，回馈开源夜莺监控的核心开发团队，也是<span class="built_in">Open-Falcon</span>项目原核心研发人员。当前社区比较活跃,升级较频繁</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Zabbix"><a href="#Zabbix" class="headerlink" title="Zabbix"></a>Zabbix</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>








      
    </div>
    <footer class="article-footer">
      <a data-url="https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%20ZABBIX/" data-id="cmbof5pgc0006m0v65g3j73ho" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-企业级容器技术 Docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%20Docker/" class="article-date">
  <time class="dt-published" datetime="2025-06-05T01:52:55.113Z" itemprop="datePublished">2025-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="企业级容器技术-Docker"><a href="#企业级容器技术-Docker" class="headerlink" title="企业级容器技术 Docker"></a>企业级容器技术 Docker</h1><h4 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker 相比虚拟机的交付速度更快，资源消耗更低，Docker 采用客户端/服务端架构，使用远程API来管理和创建容器，其可以轻松的创建一个轻量级的、可移植的、自给自足的容器，docker 的三大理念是build(构建)、ship(运输)、 run(运行)，Docker遵从apache <span class="number">2.0</span>协议，并通过（namespace及cgroup等）来提供容器的资源隔离与安全保障等，所以Docke容器在运行时不需要类似虚拟机（空运行的虚拟机占用物理机<span class="number">6</span><span class="literal">-8</span>%性能）的额外资源开销，因此可以大幅提高资源利用率,总而言之Docker是一种用了新颖方式实现的轻量级虚拟机.类似于VM但是在原理和应用上和VM的差别还是很大的，并且docker的专业叫法是应用容器(Application Container)。</span><br></pre></td></tr></table></figure>

<h4 id="Docker-的主要目标"><a href="#Docker-的主要目标" class="headerlink" title="Docker 的主要目标"></a>Docker 的主要目标</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Build, Ship and Run Any App, Anywhere，即通过对应用组件的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）等生命周期的管理，达到应用组件级别的“一次封装，到处运行”。这里的应用组件，既可以是一个Web应用，也可以是一套数据库服务，甚至是一个操作系统。将应用运行在Docker 容器上，可以实现跨平台，跨服务器，只需一次配置准备好相关的应用环境，即可实现到处运行，保证研发和生产环境的一致性，解决了应用和运行环境的兼容性问题，从而极大提升了部署效率，减少故障的可能性</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250408140309188.png" alt="image-20250408140309188"></p>
<h4 id="使用Docker-容器化封装应用程序的意义"><a href="#使用Docker-容器化封装应用程序的意义" class="headerlink" title="使用Docker 容器化封装应用程序的意义"></a>使用Docker 容器化封装应用程序的意义</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">统一基础设施环境<span class="literal">-docker</span>环境</span><br><span class="line">  硬件的组成配置</span><br><span class="line">  操作系统的版本</span><br><span class="line">  运行时环境的异构</span><br><span class="line">统一程序打包（装箱）方式<span class="literal">-docker</span>镜像</span><br><span class="line">  java程序</span><br><span class="line">  python程序</span><br><span class="line">  nodejs程序</span><br><span class="line">统一程序部署（运行）方式<span class="literal">-docker</span>容器</span><br><span class="line">  java <span class="literal">-jar</span>...→ docker run...</span><br><span class="line">  python manage.py runserver... → docker run...</span><br><span class="line">  npm run dev ... → docker run...</span><br></pre></td></tr></table></figure>

<h4 id="Docker-和虚拟机，物理主机"><a href="#Docker-和虚拟机，物理主机" class="headerlink" title="Docker 和虚拟机，物理主机"></a>Docker 和虚拟机，物理主机</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">![<span class="type">image</span>-<span class="number">20250408140442265</span>](E:\biji\image\image<span class="literal">-20250408140442265</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 容器和虚拟机技术比较</span></span><br><span class="line"></span><br><span class="line">```powershell</span><br><span class="line">传统虚拟机是虚拟出一个主机硬件,并且运行一个完整的操作系统 ,然后在这个系统上安装和运行软件</span><br><span class="line">容器内的应用直接运行在宿主机的内核之上,容器并没有自己的内核,也不需要虚拟硬件,相当轻量化</span><br><span class="line">每个容器间是互相隔离,每个容器内都有一个属于自己的独立文件系统,独立的进程空间,网络空间,用</span><br><span class="line">户空间等,所以在同一个宿主机上的多个容器之间彼此不会相互影响</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250408140931358.png" alt="image-20250408140931358"></p>
<h4 id="容器和虚拟机比较"><a href="#容器和虚拟机比较" class="headerlink" title="容器和虚拟机比较"></a>容器和虚拟机比较</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">资源利用率更高: 开销更小,不需要启动单独的虚拟机OS内核占用硬件资源,可以将服务器性能压榨至极致.虚拟机一般会有<span class="number">5</span><span class="literal">-20</span>%的损耗,容器运行基本无损耗,所以生产中一台物理机只能运行数十个虚拟机，但是一般可以运行数百个容器</span><br><span class="line">启动速度更快: 可以在数秒内完成启动</span><br><span class="line">占用空间更小: 容器一般占用的磁盘空间以MB为单位,而虚拟机以GB</span><br><span class="line">集成性更好: 和 CI/<span class="built_in">CD</span>（持续集成/持续部署）相关技术结合性更好，实现打包镜像发布测试可以一键运行,做到自动化并快速的部署管理,实现高效的开发生命周期</span><br></pre></td></tr></table></figure>

<h4 id="Docker-的组成"><a href="#Docker-的组成" class="headerlink" title="Docker 的组成"></a>Docker 的组成</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Docker 主机(Host): 一个物理机或虚拟机，用于运行Docker服务进程和容器，也称为宿主机，node节点</span><br><span class="line">Docker 服务端(Server): Docker守护进程，运行docker容器 docker engine</span><br><span class="line">Docker 客户端(Client): 客户端使用 docker 命令或其他工具调用docker API</span><br><span class="line">Docker 镜像(Images): 镜像可以理解为创建实例使用的模板,本质上就是一些程序文件的集合</span><br><span class="line">Docker 仓库(Registry): 保存镜像的仓库，官方仓库: https://hub.docker.com/，可以搭建私有仓库harbor</span><br><span class="line">Docker 容器(Container): 容器是从镜像生成对外提供服务的一个或一组服务,其本质就是将镜像中的程序启动后生成的进程</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250408141033462.png" alt="image-20250408141033462"></p>
<h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一个宿主机运行了N个容器，多个容器共用一个 OS，必然带来的以下问题:</span><br><span class="line">怎么样保证每个容器都有不同的文件系统并且能互不影响？</span><br><span class="line">一个docker主进程内的各个容器都是其子进程，那么如果实现同一个主进程下不同类型的子进程？</span><br><span class="line">各个容器子进程间能相互通信(内存数据)吗？</span><br><span class="line">每个容器怎么解决IP及端口分配的问题？</span><br><span class="line">多个容器的主机名能一样吗？</span><br><span class="line">每个容器都要不要有root用户？怎么解决账户重名问题？</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250408141141555.png" alt="image-20250408141141555"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace是Linux系统的底层概念，在LInux内核层实现，即有一些不同类型的命名空间被部署在内核，各个docker容器运行在同一个docker主进程并且共用同一个宿主机系统内核，各docker容器运行在宿主机的用户空间，每个容器都要有类似于虚拟机一样的相互隔离的运行空间，但是容器技术是在一个进程内实现运行指定服务的运行环境，并且还可以保护宿主机内核不受其他进程的干扰和影响，如文件系统空间、网络空间、进程空间等，目前主要通过以下技术实现容器运行空间的相互隔离:</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>隔离类型</th>
<th>功能</th>
<th>系统调用参数</th>
<th>内核版本</th>
</tr>
</thead>
<tbody><tr>
<td>MNT Namespace(mount)</td>
<td>提供磁盘挂载点和文件系统的隔离能力</td>
<td>CLONE_NEWNS</td>
<td>2.4.19</td>
</tr>
<tr>
<td>PID Namespace(Process Identification)</td>
<td>提供进程隔离能力</td>
<td>CLONE_NEWPID</td>
<td>2.6.24</td>
</tr>
<tr>
<td>IPC Namespace(Inter - Process Communication)</td>
<td>提供进程间通信的隔离能力，包括信号量、消息队列和共享内存</td>
<td>CLONE_NEWIPC</td>
<td>2.6.19</td>
</tr>
<tr>
<td>Net Namespace(network)</td>
<td>提供网络隔离能力，包括网络设备、网络栈、端口等</td>
<td>CLONE_NEWNET</td>
<td>2.6.29</td>
</tr>
<tr>
<td>UTS Namespace(UNIX Timesharing System)</td>
<td>提供内核、主机名和域名隔离能力</td>
<td>CLONE_NEWUTS</td>
<td>2.6.19</td>
</tr>
<tr>
<td>User Namespace(user)</td>
<td>提供用户隔离能力，包括用户和组</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Namespace-类型概述"><a href="#Namespace-类型概述" class="headerlink" title="Namespace 类型概述"></a>Namespace 类型概述</h3><ul>
<li>Pid namespace<ul>
<li>不同用户的进程通过 Pid namespace 隔离开，不同 namespace 中可存在相同 Pid。</li>
<li>借助 Pid namespace，各 namespace 中的 Pid 能够相互隔离。</li>
</ul>
</li>
<li>net namespace<ul>
<li>网络隔离由 net namespace 实现。</li>
<li>每个 net namespace 具备独立的 network devices、IP addresses、IP routing tables 以及 &#x2F;proc&#x2F;net 目录。</li>
<li>Docker 默认采用 veth 的方式，将 container 中的虚拟网卡与 host 上的 docker bridge（docker0）连接起来。</li>
</ul>
</li>
<li>ipc namespace<ul>
<li>Container 中进程交互采用 Linux 常见的进程间交互方法（IPC），如信号量、消息队列和共享内存。</li>
<li>container 的进程间交互实质是 host 上具有相同 Pid namespace 中的进程间交互，所以在 IPC 资源申请时需加入 namespace 信息，每个 IPC 资源有唯一的 32 位 ID。</li>
</ul>
</li>
<li>mnt namespace<ul>
<li>mnt namespace 允许不同 namespace 的进程看到不同的文件结构，从而隔离各 namespace 中进程所看到的文件目录。</li>
</ul>
</li>
<li>uts namespace<ul>
<li>UTS（“UNIX Time - sharing System”）namespace 使每个 container 拥有独立的 hostname 和 domain name，使其在网络上可被视为独立节点，而非 Host 上的一个进程。</li>
</ul>
</li>
<li>user namespace<ul>
<li>每个 container 能有不同的 user 和 group id，可在 container 内部使用 container 内部的用户执行程序，而非 Host 上的用户。</li>
</ul>
</li>
</ul>
<h4 id="容器管理工具"><a href="#容器管理工具" class="headerlink" title="容器管理工具"></a>容器管理工具</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有了以上的namespace、cgroups就具备了基础的容器运行环境，但是还需要有相应的容器创建与删除的管理工具、以及怎么样把容器运行起来、容器数据怎么处理、怎么进行启动与关闭等问题需要解决，于是容器管理技术出现了。目前主要是使用docker，containerd等，早期使用 LXC</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250408142745319.png" alt="image-20250408142745319"></p>
<h4 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">快速部署: 短时间内可以部署成百上千个应用，更快速交付到线上</span><br><span class="line">高效虚拟化: 不需要额外hypervisor支持，基于linux内核实现应用虚拟化，相比虚拟机大幅提高性能和效率</span><br><span class="line">节省开支: 提高服务器利用率，降低IT支出</span><br><span class="line">简化配置: 将运行环境打包保存至容器，使用时直接启动即可</span><br><span class="line">环境统一: 将开发，测试，生产的应用运行环境进行标准化和统一，减少环境不一样带来的各种问题</span><br><span class="line">快速迁移和扩展: 可实现跨平台运行在物理机、虚拟机、公有云等环境，良好的兼容性可以方便将应用从A宿主机迁移到B宿主机，甚至是A平台迁移到B平台</span><br><span class="line">更好的实现面向服务的架构,推荐一个容器只运行一个应用,实现分布的应用模型,可以方便的进行横向扩展,符合开发中高内聚,低耦合的要求,减少不同服务之间的相互影响</span><br></pre></td></tr></table></figure>

<h4 id="Docker-的缺点"><a href="#Docker-的缺点" class="headerlink" title="Docker 的缺点"></a>Docker 的缺点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多个容器共用宿主机的内核，各应用之间的隔离不如虚拟机彻底</span><br><span class="line">由于和宿主机之间的进程也是隔离的,需要进入容器查看和调试容器内进程等资源,变得比较困难和繁琐</span><br><span class="line">如果容器内进程需要查看和调试,需要在每个容器内都需要安装相应的工具,这也造成存储空间的重复浪费</span><br></pre></td></tr></table></figure>

<h4 id="镜像仓库-Registry"><a href="#镜像仓库-Registry" class="headerlink" title="镜像仓库 Registry"></a>镜像仓库 Registry</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">统一保存镜像而且是多个不同镜像版本的地方，叫做镜像仓库</span><br><span class="line">  Docker hub: docker官方的公共仓库，已经保存了大量的常用镜像，可以方便大家直接使用</span><br><span class="line">  阿里云，网易等第三方镜像的公共仓库</span><br><span class="line">  Image registry: docker 官方提供的私有仓库部署工具，无web管理界面，目前使用较少</span><br><span class="line">  Harbor: vmware 提供的自带web界面自带认证功能的镜像私有仓库，目前有很多公司使用</span><br></pre></td></tr></table></figure>

<h4 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">官方文档 : https://docs.docker.com/engine/install/</span><br><span class="line">阿里云文档: https://developer.aliyun.com/mirror/docker<span class="literal">-ce</span>?spm=a2c6<span class="built_in">h</span>.<span class="number">13651102.0</span>.<span class="number">0.3</span>e221b11guHCWE</span><br><span class="line">安装方法</span><br><span class="line">内置仓库</span><br><span class="line">官方仓库（国内镜像）</span><br><span class="line">二进制安装（离线）</span><br><span class="line">官方脚本</span><br><span class="line">Ubuntu 包安装和删除Docker</span><br><span class="line">官方文档: https://docs.docker.com/install/linux/docker<span class="literal">-ce</span>/ubuntu/</span><br></pre></td></tr></table></figure>

<h5 id="配置daemon-json-优化docker"><a href="#配置daemon-json-优化docker" class="headerlink" title="配置daemon.json   优化docker"></a>配置daemon.json   优化docker</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https://si7y70hh.mirror.aliyuncs.com&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;exec-opts&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;native.cgroupdriver=systemd&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;data-root&quot;</span>: <span class="string">&quot;/data/docker&quot;</span>,</span><br><span class="line">  <span class="string">&quot;max-concurrent-downloads&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">&quot;max-concurrent-uploads&quot;</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="string">&quot;log-opts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;max-size&quot;</span>: <span class="string">&quot;300m&quot;</span>,</span><br><span class="line">    <span class="string">&quot;max-file&quot;</span>: <span class="string">&quot;2&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;dns&quot;</span>: [<span class="string">&quot;8.8.8.8&quot;</span>, <span class="string">&quot;8.8.4.4&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo systemctl daemon<span class="literal">-reexec</span></span><br><span class="line">sudo systemctl daemon<span class="literal">-reload</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h5 id="配置http-proxy-conf"><a href="#配置http-proxy-conf" class="headerlink" title="配置http-proxy.conf"></a>配置http-proxy.conf</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="literal">-p</span> /etc/systemd/system/docker.service.d</span><br><span class="line">vim /etc/systemd/system/docker.service.d/http<span class="literal">-proxy</span>.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[<span class="type">Service</span>]</span><br><span class="line">Environment=<span class="string">&quot;HTTP_PROXY=http://172.22.101.168:7890&quot;</span></span><br><span class="line">Environment=<span class="string">&quot;HTTPS_PROXY=http://172.22.101.168:7890&quot;</span></span><br><span class="line">Environment=<span class="string">&quot;NO_PROXY=localhost,127.0.0.1,::1&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo systemctl daemon<span class="literal">-reexec</span></span><br><span class="line">sudo systemctl daemon<span class="literal">-reload</span></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="容器镜像管理"><a href="#容器镜像管理" class="headerlink" title="容器镜像管理"></a>容器镜像管理</h4><h5 id="镜像结构和原理"><a href="#镜像结构和原理" class="headerlink" title="镜像结构和原理"></a>镜像结构和原理</h5><p><img src="E:\biji\image\image-20250410103914849.png" alt="image-20250410103914849"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 搜索镜像</span></span><br><span class="line"></span><br><span class="line">```powershell</span><br><span class="line">http://hub.docker.com</span><br><span class="line">http://dockerhub.com</span><br><span class="line">https://hub<span class="literal">-stage</span>.docker.com/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行docker search命令进行搜索</span><br><span class="line">docker search centos</span><br></pre></td></tr></table></figure>

<h4 id="Alpine"><a href="#Alpine" class="headerlink" title="Alpine"></a>Alpine</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Alpine 操作系统是一个面向安全的轻型 Linux 发行版。</span><br><span class="line">alpine 管理软件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#更新源</span></span><br><span class="line">apk update = apt update</span><br><span class="line"><span class="comment">#安装软件</span></span><br><span class="line">apk add vim = apt install vim</span><br><span class="line"><span class="comment">#删除软件</span></span><br><span class="line">apk <span class="built_in">del</span> openssh openntp vim = apt remove openssh</span><br><span class="line"><span class="comment">#安装常见软件</span></span><br><span class="line">apk update &amp;&amp; apk <span class="literal">--no-cache</span> add bash <span class="built_in">curl</span> telnet <span class="built_in">wget</span> net<span class="literal">-tools</span> pstree zip</span><br><span class="line">unzip</span><br><span class="line"><span class="comment">#安装常用编译工具</span></span><br><span class="line">apk update &amp;&amp; apk <span class="literal">--no-cache</span> add gcc make <span class="built_in">curl</span> zip unzip net<span class="literal">-tools</span> pstree <span class="built_in">wget</span></span><br><span class="line">libgcc libc<span class="literal">-dev</span> libcurl libc<span class="literal">-utils</span> pcre<span class="literal">-dev</span> zlib<span class="literal">-dev</span> libnfs pcre pcre2 libevent</span><br><span class="line">libevent<span class="literal">-dev</span> iproute2</span><br><span class="line"><span class="comment">#修改时区</span></span><br><span class="line">apk update &amp;&amp; apk <span class="literal">--no-cache</span> add tzdata &amp;&amp; ln <span class="literal">-s</span></span><br><span class="line">/usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;Asia/Shanghai&quot;</span> &gt;</span><br><span class="line">/etc/timezone</span><br></pre></td></tr></table></figure>

<h4 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker pull [<span class="type">OPTIONS</span>] NAME[:<span class="type">TAG</span>|@<span class="type">DIGEST</span>]</span><br><span class="line">Options:</span><br><span class="line"><span class="literal">-a</span>, <span class="literal">--all-tags</span> Download all tagged images <span class="keyword">in</span> the repository</span><br><span class="line"><span class="literal">--disable-content-trust</span> Skip image verification (default true)</span><br><span class="line"><span class="literal">--platform</span> string <span class="built_in">Set</span> platform <span class="keyword">if</span> server is multi<span class="literal">-platform</span> capable</span><br><span class="line"><span class="literal">-q</span>, <span class="literal">--quiet</span> Suppress verbose output</span><br><span class="line">NAME: 是镜像名,一般的形式 仓库服务器:端口/项目名称/镜像名称</span><br><span class="line">:TAG: 即版本号,如果不指定:TAG,则下载最新版镜像</span><br></pre></td></tr></table></figure>

<h4 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">docker images [<span class="type">OPTIONS</span>] [<span class="type">REPOSITORY</span>[:<span class="type">TAG</span>]]</span><br><span class="line">docker image <span class="built_in">ls</span> [<span class="type">OPTIONS</span>] [<span class="type">REPOSITORY</span>[:<span class="type">TAG</span>]]</span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">bogon</span> <span class="type">docker</span>]<span class="variable">$</span> docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY                                 TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">ubuntu                                     latest    <span class="number">602</span>eb6fb314b   <span class="number">40</span> hours ago    <span class="number">78.1</span>MB</span><br><span class="line">alpine                                     <span class="number">3.21</span>.<span class="number">3</span>    aded1e1a5b37   <span class="number">7</span> weeks ago     <span class="number">7.83</span>MB</span><br><span class="line">nginx                                      latest    <span class="number">4</span>cad75abc83d   <span class="number">2</span> months ago    <span class="number">192</span>MB</span><br><span class="line">hello<span class="literal">-world</span>                                latest    <span class="number">74</span>cc54e27dc4   <span class="number">2</span> months ago    <span class="number">10.1</span>kB</span><br><span class="line">redis                                      latest    <span class="number">65750</span>d044ac8   <span class="number">3</span> months ago    <span class="number">117</span>MB</span><br><span class="line">registry.k8s.io/ingress<span class="literal">-nginx</span>/controller   v1.<span class="number">7.1</span>    <span class="number">2</span>db0b57c8712   <span class="number">23</span> months ago   <span class="number">289</span>MB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行结果的显示信息说明:</span><br><span class="line">REPOSITORY                  <span class="comment">#镜像所属的仓库名称</span></span><br><span class="line">TAG                         <span class="comment">#镜像版本号（标识符），默认为latest</span></span><br><span class="line">IMAGE ID                    <span class="comment">#镜像唯一ID标识,如果ID相同,说明是同一个镜像有多个名称</span></span><br><span class="line">CREATED                     <span class="comment">#镜像在仓库中被创建时间</span></span><br><span class="line">VIRTUAL SIZE                <span class="comment">#镜像的大小</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker images <span class="literal">--format</span>命令用于指定在输出中显示映像信息的格式。格式字符串由多个占位符组成，每个占位符代表映像的特定属性。</span><br><span class="line"></span><br><span class="line"><span class="comment">#常用的格式占位符：</span></span><br><span class="line">&#123;&#123;.Repository&#125;&#125;：映像的仓库名称。</span><br><span class="line">&#123;&#123;.Tag&#125;&#125;：映像的标签。</span><br><span class="line">&#123;&#123;.ID&#125;&#125;：映像的ID。</span><br><span class="line">&#123;&#123;.Digest&#125;&#125;：映像的摘要值。</span><br><span class="line">&#123;&#123;.CreatedAt&#125;&#125;：映像的创建时间。</span><br><span class="line">&#123;&#123;.Size&#125;&#125;：映像的大小。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">docker images <span class="literal">--format</span> <span class="string">&quot;&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;\t&#123;&#123;.Size&#125;&#125;&quot;</span></span><br><span class="line">docker images <span class="literal">--format</span> <span class="string">&quot;&#123;&#123;.CreatedAt&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;&quot;</span> | <span class="built_in">sort</span> <span class="literal">-k</span> <span class="number">1</span> <span class="literal">-r</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="查看指定镜像的详细信息"><a href="#查看指定镜像的详细信息" class="headerlink" title="查看指定镜像的详细信息"></a>查看指定镜像的详细信息</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect redis</span><br></pre></td></tr></table></figure>

<h4 id="镜像导出"><a href="#镜像导出" class="headerlink" title="镜像导出"></a>镜像导出</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker save [<span class="type">OPTIONS</span>] IMAGE [<span class="type">IMAGE...</span>]</span><br><span class="line">选项:</span><br><span class="line"><span class="literal">-o</span>, <span class="literal">--output</span> string <span class="built_in">Write</span> to a file, instead of STDOUT</span><br><span class="line"><span class="comment">#说明:</span></span><br><span class="line">Docker save 使用IMAGE ID导出，在导入后的镜像没有REPOSITORY和TAG,显示为&lt;none&gt;</span><br><span class="line"></span><br><span class="line">常见用法:</span><br><span class="line"><span class="comment">#导出为tar格式</span></span><br><span class="line">docker save <span class="literal">-o</span> /path/file.tar IMAGE1 IMAGE2 ...</span><br><span class="line">docker save IMAGE1 IMAGE2 ... &gt; /path/file.tar</span><br><span class="line"><span class="comment">#导出为压缩格式</span></span><br><span class="line">docker save IMAGE1 IMAGE2 ... | gzip &gt; /path/file.tar.gz</span><br><span class="line"></span><br><span class="line">docker save nginx:<span class="number">1.27</span>.<span class="number">4</span> <span class="literal">-o</span> /<span class="keyword">data</span>/myimages.tar</span><br></pre></td></tr></table></figure>

<h4 id="镜像导入"><a href="#镜像导入" class="headerlink" title="镜像导入"></a>镜像导入</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">利用docker load命令可以将镜像导出的打包或压缩文件再导入</span><br><span class="line">注意：镜像导入只能支持单个镜像导入，不支持多个镜像导入</span><br><span class="line">docker load [<span class="type">OPTIONS</span>]</span><br><span class="line"><span class="comment">#选项</span></span><br><span class="line"><span class="literal">-i</span>, <span class="literal">--input</span> string Read from tar archive file, instead of STDIN</span><br><span class="line"><span class="literal">-q</span>, <span class="literal">--quiet</span> Suppress the load output</span><br><span class="line"></span><br><span class="line">常见用法:</span><br><span class="line">docker load <span class="literal">-i</span> /path/file.tar</span><br><span class="line">docker load &lt; /path/file.tar.gz</span><br><span class="line"></span><br><span class="line">docker load <span class="literal">-i</span> /<span class="keyword">data</span>/myimages.tar</span><br></pre></td></tr></table></figure>

<h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 命令可以删除本地镜像</span><br><span class="line">docker rmi [<span class="type">OPTIONS</span>] IMAGE [<span class="type">IMAGE...</span>]</span><br><span class="line">docker image <span class="built_in">rm</span> [<span class="type">OPTIONS</span>] IMAGE [<span class="type">IMAGE...</span>]</span><br><span class="line"><span class="comment">#选项:</span></span><br><span class="line"><span class="operator">-f</span>, <span class="literal">--force</span> Force removal of the image  强制删除</span><br><span class="line"><span class="literal">--no-prune</span> <span class="keyword">Do</span> not delete untagged parents</span><br></pre></td></tr></table></figure>

<h4 id="镜像打标签"><a href="#镜像打标签" class="headerlink" title="镜像打标签"></a>镜像打标签</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker tag 可以给镜像打标签，类似于起别名</span><br><span class="line">docker tag SOURCE_IMAGE[:<span class="type">TAG</span>] TARGET_IMAGE[:<span class="type">TAG</span>]</span><br><span class="line"><span class="comment">#TARGET_IMAGE[:TAG]格式一般形式</span></span><br><span class="line">仓库主机FQDN或IP[:端口]/项目名(或用户名)/image名字:版本</span><br><span class="line"></span><br><span class="line">docker tag redis redis:<span class="number">1.1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="容器操作基础命令"><a href="#容器操作基础命令" class="headerlink" title="容器操作基础命令"></a>容器操作基础命令</h3><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run 可以启动容器，进入到容器，并随机生成容器ID和名称</span><br><span class="line">docker run [选项] [镜像名] [<span class="type">shell</span>命令] [参数]</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span>  查看启动过容器</span><br></pre></td></tr></table></figure>

<h4 id="启动容器的流程"><a href="#启动容器的流程" class="headerlink" title="启动容器的流程"></a>启动容器的流程</h4><p><img src="E:\biji\image\image-20250410143651598.png" alt="image-20250410143651598"></p>
<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从容器内退出,并停止容器</span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line"></span><br><span class="line">从容器内退出,且容器不停止</span><br><span class="line">同时按三个键，ctrl+p+q</span><br></pre></td></tr></table></figure>

<h4 id="守护式-持续运行-容器"><a href="#守护式-持续运行-容器" class="headerlink" title="守护式(持续运行)容器"></a>守护式(持续运行)容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">能够长期运行</span><br><span class="line">无需交互式会话</span><br><span class="line">适合运行应用程序和服务</span><br><span class="line"></span><br><span class="line">docker run <span class="literal">-d</span> nginx</span><br><span class="line"></span><br><span class="line">docker run <span class="literal">-td</span> <span class="literal">--name</span> alpine5 alpine</span><br></pre></td></tr></table></figure>

<h4 id="开机自启动容器"><a href="#开机自启动容器" class="headerlink" title="开机自启动容器"></a>开机自启动容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">--restart</span>=always <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="literal">--restart</span>=always  自启动选项</span><br></pre></td></tr></table></figure>

<h4 id="–privileged-选项"><a href="#–privileged-选项" class="headerlink" title="–privileged 选项"></a>–privileged 选项</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用该参数，container内的root拥有真正的root权限。否则，container内的root只是外部的一个普通用户权限</span><br></pre></td></tr></table></figure>

<h3 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h3><h4 id="显示当前存在容器"><a href="#显示当前存在容器" class="headerlink" title="显示当前存在容器"></a>显示当前存在容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">ps</span> [<span class="type">OPTIONS</span>]</span><br><span class="line">docker container <span class="built_in">ls</span> [<span class="type">OPTIONS</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示运行的容器</span></span><br><span class="line">docker <span class="built_in">ps</span></span><br><span class="line"><span class="comment">#显示全部容器，包括退出状态的容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span></span><br><span class="line"><span class="comment">#只显示容器ID</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">-q</span></span><br><span class="line"><span class="comment">#显示容器大小</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">-s</span></span><br><span class="line"><span class="comment">#显示最新创建的容器(停止的容器也能显示)</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-l</span></span><br><span class="line"><span class="comment">#查看运行状态的容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="operator">-f</span> <span class="string">&#x27;status=running&#x27;</span></span><br><span class="line"><span class="comment">#查看退出状态的容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="operator">-f</span> <span class="string">&#x27;status=exited&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> 命令中，你可以使用不同的占位符来指定要在输出中显示的容器信息。</span><br><span class="line"><span class="comment">#以下是一些常用的占位符：</span></span><br><span class="line">&#123;&#123;.ID&#125;&#125;：容器的ID。</span><br><span class="line">&#123;&#123;.Image&#125;&#125;：容器使用的映像名称。</span><br><span class="line">&#123;&#123;.Command&#125;&#125;：容器的启动命令。</span><br><span class="line">&#123;&#123;.CreatedAt&#125;&#125;：容器的创建时间。</span><br><span class="line">&#123;&#123;.RunningFor&#125;&#125;：容器运行的时间。</span><br><span class="line">&#123;&#123;.Ports&#125;&#125;：容器的端口映射信息。</span><br><span class="line">&#123;&#123;.Status&#125;&#125;：容器的状态。</span><br><span class="line">&#123;&#123;.Size&#125;&#125;：容器的大小。</span><br><span class="line">&#123;&#123;.Names&#125;&#125;：容器的名称。</span><br><span class="line">&#123;&#123;.Label&#125;&#125;：容器的标签。</span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;&#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Status&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker top CONTAINER [<span class="type">ps</span> <span class="type">OPTIONS</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">docker top <span class="number">2</span>bf0af811f0</span><br></pre></td></tr></table></figure>

<h4 id="查看容器资源使用情况"><a href="#查看容器资源使用情况" class="headerlink" title="查看容器资源使用情况"></a>查看容器资源使用情况</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker stats [<span class="type">OPTIONS</span>] [<span class="type">CONTAINER...</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">docker stats <span class="number">2</span>bf0af811f0ab95bf0d54</span><br></pre></td></tr></table></figure>

<h4 id="查看容器的详细信息"><a href="#查看容器的详细信息" class="headerlink" title="查看容器的详细信息"></a>查看容器的详细信息</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker inspect [<span class="type">OPTIONS</span>] NAME|ID [<span class="type">NAME</span>|<span class="type">ID...</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line">docker inspect <span class="number">4</span>a0879b2e89b</span><br><span class="line"><span class="comment">#查看容器IP</span></span><br><span class="line">docker inspect <span class="literal">--format</span> <span class="string">&quot;&#123;&#123;.NetworkSettings.Networks.bridge.IPAddress&#125;&#125;&quot;</span> elasticsearch</span><br></pre></td></tr></table></figure>

<h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker logs 可以查看容器中运行的进程在控制台的标准输出和标准错误，一般对应是日志信息</span><br><span class="line">docker 日志是存放在宿主机的 /var/lib/docker/containers/&lt;container_id&gt;/&lt;container_id&gt;<span class="literal">-json</span>.log文件中</span><br><span class="line"></span><br><span class="line">docker logs [<span class="type">OPTIONS</span>] CONTAINER</span><br><span class="line"></span><br><span class="line">docker logs d5337c0d94c7f7316b</span><br><span class="line"><span class="comment">#显示时间</span></span><br><span class="line">docker logs <span class="literal">--tail</span> <span class="number">0</span> <span class="literal">-t</span> d5337c0d94c7f7316b</span><br><span class="line"><span class="comment">#持续跟踪</span></span><br><span class="line">docker logs <span class="operator">-f</span> d5337c0d94c7f7316b</span><br></pre></td></tr></table></figure>

<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> [<span class="type">OPTIONS</span>] CONTAINER [<span class="type">CONTAINER...</span>]</span><br><span class="line">docker container <span class="built_in">rm</span> [<span class="type">OPTIONS</span>] CONTAINER [<span class="type">CONTAINER...</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除所有容器</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> `docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">-q</span>`</span><br><span class="line"><span class="comment">#删除指定状态容器</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> `docker <span class="built_in">ps</span> <span class="literal">-q</span> <span class="operator">-f</span> status=running`</span><br><span class="line">docker <span class="built_in">rm</span> `docker <span class="built_in">ps</span> <span class="literal">-qf</span> status=exited`</span><br><span class="line"><span class="comment">#删除所有停止的容器</span></span><br><span class="line">docker <span class="built_in">rm</span> `docker <span class="built_in">ps</span> <span class="literal">-qf</span> status=exited`</span><br></pre></td></tr></table></figure>

<h4 id="容器的启动和停止"><a href="#容器的启动和停止" class="headerlink" title="容器的启动和停止"></a>容器的启动和停止</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">start</span>|stop|restart|pause|unpause 容器ID</span><br><span class="line"></span><br><span class="line">批量正常启动或关闭所有容器</span><br><span class="line">docker <span class="built_in">start</span> <span class="variable">$</span>(docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">-q</span>)</span><br><span class="line">docker stop <span class="variable">$</span>(docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">-q</span>)</span><br></pre></td></tr></table></figure>

<h4 id="给正在容器发信号"><a href="#给正在容器发信号" class="headerlink" title="给正在容器发信号"></a>给正在容器发信号</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> 可以给容器发信号,默认号SIGKILL,即<span class="number">9</span>信号</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">kill</span> [<span class="type">OPTIONS</span>] CONTAINER [<span class="type">CONTAINER...</span>]</span><br><span class="line"><span class="comment">#选项:</span></span><br><span class="line"><span class="literal">-s</span>, <span class="literal">--signal</span> string Signal to send to the container (default <span class="string">&quot;KILL&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#强制关闭所有运行中的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> `docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">-q</span>`</span><br></pre></td></tr></table></figure>

<h4 id="进入正在运行的容器"><a href="#进入正在运行的容器" class="headerlink" title="进入正在运行的容器"></a>进入正在运行的容器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">容器只有正在运行状态时，才能进入</span><br><span class="line">docker exec [<span class="type">OPTIONS</span>] CONTAINER COMMAND [<span class="type">ARG...</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#常见用法</span></span><br><span class="line">docker exec <span class="literal">-it</span> 容器ID sh|bash</span><br><span class="line"></span><br><span class="line">docker exec <span class="number">544</span>d32be9707 <span class="built_in">ls</span></span><br><span class="line">docker exec <span class="literal">-it</span> <span class="number">544</span>d32be9707 bas</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="暴露所有容器端口"><a href="#暴露所有容器端口" class="headerlink" title="暴露所有容器端口"></a>暴露所有容器端口</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">容器启动后,默认处于预定义的NAT网络中,所以外部网络的主机无法直接访问容器中网络服务</span><br><span class="line">docker run <span class="literal">-P</span> 可以将事先容器预定义的所有端口映射宿主机的网卡的随机端口，默认从<span class="number">32768</span>开始</span><br><span class="line">使用随机端口 时,当停止容器后再启动可能会导致端口发生变化</span><br><span class="line"></span><br><span class="line"><span class="literal">-P</span> , <span class="literal">--publish-all</span>= true | false默认为false</span><br><span class="line"><span class="comment">#示例:</span></span><br><span class="line">docker run <span class="literal">-P</span> docker.io/nginx <span class="comment">#映射容器所有暴露端口至随机本地端口</span></span><br><span class="line"></span><br><span class="line">docker port CONTAINER [<span class="type">PRIVATE_PORT</span>[/<span class="type">PROTO</span>]]</span><br></pre></td></tr></table></figure>

<h4 id="查看-docker-run-启动参数命令"><a href="#查看-docker-run-启动参数命令" class="headerlink" title="查看 docker run 启动参数命令"></a>查看 docker run 启动参数命令</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">忘记之前启动一个容器的启动命令是什么，现在需要找回来 docker run 的运行参数，可以使用 runlike工具实现</span><br><span class="line"></span><br><span class="line">安装 runlike</span><br><span class="line"><span class="comment">#安装方式1: pip</span></span><br><span class="line">apt install <span class="literal">-y</span> python3<span class="literal">-pip</span></span><br><span class="line">pip3 install runlike</span><br><span class="line"><span class="comment">#安装方法2: by docker</span></span><br><span class="line">alias runlike=<span class="string">&quot;docker run --rm -v /var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line"><span class="string">assaflavie/runlike&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="基于CRIU实现容器热迁移"><a href="#基于CRIU实现容器热迁移" class="headerlink" title="基于CRIU实现容器热迁移"></a>基于CRIU实现容器热迁移</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker容器热迁移是指在不停止或中断容器的情况下，将正在运行的Docker容器从一个主机迁移到另一个主机的过程。此过程确保了服务的高可用性，特别适用于负载均衡和故障转移场景。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%20Docker/" data-id="cmbof5pgc0007m0v60j0034xi" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-企业级堡垒机 JumpServer" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%A0%A1%E5%9E%92%E6%9C%BA%20JumpServer/" class="article-date">
  <time class="dt-published" datetime="2025-06-05T01:52:55.108Z" itemprop="datePublished">2025-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="企业级堡垒机-JumpServer"><a href="#企业级堡垒机-JumpServer" class="headerlink" title="企业级堡垒机 JumpServer"></a>企业级堡垒机 JumpServer</h1><h4 id="跳板机和堡垒机"><a href="#跳板机和堡垒机" class="headerlink" title="跳板机和堡垒机"></a>跳板机和堡垒机</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">跳板机</span><br><span class="line">跳板机是一种用于单点登陆的主机应用系统。跳板机通常是由一台服务器通过特定的软件实现维护人员在维护过程中，首先要统一登录到这台服务器上，然后从这台服务器再登录到目标设备进行维护。</span><br><span class="line">但跳板机没有实现对运维人员操作行为的控制和审计，此外，跳板机存在严重的安全风险，一旦跳板机系统被攻入，则将后端资源风险完全暴露无遗。</span><br><span class="line">对于一些服务（如:telnet）可以通过跳板机来完成一定的控制访问，但是对于更多的服务（SSH、RDP等）来讲，就显得力不从心了。</span><br><span class="line"></span><br><span class="line">堡垒机</span><br><span class="line">由于跳板机的不足，更多的组织需要更先进、更好的安全技术,来实现运维操作管理和安全。</span><br><span class="line">堡垒机开始以独立的产品形态被广泛部署，有效降低了运维操作风险，使得运维操作管理变得更简单、更安全。</span><br><span class="line">堡垒机能满足角色管理与授权审批、信息资源访问控制、操作记录和审计、系统变更和维护控制要求，并生成一些统计报表配合管理规范，从而不断提升IT内控的合规性。</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250416191853145.png" alt="image-20250416191853145"></p>
<h4 id="JumpServer-生产应用场景"><a href="#JumpServer-生产应用场景" class="headerlink" title="JumpServer 生产应用场景"></a>JumpServer 生产应用场景</h4><p><img src="E:\biji\image\image-20250416191956975.png" alt="image-20250416191956975"></p>
<h4 id="JumpServer的优势和功能"><a href="#JumpServer的优势和功能" class="headerlink" title="JumpServer的优势和功能"></a>JumpServer的优势和功能</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">特色优势</span><br><span class="line">开源: 零门槛，线上快速获取和安装</span><br><span class="line">分布式: 轻松支持大规模并发访问；</span><br><span class="line">无插件: 仅需浏览器，极致的 Web Terminal 使用体验</span><br><span class="line">多云支持: 一套系统，同时管理不同云上面的资产</span><br><span class="line">云端存储: 审计录像云端存储，永不丢失</span><br><span class="line">多租户: 一套系统，多个子公司和部门同时使用</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h5><p><img src="E:\biji\image\image-20250416192121131.png" alt="image-20250416192121131"></p>
<p>堡垒机四个核心能力: 运维安全审计的4A规范</p>
<p><img src="E:\biji\image\image-20250416192617753.png" alt="image-20250416192617753"></p>
<table>
<thead>
<tr>
<th>身份认证 Authentication</th>
<th>登录认证</th>
<th>资源统一登录与认证</th>
</tr>
</thead>
<tbody><tr>
<td>LDAP&#x2F;AD 认证</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>RADIUS 认证</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>OpenID 认证（实现单点登录）</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>CAS 认证（实现单点登录）</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>MFA 认证</td>
<td>MFA 二次认证（Google Authenticator）</td>
<td>-</td>
</tr>
<tr>
<td>RADIUS 二次认证</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>登录复核（X-PACK）</td>
<td>用户登录行为受管理员的监管与控制</td>
<td>-</td>
</tr>
<tr>
<td><strong>账号管理 Account</strong></td>
<td>集中账号</td>
<td>管理用户管理</td>
</tr>
<tr>
<td>系统用户管理</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>统一密码</td>
<td>资产密码托管</td>
<td>-</td>
</tr>
<tr>
<td>自动生成密码</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>自动推送密码</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>密码过期设置</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>批量改密（X-PACK）</td>
<td>定期批量改密</td>
<td>-</td>
</tr>
<tr>
<td>多种密码策略</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>多云纳管（X-PACK）</td>
<td>对私有云、公有云资产自动统一纳管</td>
<td>-</td>
</tr>
<tr>
<td>收集用户（X-PACK）</td>
<td>自定义任务定期收集主机用户</td>
<td>-</td>
</tr>
<tr>
<td>密码匣子（X-PACK）</td>
<td>统一对资产主机的用户密码进行查看、更新、测试操作</td>
<td>-</td>
</tr>
<tr>
<td><strong>授权控制 Authorization</strong></td>
<td>多维授权</td>
<td>对用户、用户组、资产、资产节点、应用以及系统用户进行授权</td>
</tr>
<tr>
<td>资产授权</td>
<td>资产以树状结构进行展示</td>
<td>-</td>
</tr>
<tr>
<td>资产和节点均可灵活授权</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>节点内资产自动继承授权</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>子节点自动继承父节点授权</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>应用授权</td>
<td>实现更细粒度的应用级授权</td>
<td>-</td>
</tr>
<tr>
<td>MySQL 数据库应用、RemoteApp 远程应用（X-PACK）</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>动作授权</td>
<td>实现对授权资产的文件上传、下载以及连接动作的控制</td>
<td>-</td>
</tr>
<tr>
<td>时间授权</td>
<td>实现对授权资源使用时间段的限制</td>
<td>-</td>
</tr>
<tr>
<td>特权指令</td>
<td>实现对特权指令的使用（支持黑白名单）</td>
<td>-</td>
</tr>
<tr>
<td>命令过滤</td>
<td>实现对授权系统用户所执行的命令进行控制</td>
<td>-</td>
</tr>
<tr>
<td>文件传输</td>
<td>SFTP 文件上传 &#x2F; 下载</td>
<td>-</td>
</tr>
<tr>
<td>文件管理</td>
<td>实现 Web SFTP 文件管理</td>
<td>-</td>
</tr>
<tr>
<td>工单管理（X-PACK）</td>
<td>支持对用户登录请求行为进行控制</td>
<td>-</td>
</tr>
<tr>
<td>组织管理（X-PACK）</td>
<td>实现多租户管理与权限隔离</td>
<td>-</td>
</tr>
<tr>
<td><strong>安全审计 Audit</strong></td>
<td>操作审计</td>
<td>用户操作行为审计</td>
</tr>
<tr>
<td>会话审计</td>
<td>在线会话内容审计</td>
<td>-</td>
</tr>
<tr>
<td>历史会话内容审计</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>录像审计</td>
<td>支持对 Linux、Windows 等资产操作的录像进行回放审计</td>
<td>-</td>
</tr>
<tr>
<td>支持对 RemoteApp（X-PACK）、MySQL 等应用操作的录像进行回放审计</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>指令审计</td>
<td>支持对资产和应用等操作的命令进行审计</td>
<td>-</td>
</tr>
<tr>
<td>文件传输</td>
<td>可对文件的上传、下载记录进行审计</td>
<td>-</td>
</tr>
</tbody></table>
<h4 id="JumpServer-组成"><a href="#JumpServer-组成" class="headerlink" title="JumpServer 组成"></a>JumpServer 组成</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Core 组件是 JumpServer 的核心组件，其他组件依赖此组件启动。</span><br><span class="line">Koko 是服务于类 Unix 资产平台的组件，通过 SSH、Telnet 协议提供字符型连接。</span><br><span class="line">Lion 是服务于 Windows 资产平台的组件，用于 Web 端访问 Windows 资产。</span><br><span class="line">XRDP 是服务于 RDP 协议组件，该组件主要功能是通过 JumpServer Client 方式访问 windows2000、XP 等系统的资产。</span><br><span class="line">Razor 是服务于 RDP 协议组件，JumpServer Client 默认使用 Razor 组件访问 Windows 资产。</span><br><span class="line">Magnus 是服务于数据库的组件，用于通过客户端代理访问数据库资产。</span><br><span class="line">Kael 是服务于 GPT 资产平台的组件，用于纳管 ChatGPT 资产。</span><br><span class="line">Chen 是服务于数据库的组件，用于通过 Web GUI 方式访问数据库资产。</span><br><span class="line">Celery 是处理异步任务的组件，用于执行 JumpServer 相关的自动化任务。</span><br><span class="line">Video 是专门处理 Razor 组件和 Lion 组件产生录像的格式转换工作，将产生的会话录像转化为MP4 格式。</span><br></pre></td></tr></table></figure>

<h4 id="JumpServer-安装"><a href="#JumpServer-安装" class="headerlink" title="JumpServer 安装"></a>JumpServer 安装</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Mysql</span><br><span class="line"></span><br><span class="line">docker run <span class="literal">--name</span> mysql <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123456</span> <span class="literal">-e</span> MYSQL_DATABASE=jumpserver <span class="literal">-e</span> MYSQL_USER=jumpserver <span class="literal">-e</span> MYSQL_PASSWORD=<span class="number">123456</span> <span class="literal">-d</span> <span class="literal">-v</span> ./mysqld.cnf:/etc/mysql/conf.d/mysqld.cnf <span class="literal">--restart</span> always <span class="literal">--network</span> jumpserver<span class="literal">-net</span> registry.cn<span class="literal">-beijing</span>.aliyuncs.com/wangxiaochun/mysql:<span class="number">8.0</span>.<span class="number">29</span><span class="literal">-oracle</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Redis</span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> redis <span class="literal">--restart</span> always <span class="literal">--network</span> jumpserver<span class="literal">-net</span> registry.cn<span class="literal">-beijing</span>.aliyuncs.com/wangxiaochun/redis:<span class="number">7.2</span>.<span class="number">5</span> redis<span class="literal">-server</span> <span class="literal">--requirepass</span> <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Jumpserver</span><br><span class="line">docker run <span class="literal">--name</span> jms_all <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--network</span> jumpserver<span class="literal">-net</span> \</span><br><span class="line">  <span class="literal">--restart</span> always \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">2222</span>:<span class="number">2222</span> \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">30000</span><span class="literal">-30100</span>:<span class="number">30000</span><span class="literal">-30100</span> \</span><br><span class="line">  <span class="literal">-e</span> SECRET_KEY=gXqxW5aIdLs3DfLAjDDIyCb8IqD2bEtnYkGrPrdEDk2ETo9mxG \</span><br><span class="line">  <span class="literal">-e</span> BOOTSTRAP_TOKEN=SjjdI4O1rmNqNpodd7qnazr5lKN9oR \</span><br><span class="line">  <span class="literal">-e</span> LOG_LEVEL=ERROR \</span><br><span class="line">  <span class="literal">-e</span> DB_ENGINE=mysql \</span><br><span class="line">  <span class="literal">-e</span> DB_HOST=mysql \</span><br><span class="line">  <span class="literal">-e</span> DB_PORT=<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> DB_USER=jumpserver \</span><br><span class="line">  <span class="literal">-e</span> DB_PASSWORD=<span class="number">123456</span> \</span><br><span class="line">  <span class="literal">-e</span> DB_NAME=jumpserver \</span><br><span class="line">  <span class="literal">-e</span> REDIS_HOST=redis \</span><br><span class="line">  <span class="literal">-e</span> REDIS_PORT=<span class="number">6379</span> \</span><br><span class="line">  <span class="literal">-e</span> REDIS_PASSWORD=<span class="number">123456</span> \</span><br><span class="line">  <span class="literal">--privileged</span>=true \</span><br><span class="line">  <span class="literal">-v</span> /opt/jumpserver/core/<span class="keyword">data</span>:/opt/jumpserver/<span class="keyword">data</span> \</span><br><span class="line">  <span class="literal">-v</span> /opt/jumpserver/koko/<span class="keyword">data</span>:/opt/koko/<span class="keyword">data</span> \</span><br><span class="line">  <span class="literal">-v</span> /opt/jumpserver/lion/<span class="keyword">data</span>:/opt/lion/<span class="keyword">data</span> \</span><br><span class="line">  <span class="literal">-v</span> /opt/jumpserver/kael/<span class="keyword">data</span>:/opt/kael/<span class="keyword">data</span> \</span><br><span class="line">  <span class="literal">-v</span> /opt/jumpserver/chen/<span class="keyword">data</span>:/opt/chen/<span class="keyword">data</span> \</span><br><span class="line">  <span class="literal">-v</span> /opt/jumpserver/web/log:/var/log/nginx \</span><br><span class="line">  jumpserver/jms_all:v4.<span class="number">8.1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker volume create jsdata &amp;&gt; /dev/null</span><br><span class="line">docker volume create pgdata &amp;&gt; /dev/null</span><br><span class="line">docker run <span class="literal">--name</span> jms_all \</span><br><span class="line">     <span class="literal">-e</span> SECRET_KEY=NCcm4YWap8HBBb5TRCQLh1P1Wt4k8h1Ut9zRbcJBzWQvirdxSJ \</span><br><span class="line">     <span class="literal">-e</span> BOOTSTRAP_TOKEN=<span class="number">0</span>KlD4Jtp0ZHhjAspPtRssJ3VAOlqND \</span><br><span class="line">     <span class="literal">-v</span> jsdata:/opt/<span class="keyword">data</span> \</span><br><span class="line">     <span class="literal">-v</span> pgdata:/var/lib/postgresql \</span><br><span class="line">     <span class="literal">-p</span> <span class="number">2222</span>:<span class="number">2222</span> \</span><br><span class="line">     <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> jumpserver/jms_all:v4.<span class="number">8.1</span></span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    #image: mariadb:10.6</span><br><span class="line">    image: registry.cn-beijing.aliyuncs.com/wangxiaochun/mariadb:10.6</span><br><span class="line">    container_name: jms_mysql</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      MARIADB_ROOT_PASSWORD: $&#123;DB_PASSWORD:-123456&#125;</span><br><span class="line">      MARIADB_DATABASE: $&#123;DB_NAME:-jumpserver&#125;</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: &quot;mysql -h127.0.0.1 -uroot -p$$MARIADB_ROOT_PASSWORD -e &#x27;SHOW DATABASES;&#x27;&quot;</span><br><span class="line">      interval: 10s</span><br><span class="line">      timeout: 5s</span><br><span class="line">      retries: 3</span><br><span class="line">      start_period: 30s</span><br><span class="line">    volumes:</span><br><span class="line">      - $&#123;VOLUME_DIR:-./data&#125;/mariadb/data:/var/lib/mysql</span><br><span class="line">    networks:</span><br><span class="line">      - net</span><br><span class="line">  redis:</span><br><span class="line">    #image: redis:7.0</span><br><span class="line">    image: registry.cn-beijing.aliyuncs.com/wangxiaochun/redis:7.2.5</span><br><span class="line">    container_name: jms_redis</span><br><span class="line">    restart: always</span><br><span class="line">    command: redis-server --requirepass $&#123;REDIS_PASSWORD:-123456&#125;</span><br><span class="line">    environment:</span><br><span class="line">      REDIS_PASSWORD: $&#123;REDIS_PASSWORD:-123456&#125;</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: &quot;redis-cli -h 127.0.0.1 -a $$REDIS_PASSWORD info Replication&quot;</span><br><span class="line">      interval: 10s</span><br><span class="line">      timeout: 5s</span><br><span class="line">      retries: 3</span><br><span class="line">      start_period: 10s</span><br><span class="line">    volumes:</span><br><span class="line">      - $&#123;VOLUME_DIR:-./data&#125;/redis/data:/data</span><br><span class="line">    networks:</span><br><span class="line">      - net</span><br><span class="line">  jumpserver:</span><br><span class="line">    image: jumpserver/jms_all:v4.8.1</span><br><span class="line">    #image: registry.cn-beijing.aliyuncs.com/wangxiaochun/jms_all:v4.6.0</span><br><span class="line">    #build:</span><br><span class="line">    #  context: .</span><br><span class="line">    #  dockerfile: Dockerfile</span><br><span class="line">    container_name: jms_all</span><br><span class="line">    privileged: true</span><br><span class="line">    restart: always</span><br><span class="line">    environment:</span><br><span class="line">      SECRET_KEY: $&#123;SECRET_KEY:-LfFL6zB2mt4fMVq1D3hGKxxW0hopV1tlNicUHvsKJMQxsFPhBM&#125;</span><br><span class="line">      BOOTSTRAP_TOKEN: $&#123;BOOTSTRAP_TOKEN:-OVxLWFfTmXRd2f0e&#125;</span><br><span class="line">      LOG_LEVEL: $&#123;LOG_LEVEL:-ERROR&#125;</span><br><span class="line">      DB_ENGINE: $&#123;DB_HOST:-mysql&#125; # 新版要求</span><br><span class="line">      DB_HOST: $&#123;DB_HOST:-mysql&#125;</span><br><span class="line">      DB_PORT: $&#123;DB_PORT:-3306&#125;</span><br><span class="line">      DB_USER: $&#123;DB_USER:-root&#125;</span><br><span class="line">      DB_PASSWORD: $&#123;DB_PASSWORD:-123456&#125;</span><br><span class="line">      DB_NAME: $&#123;DB_NAME:-jumpserver&#125;</span><br><span class="line">      REDIS_HOST: $&#123;REDIS_HOST:-redis&#125;</span><br><span class="line">      REDIS_PORT: $&#123;REDIS_PORT:-6379&#125;</span><br><span class="line">      REDIS_PASSWORD: $&#123;REDIS_PASSWORD:-123456&#125;</span><br><span class="line">      DOMAINS: $&#123;DOMAINS:-&#125;</span><br><span class="line">    ports:</span><br><span class="line">      - $&#123;HTTP_PORT:-80&#125;:80/tcp</span><br><span class="line">      - $&#123;SSH_PORT:-2222&#125;:2222/tcp</span><br><span class="line">    depends_on:</span><br><span class="line">      mysql:</span><br><span class="line">        condition: service_healthy</span><br><span class="line">      redis:</span><br><span class="line">        condition: service_healthy</span><br><span class="line">    healthcheck:</span><br><span class="line">      test: &quot;curl -fsL http://localhost/api/health/ &gt; /dev/null&quot;</span><br><span class="line">      interval: 10s</span><br><span class="line">      timeout: 5s</span><br><span class="line">      retries: 3</span><br><span class="line">      start_period: 90s</span><br><span class="line">    volumes:</span><br><span class="line">      - $&#123;VOLUME_DIR:-./data&#125;/core/data:/opt/jumpserver/core/data</span><br><span class="line">      - $&#123;VOLUME_DIR:-./data&#125;/koko/data:/opt/jumpserver/koko/data</span><br><span class="line">      - $&#123;VOLUME_DIR:-./data&#125;/lion/data:/opt/jumpserver/lion/data</span><br><span class="line">      - $&#123;VOLUME_DIR:-./data&#125;/chen/data:/opt/jumpserver/chen/data</span><br><span class="line">      - $&#123;VOLUME_DIR:-./data&#125;/kael/data:/opt/jumpserver/kael/data</span><br><span class="line">      - $&#123;VOLUME_DIR:-./data&#125;/web/log:/var/log/nginx</span><br><span class="line">    networks:</span><br><span class="line">      - net</span><br><span class="line">networks:</span><br><span class="line">  net:</span><br><span class="line">    ipam:</span><br><span class="line">      driver: default</span><br><span class="line">      config:</span><br><span class="line">        - subnet: 172.27.0.0/16</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">[root@bogon ~]$ VERSION=4.8.1</span><br><span class="line">[root@bogon ~]$ curl -sSL https://resource.fit2cloud.com/jumpserver/jumpserver/releases/download/v$&#123;VERSION&#125;/quick_start.sh|bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%A0%A1%E5%9E%92%E6%9C%BA%20JumpServer/" data-id="cmbof5pgb0005m0v6cbbk3it7" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-企业级调度器LVS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/" class="article-date">
  <time class="dt-published" datetime="2025-06-05T01:52:55.108Z" itemprop="datePublished">2025-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="企业级调度器LVS"><a href="#企业级调度器LVS" class="headerlink" title="企业级调度器LVS"></a>企业级调度器LVS</h1><h2 id="集群解决方案"><a href="#集群解决方案" class="headerlink" title="集群解决方案"></a>集群解决方案</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">三轴扩展</span><br><span class="line">x轴扩展:</span><br><span class="line">也称水平扩展(Scale Out),通过复制或者克隆的方式，实现基于当前环境加倍的效果，能够把几乎任何系统或者业务环境扩展大无限的水平，是企业发展过程中通用的一种策略，尤其是项目后期。</span><br><span class="line">简单来说就是，一个不够多个来凑 或者 <span class="string">&quot;增加机器&quot;</span>。</span><br><span class="line">y轴扩展：</span><br><span class="line">也称垂直扩展(Scale Up),通过配置升级或者资源增强的方式，实现基于当前环境加倍的效果，这种方式的扩展受资金承受能力和技术发展程度的限制，企业发展前期常见的方法，中后期限制较多。</span><br><span class="line">简单来说就是，小个打不过换个高的来 或者 <span class="string">&quot;升级机器&quot;</span>。</span><br><span class="line">z轴扩展:</span><br><span class="line">也称拆分扩展，通过业务梳理和资源整合的方式，将业务环境中类似的或者共用的功能拆分并整合在一起，形成特有的业务属性，然后基于业务属性的情况，结合X轴和Y轴的方法满足业务需求，而且实现资源高效利用。</span><br><span class="line">简单来说就是，化整为零各个击破 或者 <span class="string">&quot;独立部署&quot;</span>。</span><br></pre></td></tr></table></figure>

<h4 id="集群类型"><a href="#集群类型" class="headerlink" title="集群类型"></a>集群类型</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">三种分类：</span><br><span class="line">高扩展(LB)：单个主机负载不足的时候，采取增加主机的方式来满足负载需求的解决方案。</span><br><span class="line">高可用(HA)：集群中的某主机失效时候，避免业务中断，我们将其任务转交给其他主机的解决方案。</span><br><span class="line">高性能(HPA)：通过某些技术，实现同样资源来承受更多用户请求负载的解决方案。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="单点故障"><a href="#单点故障" class="headerlink" title="单点故障"></a>单点故障</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于任何一个集群来说，满足业务功能需求是一个方面，但是我们要知道，所有的解决方案都是为了实现一个目的：业务项目的稳定。当我们唯一的服务器崩了怎么办，一旦用户访问的入口被关闭了，再多的投入也是浪费。那么像这种情况，我们一般称之为<span class="string">&quot;单点故障&quot;</span>(Single Point Of Failure)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="高可用集群-High-Availability-Cluster-，也称”主机冗余”集群"><a href="#高可用集群-High-Availability-Cluster-，也称”主机冗余”集群" class="headerlink" title="高可用集群(High Availability Cluster)，也称”主机冗余”集群"></a>高可用集群(High Availability Cluster)，也称”主机冗余”集群</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">它是指将 核心业务使用多台(一般是<span class="number">2</span>台)主机共同工作，支撑并保障核心业务的正常运行，尤其是业务的对外不间断的对外提供服务。核心特点就是<span class="string">&quot;冗余&quot;</span>.</span><br><span class="line"> 它存在的目的就是为了解决单点故障(Single Point of Failure)问题的。</span><br></pre></td></tr></table></figure>

<p><strong>站点可用性指标</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于网站可用性来说，它主要有这么一个指标来评判：</span><br><span class="line">A = MTBF/(MTBF+MTTR)</span><br><span class="line"> MTBF(Mean Time Between Failure),即平均故障间隔时间，表示产品多长时间出现一次问题。 </span><br><span class="line"> MTTR(Mean Time To Restoration)，即平均恢复时间,表示产品从故障状态到稳定状态的维修花费时间。  </span><br></pre></td></tr></table></figure>

<h2 id="集群的实现细节"><a href="#集群的实现细节" class="headerlink" title="集群的实现细节"></a>集群的实现细节</h2><h4 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">分布式计算机系统，是指由多台分散的计算机，经互连网络的联接而形成的系统，系统的处理和控制功能分布在各个计算机上</span><br><span class="line"></span><br><span class="line">分布式应用：</span><br><span class="line">  服务按照功能拆分，使用微服务器构搭建的系统</span><br><span class="line">分布式存储：</span><br><span class="line">  将数据分散存储到多个存储服务器上，并将这些分散的存储资源构成一个虚拟的存储设备，包括分布式文件系统、分布式块存储和分布式对象存储外，还包括分布式数据库和分布式缓存等，常用的分布式存储技术包括 HDFS，Ceph等</span><br><span class="line">分布式计算：</span><br><span class="line">  一种科学的计算方法，能把需要进行大量计算的工程数据分割成小块，由多台计算机分别计算，然后再把所有的结果进行合并，得出统一的结论，常用的分布式框架包括 Hadoop，Spark 等</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="集群和分布式的区别"><a href="#集群和分布式的区别" class="headerlink" title="集群和分布式的区别"></a>集群和分布式的区别</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">集群和分布式 <span class="literal">--</span> 集群是同一任务的多副本，而分布式是拆分任务。</span><br><span class="line">集群：</span><br><span class="line">  应该是指多台服务器组合在一起，共同完成某个任务，比如网站访问量大，单台服务器扛不住，用集群来分担负载。</span><br><span class="line">  集群的优点是提高可用性和扩展性，但资源利用率可能不高，因为每台机器都要处理完整的任务。</span><br><span class="line">  生活示例：连锁奶茶店，每家店都能做相同的产品，顾客可去任意一家购买（负载均衡），一家店关门不影响其他店（高可用）。</span><br><span class="line"></span><br><span class="line">分布式：</span><br><span class="line">  更侧重于把一个任务拆分成多个部分，在不同机器上处理，然后合并结果。</span><br><span class="line">  可以更高效地利用资源，处理更大的任务，但复杂度高，需要处理节点间的通信、数据一致性等问题。</span><br><span class="line">  生活示例：哪吒<span class="number">2</span>的制作采用了高度协作的工业化模式，将不同功能模块拆解后分包给上百家专业公司，涵盖动画制作、特效合成、数字资产、美术设计、分镜设计等多个环节，所有分包内容需经导演饺子审核，最终由光线传媒终审。</span><br></pre></td></tr></table></figure>

<h4 id="集群和分布式的特点"><a href="#集群和分布式的特点" class="headerlink" title="集群和分布式的特点"></a>集群和分布式的特点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">集群的主要特点：</span><br><span class="line">  多台机器做同样的事情，通过负载均衡来分配请求，提高可用性和性能。比如Web服务器集群，每台服务器都运行相同的应用，用户请求被分发到不同的服务器上。这样如果一台挂了，其他的还能继续服务，提高了可用性。</span><br><span class="line">分布式系统的主要特点：</span><br><span class="line">  不同的节点处理不同的任务，比如数据库分片，每个节点存储部分数据，或者像MapReduce那样处理大数据，拆分任务到各个节点处理。</span><br></pre></td></tr></table></figure>

<h5 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h5><table>
<thead>
<tr>
<th>维度</th>
<th>集群</th>
<th>分布式</th>
</tr>
</thead>
<tbody><tr>
<td>任务类型</td>
<td>相同任务多副本运行</td>
<td>任务被拆解，不同节点协作完成</td>
</tr>
<tr>
<td>节点角色</td>
<td>同构（所有节点功能相同）</td>
<td>异构（节点可能承担不同职责）</td>
</tr>
<tr>
<td>核心目标</td>
<td>高可用、负载均衡</td>
<td>高效处理大规模任务</td>
</tr>
<tr>
<td>典型技术</td>
<td>Kubernetes、Redis Cluster</td>
<td>Hadoop、微服务、区块链</td>
</tr>
</tbody></table>
<h4 id="集群和分布式的实现目的"><a href="#集群和分布式的实现目的" class="headerlink" title="集群和分布式的实现目的"></a>集群和分布式的实现目的</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分布式</span><br><span class="line">  主要目的是解决大规模问题，通过将任务分解到多个节点上并行处理，提高系统的处理能力和可扩展性，能够处理单个计算机无法处理的大型任务，同时也提高了系统的可靠性和容错能力，因为即使某个节点出现故障，其他节点仍然可以继续工作。</span><br><span class="line"></span><br><span class="line">集群</span><br><span class="line">  主要目的是提供高可用性、高性能和可扩展性。通过多个节点的冗余和负载均衡，确保系统在面对高并发请求或硬件故障时能够持续稳定地运行，提高系统的性能和处理能力，以满足不断增长的业务需求。</span><br></pre></td></tr></table></figure>

<h4 id="架构复杂度"><a href="#架构复杂度" class="headerlink" title="架构复杂度"></a>架构复杂度</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分布式</span><br><span class="line">  架构相对复杂，因为需要考虑任务的分解、子任务的协调、数据的一致性、网络通信等多个方面的问题。设计和实现一个分布式系统需要对分布式算法、网络编程、数据一致性算法等有深入的理解和掌握。</span><br><span class="line"></span><br><span class="line">集群</span><br><span class="line">  架构相对简单一些，主要关注节点的管理、负载均衡和故障转移等方面。通常可以通过一些成熟的集群管理软件来实现集群的搭建和管理，相对来说实现难度较低。</span><br></pre></td></tr></table></figure>

<h4 id="集群的实现方案"><a href="#集群的实现方案" class="headerlink" title="集群的实现方案"></a>集群的实现方案</h4><h5 id="按实现方式分类"><a href="#按实现方式分类" class="headerlink" title="按实现方式分类"></a><strong>按实现方式分类</strong></h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">从硬件和软件两个角度</span><br><span class="line">硬件方案</span><br><span class="line">F5负载均衡设备，价格昂贵，实现功能极其多，大中型公司的核心业务、金融公司、银行采用比较多。Citrix Netscaler、A10等</span><br><span class="line"></span><br><span class="line">软件方案</span><br><span class="line">LVS 可以实现二~四层的负载均衡效果</span><br><span class="line">Nginx 可以实现四~七等的负载均衡效果</span><br><span class="line">Haproxy 可以实现四~七层的负载均衡效果</span><br><span class="line">阿里云  可以实现四~七层的负载均衡效果</span><br><span class="line">                阿里云ALB（七层负载均衡），阿里云NLB（四层负载均衡），阿里云 CLB（传统型负载均衡）</span><br><span class="line">                https://help.aliyun.com/zh/slb/</span><br><span class="line">AWS 可以实现四~七层的负载均衡效果</span><br><span class="line">                ALB（七层负载均衡），AWS NLB（四层负载均衡），AWS CLB（传统型负载均衡）</span><br><span class="line">                https://aws.amazon.com/cn/elasticloadbalancing/</span><br></pre></td></tr></table></figure>

<h5 id="工作的协议层次分类"><a href="#工作的协议层次分类" class="headerlink" title="工作的协议层次分类"></a><strong>工作的协议层次分类</strong></h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">工作在传输层（四层）的负载均衡：</span><br><span class="line">传输层负载均衡基于四层通用协议（TCP/UDP）进行调度</span><br><span class="line"> LVS</span><br><span class="line"> nginx（基于stream划模块）</span><br><span class="line"> haproxy（基于tcp模式）</span><br><span class="line"> 阿里云 NLB和CLB</span><br><span class="line"> AWS NLB和CLB</span><br><span class="line"> </span><br><span class="line">工作在应用层（七层）的负载均衡：</span><br><span class="line">应用层负载均衡通常基于应用层特定协议进行调度，又被称为 proxy server</span><br><span class="line"> 基于 http 协议的负载均衡：nginx，httpd，haproxy（mode http）, ......</span><br><span class="line"> 基于 fastcgi 协议的负载均衡：nginx，httpd，......</span><br><span class="line"> 基于 mysql 协议的负载均衡：mysql<span class="literal">-proxy</span>，mycat，......</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h4 id="五表五链"><a href="#五表五链" class="headerlink" title="五表五链"></a>五表五链</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">iptables防火墙规则很多，不好管理，它用五个表来划分管理范围，以便对数据包进行分组管理，具体如下：</span><br><span class="line"></span><br><span class="line">security: 对数据包的mac信息进行过滤</span><br><span class="line"><span class="keyword">filter</span>：对主机接收的数据包实现过滤功能，它是iptables的默认规则。</span><br><span class="line">nat: 对主机接收的数据包实现转换功能，端口映射，地址映射等,使用场景比较多表。</span><br><span class="line">mangle: 用于对特定数据包的修改，报文拆开，修改，封装表</span><br><span class="line">raw: 特殊场景下实现的自定义规则</span><br><span class="line"></span><br><span class="line">  security表的主要作用是依据 SELinux（Security<span class="literal">-Enhanced</span> Linux）或其他基于 Linux 内核的强制访问控制（MAC）机制，对数据包进行过滤和标记。它可以根据安全上下文来决定是否允许数据包通过，从而提供比传统自主访问控制（DAC）更细粒度、更严格的访问控制，常用于增强系统安全性，防止恶意软件或非法用户对系统资源的非法访问。</span><br><span class="line"> 注意：此处的MAC和网卡的 MAC 地址是两个完全不同的概念，千万不要混淆。</span><br><span class="line"> </span><br><span class="line">对于iptabls来说，<span class="number">5</span>个链：PREROUTING,INPUT,FORWARD,OUTPUT,POSTROUTING。</span><br><span class="line">PREROUTING:数据包进入路由表之前 INPUT:通过路由表后目的地为本机</span><br><span class="line">FORWARD:通过路由表后，目的地不为本机 OUTPUT:由本机产生，向外转发</span><br><span class="line">POSTROUTIONG:发送到网卡接口之前</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\30788\AppData\Roaming\Typora\typora-user-images\image-20250319095854790.png" alt="image-20250319095854790"></p>
<h4 id="SNAT-和-DNAT"><a href="#SNAT-和-DNAT" class="headerlink" title="SNAT 和 DNAT"></a><strong>SNAT</strong> <strong>和</strong> <strong>DNAT</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">网络数据包，我们主要是根据**请求报文**中的数据地址转换划分为 SNAT 和 DNAT，而不是响应数据包。</span><br><span class="line"></span><br><span class="line">![<span class="type">image</span>-<span class="number">20250319100630846</span>](C:\Users\<span class="number">30788</span>\AppData\Roaming\Typora\typora<span class="literal">-user-images</span>\image<span class="literal">-20250319100630846</span>.png)</span><br><span class="line"></span><br><span class="line">```powershell</span><br><span class="line">数据包在网络上上主机间传输的时候，它是这样子的结构形式来传输的。我们这里暂时只关心IP头部，对于一个互联网上的数据包来说，他的ip头部里面包含了，数据包的来源地址以及数据包的目标地址。</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\30788\AppData\Roaming\Typora\typora-user-images\image-20250319101114064.png" alt="image-20250319101114064"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SNAT:源地址转换，应用场景：内网访问外网</span><br><span class="line">源                  目标</span><br><span class="line">SRC_IP:SRC_PORT <span class="literal">--</span>&gt; DEST_IP:DEST:PORT</span><br><span class="line">外部公网IP：Port <span class="literal">--</span>&gt; DEST_IP:DEST:PORT </span><br><span class="line"><span class="comment"># 出去的数据包：经过NAT设备时候，原地址转换成公网IP地址，外部公网IP地址之间是存在路由的，可以自</span></span><br><span class="line">动检索到。</span><br><span class="line">源                    目标</span><br><span class="line">DEST_IP:DEST:PORT <span class="literal">--</span>&gt; 外部公网IP：Port</span><br><span class="line">DEST_IP:DEST:PORT <span class="literal">--</span>&gt; SRC_IP:SRC_PORT</span><br><span class="line"></span><br><span class="line">DNAT:目标地址转换，应用场景：外网访问内网</span><br><span class="line">源                  目标</span><br><span class="line">SRC_IP:SRC_PORT <span class="literal">--</span>&gt; DEST_IP:DEST:PORT（公有地址）</span><br><span class="line">SRC_IP:SRC_PORT <span class="literal">--</span>&gt; 私有DEST_IP:DEST:PORT（私有地址）</span><br><span class="line"><span class="comment"># 进来的数据包：经过NAT设备的时候，公网IP地址转换成私网IP地址，私网地址在同一个网段，线路可达。</span></span><br><span class="line">私有DEST_IP:DEST:PORT（私有地址） <span class="literal">--</span>&gt; SRC_IP:SRC_PORT</span><br><span class="line">DEST_IP:DEST:PORT（公有地址） <span class="literal">--</span>&gt; SRC_IP:SRC_PORT</span><br></pre></td></tr></table></figure>

<h2 id="LVS基础"><a href="#LVS基础" class="headerlink" title="LVS基础"></a>LVS基础</h2><h4 id="LVS-Linux-Virtual-Server"><a href="#LVS-Linux-Virtual-Server" class="headerlink" title="LVS(Linux Virtual Server)"></a>LVS(Linux Virtual Server)</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  LVS 基于IP负载均衡|内容请求分发等技术，整合了一些特有的理念和思想后的一套解决方案。普通的linux主机可以基于lvs提供的负载均衡技术，实现一个高扩展的linux的服务器集群。</span><br></pre></td></tr></table></figure>

<h4 id="一般来说，LVS集群有三部分组成"><a href="#一般来说，LVS集群有三部分组成" class="headerlink" title="一般来说，LVS集群有三部分组成"></a>一般来说，LVS集群有三部分组成</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">负载调度器(load balancer)，负责将客户的请求调度到后端主机上。</span><br><span class="line">服务器池(server pool)，真正响应用户请求的后端主机。</span><br><span class="line">共享存储(shared storage)，存储配置、元数据等相关信息</span><br><span class="line"></span><br><span class="line">共享存储并不属于负载调度器和服务器池中的任何一部分主机，它是独立于这两者之外的一个组件，但 与它们存在紧密的联系。</span><br><span class="line">在 LVS 集群中，共享存储通常是一个单独的存储设备或存储系统，可以是网络附加存储（NAS）、存储区域网络（SAN）等。其作用是为负载调度器和服务器池中的所有主机提供共享的配置文件、元数据以及可能需要共享的数据等，以确保整个集群能够协调一致地工作。例如，服务器池中的后端主机可能需要从共享存储中读取相同的配置信息来正确处理用户请求，负载调度器也可能会参考共享存储中的某些元数据来进行请求调度决策。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="LVS集群提供了四种主要的资源调度功能："><a href="#LVS集群提供了四种主要的资源调度功能：" class="headerlink" title="LVS集群提供了四种主要的资源调度功能："></a>LVS集群提供了四种主要的资源调度功能：</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAT 修改请求数据包的目标ip地址，实现请求转发功能 </span><br><span class="line">Tunneling 给请求数据包外部增加新的ip首部，实现请求转发功能</span><br><span class="line">DirectRouting 修改请求数据包的mac地址，实现请求转发功能</span><br><span class="line">FULLNAT 结合SYNPROXY技术，修改数据包的源ip地址和目标ip地址，实现请求转发功能</span><br></pre></td></tr></table></figure>

<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LVS 是根据监听到的前端请求报文中的目标 IP 和目标协议及端口号，将该请求转发到后台某台 RS 服务器上，由 RS 服务器完成对前端请求的响应，具体的监听规则及调度策略由使用者自行配置。</span><br><span class="line">    LVS 是内核中的功能，工作在 PRE_ROUTING链 和 INPUT链 中间的位置上，截取发往 INPUT 链的请求与配置好的 LVS 监听及调度规则进行对比，如果命中，则会触发 LVS 调度，从而转发该请求</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\30788\AppData\Roaming\Typora\typora-user-images\image-20250319105248228.png" alt="image-20250319105248228"></p>
<h4 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a><strong>常见术语</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">物理术语 - 用于描述主机的常见术语</span><br><span class="line">DS：Director Server。</span><br><span class="line">    指的是LVS集群中的负责调度(Dispatcher)或者负载均衡(Load Balancer)的主机，即部署LVS的主机。</span><br><span class="line">    也称VS(Virtual Server)。</span><br><span class="line">RS：Real Server。</span><br><span class="line">    指的是这正相应用户主机的后端服务器主机。</span><br><span class="line">    也称BS(Backend Server)。</span><br><span class="line"></span><br><span class="line">逻辑术语 - 用户描述逻辑关系的常见术语</span><br><span class="line">VIP：Virtual Server IP</span><br><span class="line">    LVS主机上用于向外部用户提供服务的ip地址，作为用户请求的目标的IP地址。</span><br><span class="line">    它是一个在物理主机上没有物理网卡的ip地址，一般用于LVS主机的外网ip。</span><br><span class="line">DIP：Director Server IP</span><br><span class="line">    LVS主机上和后端提供真正服务的主机通信的IP地址。</span><br><span class="line">    它是一个独立的物理网卡上的地址，一般用于LVS主机的内网ip。</span><br><span class="line">RIP：Real Server IP</span><br><span class="line"> 在LVS调度主机后端，真正响应用户请求的主机IP地址。</span><br><span class="line"> </span><br><span class="line">CIP：Client IP</span><br><span class="line">    发起请求的用户客户端IP地址。</span><br><span class="line">    一般都是外网ip地址。</span><br></pre></td></tr></table></figure>

<h5 id="这四者之间的访问关系如下：CIP-VIP-DIP-RIP"><a href="#这四者之间的访问关系如下：CIP-VIP-DIP-RIP" class="headerlink" title="这四者之间的访问关系如下：CIP &lt;–&gt; VIP &#x3D;&#x3D; DIP &lt;–&gt; RIP"></a>这四者之间的访问关系如下：CIP &lt;–&gt; VIP &#x3D;&#x3D; DIP &lt;–&gt; RIP</h5><p><img src="C:\Users\30788\AppData\Roaming\Typora\typora-user-images\image-20250319105609725.png" alt="image-20250319105609725"></p>
<h5 id="我们在课程中实践的时候，往往在LVS上配置两个网卡，一个对外，一个对内"><a href="#我们在课程中实践的时候，往往在LVS上配置两个网卡，一个对外，一个对内" class="headerlink" title="我们在课程中实践的时候，往往在LVS上配置两个网卡，一个对外，一个对内"></a>我们在课程中实践的时候，往往在LVS上配置两个网卡，一个对外，一个对内</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">为了达到不同网段的ip地址能够达到正常的通信，我们需要开启linux服务的ip转发功能</span><br><span class="line">    方法一：在 /etc/sysctl.conf中开启功能</span><br><span class="line">    net.ipv4.ip_forward = <span class="number">1</span></span><br><span class="line">    方法二：直接修改ip_forward文件</span><br><span class="line">    <span class="built_in">echo</span> <span class="number">1</span> &gt; /proc/sys/net/ipv4/ip_forward</span><br><span class="line">注意：</span><br><span class="line">    <span class="number">0</span> 代表禁用，<span class="number">1</span>代表开启。</span><br></pre></td></tr></table></figure>

<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><h5 id="用户访问流程"><a href="#用户访问流程" class="headerlink" title="用户访问流程"></a>用户访问流程</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">结合我们对LVS的集群结构与常见术语，我们可以简单的梳理一下，在LVS集群环境中，用户请求的处理流程。</span><br><span class="line"><span class="number">1</span> 用户在客户端发起访问服务的请求</span><br><span class="line"><span class="number">2</span> 经过层层的dns解析原理，获取服务的提供ip地址<span class="literal">--VIP</span></span><br><span class="line"><span class="number">3</span> 客户端向VIP所在的LVS主机(VS)发起服务请求</span><br><span class="line"><span class="number">4</span> LVS主机(VS)接收到用户请求，根据自身的配置，将用户请求转交到后端的某主机(RS)</span><br><span class="line"><span class="number">5</span> 用户请求经LVS的DIP网卡，进入到公司内网环境</span><br><span class="line"><span class="number">6</span> 根据数据包的结构，找到真正提供服务的后端主机(RS)</span><br><span class="line"><span class="number">7</span> 公司内部的后端主机，处理用户请求后，采用某种方式返回给客户端</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\30788\AppData\Roaming\Typora\typora-user-images\image-20250319110814720.png" alt="image-20250319110814720"></p>
<h4 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a><strong>软件环境</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LVS软件 由<span class="number">2</span>部分程序组成：ipvs 和 ipvsadm。</span><br><span class="line">ipvs(ip virtual server)</span><br><span class="line">  LVS提供了一个支持多种IP负载均衡技术的IP虚拟服务器软件IPVS，这段代码工作在lvs主机的内核空间(netfilter的INPUT),它用于截获用户请求数据包，根据内部的调度策略实现数据包转交的功能。</span><br><span class="line">    我们只需要在内核中开启此模块的应用即可</span><br><span class="line"></span><br><span class="line">ipvsadm</span><br><span class="line">ipvsadm是工作在用户空间的命令行工具，负责为ipvs的资源调度编写转交规则：</span><br><span class="line">    <span class="number">1</span> 定义lvs集群的名称</span><br><span class="line">    <span class="number">2</span> 定义该集群中处于后端提供真实服务的主机列表(Real Server)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu环境检测内核模块</span><br><span class="line">查看内核模块关于ipvs的信息</span><br><span class="line">[<span class="type">root</span>@<span class="type">bogon</span> <span class="type">boot</span>]<span class="variable">$</span> grep <span class="literal">-i</span> <span class="literal">-C</span> <span class="number">2</span> ipvs /boot/config<span class="literal">-5</span>.<span class="number">15.0</span><span class="literal">-133-generic</span></span><br><span class="line">查看模块信息</span><br><span class="line">[<span class="type">root</span>@<span class="type">bogon</span> <span class="type">boot</span>]<span class="variable">$</span> modinfo ip_vs</span><br><span class="line"></span><br><span class="line">Rocky环境检测内核模块</span><br><span class="line">查看内核模块关于ipvs的信息</span><br><span class="line">[<span class="type">root</span>@<span class="type">bogon</span> <span class="type">boot</span>]<span class="variable">$</span> grep <span class="literal">-i</span> <span class="literal">-C</span> <span class="number">2</span> ipvs /boot/config<span class="literal">-5</span>.<span class="number">14.0</span><span class="literal">-427</span>.<span class="number">13.1</span>.el9_4.x86_64</span><br><span class="line">查看模块信息</span><br><span class="line">[<span class="type">root</span>@<span class="type">bogon</span> <span class="type">boot</span>]<span class="variable">$</span> modinfo ip_vs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="软件部署"><a href="#软件部署" class="headerlink" title="软件部署"></a>软件部署</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ubuntu系统</span><br><span class="line">[<span class="type">root</span>@<span class="type">bogon</span> <span class="type">boot</span>]<span class="variable">$</span> apt install ipvsadm</span><br><span class="line">Rocky系统</span><br><span class="line">[<span class="type">root</span>@<span class="type">bogon</span> ~]<span class="variable">$</span> yum install ipvsadm <span class="literal">-y</span> </span><br></pre></td></tr></table></figure>

<h4 id="集群状态查看"><a href="#集群状态查看" class="headerlink" title="集群状态查看"></a>集群状态查看</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">命令格式：ipvsadm <span class="literal">-Ln</span></span><br><span class="line">格式详解：</span><br><span class="line">    <span class="literal">-L</span> 显示当前的服务或者目标主机信息</span><br><span class="line">    <span class="literal">-n</span> 地址和端口的数字输出</span><br><span class="line">    <span class="literal">--stats</span>                             <span class="comment"># 输出统计信息</span></span><br><span class="line">    <span class="literal">--rate</span>                             <span class="comment"># 输出比例信息</span></span><br><span class="line">    </span><br><span class="line">查看详细信息</span><br><span class="line">[<span class="type">root</span>@<span class="type">bogon</span> ~]<span class="variable">$</span> ipvsadm <span class="literal">-Ln</span> <span class="literal">--rate</span></span><br><span class="line">IP Virtual Server version <span class="number">1.2</span>.<span class="number">1</span> (size=<span class="number">4096</span>)</span><br><span class="line">Prot LocalAddress:Port                 CPS    InPPS   OutPPS    InBPS   OutBPS</span><br><span class="line">  -&gt; RemoteAddress:Port</span><br><span class="line">结果显示：</span><br><span class="line">    这里显示的信息比刚才的内容多多了，而且都是一些性能评判的指标数据：</span><br><span class="line">    CPS-连接数、InPPS-输入连接数、OutPPS-输出连接数、InBPS-输入数据量、OutBPS-输出数据量</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LVS 官方支持三种工作模式，分别是 NAT 模式，DR 模式，TUN 模式，不同的模式有各自不同的特点，使用者可以根据业务场景选择不同的的工作模式来实现其负载均衡集群</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="NAT模式"><a href="#NAT模式" class="headerlink" title="NAT模式"></a><strong>NAT</strong>模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAT：Network address translation （网络地址转换）</span><br><span class="line">  当私网主机和公网主机通信的时候，数据包经过NAT网关时，他会将数据包IP报文首部的中的源IP或目的IP进行转换。</span><br><span class="line">  NAT 模式本质上就是多目标的DNAT（如果记不起来，请自行参考 iptables 课程中的 NAT 网络部份），LVS 将请求报文中的目标地址和目标端口修改为后端的 RS 服务器的 RIP 和 PORT 进行转发</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\30788\AppData\Roaming\Typora\typora-user-images\image-20250319143523369.png" alt="image-20250319143523369"></p>
<h6 id="我们在实践的时候，往往需要再-LVS主机上，定制两个网卡，一个对外，一个对内。"><a href="#我们在实践的时候，往往需要再-LVS主机上，定制两个网卡，一个对外，一个对内。" class="headerlink" title="我们在实践的时候，往往需要再 LVS主机上，定制两个网卡，一个对外，一个对内。"></a>我们在实践的时候，往往需要再 LVS主机上，定制两个网卡，一个对外，一个对内。</h6><h6 id="LVS-和-RS-之间可以是路由器，也可以是交换机。"><a href="#LVS-和-RS-之间可以是路由器，也可以是交换机。" class="headerlink" title="LVS 和 RS 之间可以是路由器，也可以是交换机。"></a>LVS 和 RS 之间可以是路由器，也可以是交换机。</h6><h6 id="数据报文中的源和目标，1-2是请求包，3-4是响应包"><a href="#数据报文中的源和目标，1-2是请求包，3-4是响应包" class="headerlink" title="数据报文中的源和目标，1-2是请求包，3-4是响应包"></a>数据报文中的源和目标，1-2是请求包，3-4是响应包</h6><table>
<thead>
<tr>
<th>报文顺序</th>
<th>源</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>client: 49.89.179.13:12345</td>
<td>LVS-VIP: 219.142.145.239:80</td>
</tr>
<tr>
<td>2</td>
<td>client: 49.89.179.13:12345</td>
<td>RS-RIP: 192.168.10.110:80</td>
</tr>
<tr>
<td>3</td>
<td>RS-RIP: 192.168.10.110:80</td>
<td>client: 49.89.179.13:12345</td>
</tr>
<tr>
<td>4</td>
<td>LVS-VIP: 219.142.145.239:80</td>
<td>client: 49.89.179.13:12345</td>
</tr>
</tbody></table>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">基本工作流程</span><br><span class="line"><span class="number">1</span> 用户向具有公网ip地址的LVS主机地址(VIP)发起请求，(Src=CIP，Dst=VIP)</span><br><span class="line"><span class="number">2</span> LVS主机接收到数据包后，修改数据包的目标地址为后端RS1主机并转发出去，(Src=CIP，Dst=RIP1)</span><br><span class="line"><span class="number">3</span> 后端RS1主机处理完请求后，返回数据包给LVS主机，(Src=RIP1，Dst=CIP)</span><br><span class="line"><span class="number">4</span> LVS主机接收到数据包后，修改数据包的源地址为LVS的公网地址(VIP)并转发出去，(Src=VIP，Dst=CIP)</span><br><span class="line">LVS本质上使用的类似于iptables里面的DNAT策略</span><br><span class="line"> - LVS工作于内核上，而不是iptables的五表五链上</span><br></pre></td></tr></table></figure>

<h5 id="lvs和-iptables"><a href="#lvs和-iptables" class="headerlink" title="lvs和****iptables"></a><strong>lvs</strong>和****iptables</h5><p><img src="E:/biji/image/image-20250319143852351.png" alt="image-20250319143852351"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lvs的NAT模式在iptables里面的流向</span><br><span class="line">lvs工作于 PREROUTING链和INPUT链中间的位置，起到了一个关卡的功能，一旦发现符合lvs规则的请求，直接转发给后端的RS主机。也就是说，更改了正常的iptables数据流向。</span><br><span class="line"></span><br><span class="line">iptables里面的DNAT的数据流向</span><br><span class="line">数据流向到本地主机之后，流经PREROUTING链，然后发现DNAT规则，然后经过FORWARD链将数据包转发到后端的主机。</span><br></pre></td></tr></table></figure>

<h5 id="为什么LVS流入的时候不经过forward链还需要开启端口转发"><a href="#为什么LVS流入的时候不经过forward链还需要开启端口转发" class="headerlink" title="为什么LVS流入的时候不经过forward链还需要开启端口转发"></a><strong>为什么</strong>LVS流入的时候不经过forward链还需要开启端口转发</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">关于ip_forward数据转发的功能</span><br><span class="line">原则上来说，没有经过forward链的数据包是无需启用 ip_forward内核参数的。</span><br><span class="line"></span><br><span class="line">根据我们对于 lvs和iptables的流入数据包的流向分析，发现 lvs的流入数据包没有经过forward链。所以原则上来说，是不需要打开ip_forward功能的。但是实际情况下，还是需要打开的。</span><br><span class="line"></span><br><span class="line">lvs转发到后端真实主机之后，真实主机响应的数据包到达lvs之后的数据流向：</span><br><span class="line">   数据流向到本地主机之后，</span><br><span class="line">     流经PREROUTING链，然后发现DNAT规则，</span><br><span class="line">       - 因为PREROUTING链是lvs主机上所有数据流的总入口</span><br><span class="line">     经过FORWARD链将数据包转发</span><br><span class="line">     流经POSTROUTING链，然后将数据包的源地址实现转换</span><br><span class="line">     然后将数据包发送到互联网上</span><br><span class="line">   所以后端真实主机的响应数据包必须原路返回</span><br><span class="line">     所以，出网的网关地址必须是指定的</span><br></pre></td></tr></table></figure>

<h5 id="NAT-模式特点"><a href="#NAT-模式特点" class="headerlink" title="NAT 模式特点"></a>NAT 模式特点</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">整个网络环境需要涉及到两个网段：公网网段、私网网段</span><br><span class="line">请求报文和响应报文都必须经由 LVS 转发，LVS 易成为系统瓶颈</span><br><span class="line"> - 数据包进入到私网的时候，转换的是目标ip地址，因为提供服务的是RIP主机</span><br><span class="line"> - 数据包进入到外网的时候，转换的是源ip地址，因为数据包来的时候，找的就是VIP</span><br><span class="line"> </span><br><span class="line">RIP 和 DIP 应在同一个 IP 网络，且应使用私网地址；</span><br><span class="line"> - 由于数据包在流转的时候，尤其是RS响应的数据包要走到lvs主机，所以必须配置网关地址DIP。</span><br><span class="line"> - 支持端口映射，可修改请求报文的目标 PORT</span><br><span class="line"> </span><br><span class="line">其他内容</span><br><span class="line"> - VS 必须是 Linux 系统，RS 可以是任意 OS 系统</span><br><span class="line"> - LVS 主机需要开启 ip_forward 转发</span><br></pre></td></tr></table></figure>

<h4 id="DR模式"><a href="#DR模式" class="headerlink" title="DR模式"></a><strong>DR</strong>模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DR：Direct Routing（直接路由）</span><br><span class="line">  DR 模式是 LVS 的默认模式，应用广泛，通过为请求报文重新封装一个 MAC 首部进行转发，源 MAC 是 DIP 所在的接口的 MAC，目标MAC 是某挑选出的 RS 的 RIP 所在接口的 MAC 地址；源 IP/PORT，以及目标 IP/PORT 均保持不变，但源 MAC 和目标 MAC 会发生改变，DR 模式下，数据链路层之上的内容不会发生变化</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250319145855201.png" alt="image-20250319145855201"></p>
<h6 id="LVS-和-RS-之间只能是交换机。不许允许是路由器。"><a href="#LVS-和-RS-之间只能是交换机。不许允许是路由器。" class="headerlink" title="LVS 和 RS 之间只能是交换机。不许允许是路由器。"></a>LVS 和 RS 之间只能是交换机。不许允许是路由器。</h6><h6 id="数据报文中的源和目标，1-2-请求包，3-响应包"><a href="#数据报文中的源和目标，1-2-请求包，3-响应包" class="headerlink" title="数据报文中的源和目标，1-2 请求包，3 响应包"></a>数据报文中的源和目标，1-2 请求包，3 响应包</h6><table>
<thead>
<tr>
<th>报文顺序</th>
<th>源</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>client: 49.89.179.13:12345 (client mac)</td>
<td>LVS-VIP: 219.142.145.239:80（中间有路由的话，是路由器对外 mac 地址）</td>
</tr>
<tr>
<td>2</td>
<td>client: 49.89.179.13:12345 (路由器对内 mac 地址)</td>
<td>LVS-VIP: 219.142.145.239:80 (LVS VIP mac)</td>
</tr>
<tr>
<td>3</td>
<td>LVS: 49.89.179.13:12345 (LVS DIP mac)</td>
<td>RS-VIP: 219.142.145.239:80 (RS RIP mac)</td>
</tr>
<tr>
<td>4</td>
<td>RS-VIP: 219.142.145.239:80 (RS RIP mac)</td>
<td>client: 49.89.179.13:12345 (路由器对内 mac 地址)</td>
</tr>
<tr>
<td>5</td>
<td>RS-VIP: 219.142.145.239:80 (路由器对外 mac 地址)</td>
<td>client: 49.89.179.13:12345 (client mac)</td>
</tr>
</tbody></table>
<h5 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 用户向具有公网ip地址的LVS主机地址(VIP)发起请求，(Src=CIP，Dst=VIP)</span><br><span class="line"><span class="number">2</span> LVS主机接收到数据包后，修改数据包的目标MAC地址为后端RS主机并转发出去，(Src=CIP，Dst=VIP)</span><br><span class="line"><span class="number">3</span> 后端RS主机处理完请求后，返回数据包给客户端主机，(Src=VIP，Dst=CIP)</span><br><span class="line"></span><br><span class="line">整个过程只需要更改数据包外层的mac地址即可。</span><br></pre></td></tr></table></figure>

<h5 id="那么多的VIP，如何找到LVS主机"><a href="#那么多的VIP，如何找到LVS主机" class="headerlink" title="那么多的VIP，如何找到LVS主机"></a><strong>那么多的VIP，如何找到</strong>LVS主机</h5><p>为什么不允许将同一个IP配置在多个主机的网卡上？</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在同一个局域网中，不允许将同一个 IP 地址配置在多个主机的网卡上，主要是为了避免 IP 地址冲突，确保网络通信的准确性和稳定性。</span><br><span class="line"></span><br><span class="line">网络通信混乱：</span><br><span class="line">   IP 地址是网络中设备的唯一标识，当有多个主机使用相同的 IP 地址时，网络中的路由器和交换机等设备无法准确区分数据应该发送到哪个具体的主机，会导致数据传输错误或混乱。例如，当一个数据包发送到这个重复的 IP 地址时，网络设备可能会随机将数据包发送到其中一个主机，或者在多个主机之间来回转发，造成数据丢失或延迟，影响网络通信的正常进行。</span><br><span class="line">地址解析冲突：</span><br><span class="line">   在局域网中，设备通过地址解析协议（ARP）来将 IP 地址映射到 MAC 地址，以便在数据链路层进行数据传输。如果多个主机使用同一个 IP 地址，会导致 ARP 表中的映射关系混乱。当其他设备请求解析该 IP 地址对应的 MAC 地址时，可能会收到多个不同的 MAC 地址响应，使得 ARP 缓存中的信息不准确，进一步影响数据的正确传输。</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<h5 id="LVS的DR模式大量VIP是怎么回事"><a href="#LVS的DR模式大量VIP是怎么回事" class="headerlink" title="LVS的DR模式大量VIP是怎么回事"></a><strong>LVS</strong>的DR模式大量VIP是怎么回事</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在lvs环境中，大量的VIP作用是不一样的</span><br><span class="line">LVS主机上的VIP是用于接受用户请求</span><br><span class="line">   - 所以该VIP必须在互联网上公开</span><br><span class="line">RS主机上的VIP目的是永远响应用户请求</span><br><span class="line">   - 所以该VIP是无需再互联网上公开，避免让客户端知道你是伪造的。</span><br></pre></td></tr></table></figure>

<h5 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ARP 请求：</span><br><span class="line"> 当本地主机需要与同一局域网内的远程主机通信时，它首先会检查自己的 ARP 缓存表，看是否已经有目标 IP 地址对应的 MAC 地址。如果没有，就会发送一个 ARP 请求广播包，这个广播包中包含了目标 IP 地址和自己的 MAC 地址等信息。局域网内的所有设备都会收到这个广播包，但只有目标 IP 地址对应的主机才会响应。</span><br><span class="line">ARP 响应：</span><br><span class="line"> 目标主机收到 ARP 请求后，会将自己的 MAC 地址放入 ARP 响应包中，然后发送给请求方。请求方收到响应后，会将目标 IP 地址和对应的 MAC 地址存入自己的 ARP 缓存表中，以便后续通信使用。</span><br><span class="line">数据传输：</span><br><span class="line"> 通过 ARP 协议获取到目标主机的 MAC 地址后，本地主机就可以将数据包封装成数据帧，在数据帧的首部添加源 MAC 地址和目标 MAC 地址等信息，然后将数据帧发送到局域网中。数据帧会根据 MAC 地址在局域网内传输，最终到达目标主机。</span><br></pre></td></tr></table></figure>

<h5 id="在跨网络通信中，ARP-协议同样起着重要的作用。"><a href="#在跨网络通信中，ARP-协议同样起着重要的作用。" class="headerlink" title="在跨网络通信中，ARP 协议同样起着重要的作用。"></a>在跨网络通信中，ARP 协议同样起着重要的作用。</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arp无法穿越路由器，只能通过一段一段路由的方式传递到目标主机。</span><br><span class="line">当数据包到达目标主机所在的局域网的网关（路由器）时，网关需要知道目标主机的 MAC 地址才能将数据包转发到目标主机。此时，网关会在局域网内发送 ARP 请求来获取目标主机的 MAC 地址。同样，目标主机响应 ARP 请求，网关收到响应后将目标主机的 MAC 地址信息添加到自己的 ARP 缓存中，然后将数据包转发到目标主机。</span><br></pre></td></tr></table></figure>

<h4 id="如何让真正的vip响应请求"><a href="#如何让真正的vip响应请求" class="headerlink" title="如何让真正的vip响应请求"></a><strong>如何让真正的</strong>vip响应请求</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为了保证真正的目标IP地址主机能够接收到数据，需要采取两种方式来解决这种问题</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 收到客户端信息的时候，被动应答。</span><br><span class="line"> /proc/sys/net/ipv4/conf/all/arp_ignore，忽略ARP广播，不应答</span><br><span class="line"><span class="number">2</span> 主动向外部主机发布信息，我是谁。</span><br><span class="line"> /proc/sys/net/ipv4/conf/all/arp_announce，使用本机地址向外进行ARP请求，对外宣传我是谁</span><br></pre></td></tr></table></figure>

<h5 id="如何向真正的vip发送请求"><a href="#如何向真正的vip发送请求" class="headerlink" title="如何向真正的vip发送请求"></a><strong>如何向真正的</strong>vip发送请求</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如何确保前端路由器将目标 IP 为 VIP 的请求报文只发往 LVS 服务器</span><br><span class="line">在前端网关的 ARP 表中做静态绑定 - 不推荐</span><br><span class="line">    - 将 VIP 和 LVS 服务器上的 VIP 所在的网卡的 MAC 地址写死</span><br><span class="line">在 RS 服务器上用 arptables 工具设置  arp 防火墙</span><br><span class="line">    arptables <span class="literal">-A</span> <span class="keyword">IN</span> <span class="literal">-d</span> <span class="variable">$VIP</span> <span class="literal">-j</span> DROP</span><br><span class="line">    arptables <span class="literal">-A</span> OUT <span class="literal">-s</span> <span class="variable">$VIP</span> <span class="literal">-j</span> mangle <span class="literal">--mangle-ip-s</span> <span class="variable">$RIP</span></span><br><span class="line"> </span><br><span class="line">确保 RS 服务器上的 VIP 不对外发送ARP 广播，也不会响应 ARP 广播</span><br><span class="line">    - 在 RS 服务器上修改内核参数关闭 ARP 广播和 ARP 应答</span><br><span class="line">    /proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">    /proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">    - lvs的控制节点主机不参与内核参数的修改</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250319153503041.png" alt="image-20250319153503041"></p>
<h5 id="DR-模式特点"><a href="#DR-模式特点" class="headerlink" title="DR 模式特点"></a>DR 模式特点</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LVS 服务器 和 RS 服务器 上都配置有 VIP 地址</span><br><span class="line"> - 确保前端路由器将目标 IP 为 VIP 的请求报文只发往 LVS 服务器；</span><br><span class="line"> - 后端 RS 服务器上的 VIP 只用作封装响应报文。</span><br><span class="line"> 不可响应 ARP 广播，也不可主动对外发送 ARP 广播</span><br><span class="line"> </span><br><span class="line">RS 的 RIP 可以使用私网地址，也可以是公网地址；</span><br><span class="line"> - RIP 与 DIP在同一 IP 网络；</span><br><span class="line"> - RIP 的网关不能指向 DIP，以确保响应报文不会经由 LVS 服务器</span><br><span class="line"> - RS 服务器和 LVS 服务器要在同一个物理网络（不能跨路由，因为路由会隔离 ARP 广播）</span><br><span class="line"> </span><br><span class="line">LVS 服务器只处理请求报文，不处理响应报文。</span><br><span class="line"> - 相对于 NAT 模式其负载性能会大幅提升，响应由 RS 服务器自行完成</span><br><span class="line"> - 不支持端口映射（端口不能修改，数据链路层之上的内容不会发生变化）</span><br><span class="line"> - 无需开启 ip_forward</span><br><span class="line">RS 服务器可以使用大多数 OS 系统（支持相关网络设置即可）</span><br></pre></td></tr></table></figure>

<h4 id="TUN模式"><a href="#TUN模式" class="headerlink" title="TUN模式"></a><strong>TUN</strong>模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TUN：IP tunneling（IP隧道）</span><br><span class="line"> TUN 模式不修改请求报文的IP首部（源 IP 为 CIP，目标 IP 为 VIP），而是在原 IP 报文之外再封装一个IP首部（源 IP 为 DIP，目标 IP 为 RIP），再将报文发往后端 RS，RS 直接响应客户端（源IP 是 VIP，目标 IP 是 CIP），TUN  模式与 DR 模式的区别是 TUN 模式下 LVS 服务器和后端 RS 可以不在同一个物理网络，可以跨公网</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250319153725063.png" alt="image-20250319153725063"></p>
<h6 id="LVS-和-RS-之间允许是路由器。"><a href="#LVS-和-RS-之间允许是路由器。" class="headerlink" title="LVS 和 RS 之间允许是路由器。"></a>LVS 和 RS 之间允许是路由器。</h6><p>数据报文中的源和目标：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>源</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>client: 49.89.179.13:12345(client mac)</td>
<td>LVS-VIP: 219.142.145.239:80 (LVS VIP mac)</td>
</tr>
<tr>
<td>2</td>
<td>LVS-DIP: 74.176.10.123 (49.89.179.13:12345)(LVS-DIP mac)</td>
<td>RS-RIP: 152.68.174.110(219.142.145.239:80)(RS-RIP mac)</td>
</tr>
<tr>
<td>3</td>
<td>RS-VIP: 219.142.145.239:80 (RS - RIP mac)</td>
<td>client: 49.89.179.13:12345 (网关 MAC)</td>
</tr>
</tbody></table>
<h5 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 用户向具有公网ip地址的LVS主机地址(VIP)发起请求，(Src=CIP，Dst=VIP)</span><br><span class="line"><span class="number">2</span> LVS主机接收到数据包后，将原数据包封装到ip隧道数据包中，转发到后端RS主机，(Src=DIP，Dst=RIP)</span><br><span class="line"><span class="number">3</span> 后端RS主机处理完请求后，返回数据包给客户端主机，(Src=VIP，Dst=CIP)</span><br></pre></td></tr></table></figure>

<h5 id="数据包拆解"><a href="#数据包拆解" class="headerlink" title="数据包拆解"></a><strong>数据包拆解</strong></h5><h6 id="正常的数据包结构"><a href="#正常的数据包结构" class="headerlink" title="正常的数据包结构"></a>正常的数据包结构</h6><p><img src="E:\biji\image\image-20250319154759524.png" alt="image-20250319154759524"></p>
<h6 id="TUN模式下的数据包"><a href="#TUN模式下的数据包" class="headerlink" title="TUN模式下的数据包"></a>TUN模式下的数据包</h6><p><img src="E:\biji\image\image-20250319154823519.png" alt="image-20250319154823519"></p>
<h4 id="整体流程效果"><a href="#整体流程效果" class="headerlink" title="整体流程效果"></a>整体流程效果</h4><p><img src="E:\biji\image\image-20250319154951278.png" alt="image-20250319154951278"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据包到达LVS主机之后</span><br><span class="line">   对数据包进行二次封装处理</span><br><span class="line">   通过 POSTROUTING 将数据包转发给 后端的真实主机</span><br><span class="line">数据包到达RS主机之后</span><br><span class="line">   拆解数据包，然后响应数据</span><br><span class="line">   直接将数据返回给客户端主机</span><br><span class="line"></span><br><span class="line">相较于 DR模型来说，它修改的是 更深层的ip报文，所以性能有些差。但是好处是可以跨网络。</span><br></pre></td></tr></table></figure>

<h5 id="TUN-模式特点"><a href="#TUN-模式特点" class="headerlink" title="TUN 模式特点"></a>TUN 模式特点</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- RIP 和 DIP 可以不处于同一物理网络中，RS 的网关一般不能指向 DIP，且 RIP 可以和公网通信；</span><br><span class="line">- 集群节点可以跨互联网实现，DIP，VIP，RIP 都可以是公网地址；</span><br><span class="line">- RS 服务器上的 tun 接口需要配置 VIP 地址，以便接收 LVS 服务器转发的数据包，以及作为响应报文的源 IP；</span><br><span class="line">- LVS 服务器转发给 RS 服务器时需要使用隧道，隧道外层的数据报文中的源 IP  是 DIP，目标 IP 是</span><br><span class="line">RIP；</span><br><span class="line">- RS 服务器响应给客户端的报文中源 IP 是 VIP，目标 IP 是 CIP；</span><br><span class="line">- LVS 服务器只处理请求报文，不处理响应报文，相对于 NAT 模式其负载性能会大幅提升，响应由 RS 服务器自行完成；</span><br><span class="line">- 不支持端口映射；</span><br><span class="line">- 无需开启 ip_forward；</span><br><span class="line">- RS 服务器的操作系统必须支持隧道功能；</span><br></pre></td></tr></table></figure>

<h4 id="FULLNAT模式"><a href="#FULLNAT模式" class="headerlink" title="FULLNAT模式"></a><strong>FULLNAT</strong>模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FULL NAT：Full Network address translation （完全网络地址转换）</span><br><span class="line"></span><br><span class="line">FULL NAT 模式不是 LVS 官方内置的工作模式，是由阿里巴巴公司开发的第三方模式，仅在 <span class="number">2.6</span>.<span class="number">32</span>版本的内核中存在过，目前主流的 LINUX 发行版并不支持该模式，相对于 NAT 模式而言，FULL NAT 在转发时，将请求报文中的源 IP 地址 源端口和目标 IP 地址目标端口都进行了替换，然后再向后端转发</span><br><span class="line"></span><br><span class="line">FULL NAT 模式主要用于公有云环境中，在阿里云上，不建议将虚拟机设为流量穿透服务，虚拟机网关必须使用其自带的网关，在此情况下，无法修改后端 RS 服务器的网关，则无法使用 NAT 模式，所以需要使用 FULL NAT 模式来解决此类问题</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250319155251888.png" alt="image-20250319155251888"></p>
<h6 id="数据报文中的源和目标"><a href="#数据报文中的源和目标" class="headerlink" title="数据报文中的源和目标"></a>数据报文中的源和目标</h6><table>
<thead>
<tr>
<th>报文顺序</th>
<th>源</th>
<th>目标</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>client: 49.89.179.13:12345</td>
<td>LVS-VIP: 219.142.145.239:80</td>
</tr>
<tr>
<td>2</td>
<td>LVS-DIP: 192.168.10.123:12345</td>
<td>RS-RIP: 192.168.10.110:80</td>
</tr>
<tr>
<td>3</td>
<td>RS-RIP: 192.168.10.110:80</td>
<td>LVS-DIP: 192.168.10.123:12345</td>
</tr>
</tbody></table>
<h6 id="整体效果图"><a href="#整体效果图" class="headerlink" title="整体效果图"></a><strong>整体效果图</strong></h6><h5 id="FULL-NAT-模式特点"><a href="#FULL-NAT-模式特点" class="headerlink" title="FULL NAT 模式特点"></a>FULL NAT 模式特点</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- RIP 和 DIP 不要求在同一网络，但要能通信；RS 网关不必指向 DIP</span><br><span class="line">- 请求报文和响应报文都必须经由 LVS 转发，LVS 易成为系统瓶颈</span><br><span class="line">- 支持端口映射，可修改请求报文的目标 PORT</span><br><span class="line">- VS 必须是 Linux 系统，RS 可以是任意 OS 系统</span><br><span class="line">- LVS 主机需要开启 ip_forward 转发</span><br><span class="line">注意：此类型kernel默认不支持</span><br></pre></td></tr></table></figure>

<h4 id="工作模式小结"><a href="#工作模式小结" class="headerlink" title="工作模式小结"></a><strong>工作模式小结</strong></h4><table>
<thead>
<tr>
<th></th>
<th>NAT</th>
<th>TUN</th>
<th>DR</th>
</tr>
</thead>
<tbody><tr>
<td>RS 服务器系统</td>
<td>无任何额外要求</td>
<td>要求支持隧道功能</td>
<td>要求禁用 ARP 广播和 ARP 应答</td>
</tr>
<tr>
<td>RS 服务器网络</td>
<td>私有网络</td>
<td>私有网络 &#x2F; 公有网络</td>
<td>私有网络</td>
</tr>
<tr>
<td>RS 服务器数量</td>
<td>较少，一般不超过 20 台</td>
<td>可以超过 100 台</td>
<td>可以超过 100 台</td>
</tr>
<tr>
<td>RS 服务器网关</td>
<td>指向 LVS 服务器，原路返回</td>
<td>指向自己的路由器，不需要原路返回</td>
<td>指向自己的路由器，不需要原路返回</td>
</tr>
<tr>
<td>优点</td>
<td>支持端口转换</td>
<td>支持公网</td>
<td>性能最好</td>
</tr>
<tr>
<td>缺点</td>
<td>性能存在瓶颈</td>
<td>要求支持隧道，不支持端口转换</td>
<td>不支持跨网段和端口转换</td>
</tr>
</tbody></table>
<h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"><span class="comment">##### **调度分类**</span></span><br><span class="line"></span><br><span class="line">```powershell</span><br><span class="line">根据我们的梳理，lvs的调度算法，站在<span class="string">&quot;是否考虑到后端主机负载&quot;</span>的角度可以划分为以下三类</span><br><span class="line">静态方法：仅仅从调度策略本身实现的功能角度进行工作</span><br><span class="line"> RR、WRR、DH、SH</span><br><span class="line">动态方法：在满足调度策略本身实现功的前提下，还要考虑后端主机的动态负载效果</span><br><span class="line"> LC、WLC、LBLC、LBLCR、SED、NQ</span><br><span class="line">高版本内核中新增的调度算法: 在 <span class="number">4.15</span> 版本的内核中新增的方法</span><br><span class="line"> FO、OVF、MH、TNDR等</span><br></pre></td></tr></table></figure>

<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">静态算法仅根据算法本身来进行调度，不关注后端 RS 服务器负载情况</span><br><span class="line">RR：Round Robin，轮询算法，</span><br><span class="line"> LVS 服务器将前端请求轮流转发到后端每一台 RS 服务器上，后端每台 RS 服务器处理的请求量都是相同的</span><br><span class="line">WRR：Weight RR，加权轮询算法，</span><br><span class="line"> LVS 服务器将前端请求根据后端 RS 服务器的权重进行转发，对于后端 RS 服务器中性能好的机器可以设置较高的权重，物尽其用</span><br><span class="line">SH：Source Hash，源 IP 地址 hash，</span><br><span class="line"> 将来自于同一个 IP 地址的客户端请求调度到后端同一台 RS 服务器上，从而实现会话保持</span><br><span class="line">DH：Destinatio Hash，目标 IP 地址 hash，</span><br><span class="line"> 客户端的请求第一次被调度到某到 RS 服务器后，其后续的请求都将会被发往同一台 RS 服务器，一般用于正向代理缓存场景</span><br></pre></td></tr></table></figure>

<h5 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">动态算法要根据当前系统中后端 RS 服务器的负载情况进行调度，给负载较低的后端主机多转发，给负载较高的后端主机少转发。</span><br><span class="line"></span><br><span class="line">活动连接：Activeconns ，在 LVS 中，有数据传输的连接被称为活动连接</span><br><span class="line">非活动连接：InActiveconns，在 LVS 中，没有数据传输的连接被称为非活动连接</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="ipvsadm命令"><a href="#ipvsadm命令" class="headerlink" title="ipvsadm命令"></a><strong>ipvsadm</strong>命令</h4><h6 id="关于集群"><a href="#关于集群" class="headerlink" title="关于集群"></a>关于集群</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">增加集群</span><br><span class="line">命令格式：ipvsadm <span class="literal">-A</span> <span class="literal">-t</span>|u|f service_address:port [-<span class="type">s</span> <span class="type">scheduler</span>] [-<span class="type">p</span> [<span class="type">timeout</span>]]</span><br><span class="line">格式详解：</span><br><span class="line">    <span class="literal">-A</span> 增加lvs集群</span><br><span class="line">    <span class="literal">-t</span> 指定lvs主机地址信息</span><br><span class="line">        <span class="literal">-t</span> 指定lvs集群服务主机的tcp端口</span><br><span class="line">        <span class="literal">-u</span> 指定lvs集群服务主机的udp端口</span><br><span class="line">        <span class="operator">-f</span> 指定lvs集群服务主机采用的防火墙自定义规则的标记，默认是数字</span><br><span class="line">        这三个选项最好选择一个，想要多选的话，再创建一条规则即可。</span><br><span class="line">    <span class="literal">-s</span> 指定lvs集群的调度策略，默认是wlc</span><br><span class="line"></span><br><span class="line">编辑集群</span><br><span class="line">命令格式：ipvsadm <span class="literal">-E</span> <span class="literal">-t</span> service_address:port [-<span class="type">s</span> <span class="type">scheduler</span>]</span><br><span class="line">格式详解：</span><br><span class="line"> <span class="literal">-E</span> 编辑lvs集群的信息</span><br><span class="line"> 注意：</span><br><span class="line"> 更改集群信息的时候，只能更改已存在的lvs集群的细节属性，不能直接将lvs的地址更改</span><br><span class="line"></span><br><span class="line">删除集群</span><br><span class="line">命令格式：ipvsadm <span class="literal">-D</span> <span class="literal">-t</span> service_address:port</span><br><span class="line">格式详解：</span><br><span class="line">    <span class="literal">-D</span> 删除指定lvs集群的信息</span><br><span class="line">    <span class="literal">-C</span> 删除所有lvs集群的信息</span><br><span class="line">    注意：</span><br><span class="line">  删除集群信息的时候，必须指定已存在的lvs集群地址，协议也必须正确</span><br></pre></td></tr></table></figure>

<h6 id="关于主机"><a href="#关于主机" class="headerlink" title="关于主机"></a>关于主机</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">查看主机</span><br><span class="line">使用命令：ipvsadm <span class="literal">-Ln</span></span><br><span class="line">对于lvs集群中的主机来说，可以通过ipvsadm命令来查看，它可以通过配置文件专门来显示连接主机的规则信息</span><br><span class="line"> /proc/net/ip_vs 和 /proc/net/ip_vs_conn</span><br><span class="line">注意：</span><br><span class="line"> ip_vs_conn 只显示连接成功的信息，我们会在后序模式实践的过程中，给大家展示效果。</span><br><span class="line"> </span><br><span class="line">增加主机</span><br><span class="line">命令格式：ipvsadm <span class="literal">-a</span> <span class="literal">-t</span> service_address:port <span class="literal">-r</span> server<span class="literal">-address</span>:port <span class="literal">-g</span>|m|i </span><br><span class="line">[<span class="type">options</span>]</span><br><span class="line">格式详解：</span><br><span class="line">    <span class="literal">-a</span> 给lvs集群增加一个真实主机RS</span><br><span class="line">    <span class="literal">-r</span> 指定真实主机的地址信息，格式是 IP:[<span class="type">Port</span>],Port可以省略</span><br><span class="line">    <span class="literal">-g</span>|m|i 设定后端主机的转发模式</span><br><span class="line">        <span class="literal">-g</span> 采用默认的direct routing模式</span><br><span class="line">        <span class="literal">-m</span> 采用masquerading的nat模式</span><br><span class="line">        <span class="literal">-i</span> 采用ipip的tunneling模式</span><br><span class="line">   这三者只能选择其一</span><br><span class="line">    <span class="literal">-w</span> 指定真实主机的权重信息</span><br><span class="line">    </span><br><span class="line">编辑主机</span><br><span class="line">命令格式：ipvsadm <span class="literal">-e</span> <span class="literal">-t</span> service_address:port <span class="literal">-r</span> server<span class="literal">-address</span>:port [<span class="type">options</span>]</span><br><span class="line">格式详解：</span><br><span class="line">    <span class="literal">-e</span> 修改真实主机的属性信息</span><br><span class="line">    <span class="literal">-m</span> 设定真实主机的转发模型信息为nat模型</span><br><span class="line">    注意：</span><br><span class="line">      修改真实主机信息的时候，必须指定已存在的lvs集群地址，协议也必须正确</span><br><span class="line">      <span class="literal">-m</span> 和 <span class="literal">-i</span> 不能同时使用</span><br><span class="line"></span><br><span class="line">删除主机</span><br><span class="line">命令格式：ipvsadm <span class="literal">-d</span> <span class="literal">-t</span> service_address:port <span class="literal">-r</span> server<span class="literal">-address</span>:port</span><br><span class="line">格式详解：</span><br><span class="line">    <span class="literal">-d</span> 删除真实主机的属性信息</span><br><span class="line">    注意：</span><br><span class="line">        lvs服务主机和rs真实主机的地址必须指定正确</span><br><span class="line">        单个删除RS主机有些繁琐，我们可以直接采用删除lvs主机的效果清空所有目标主机</span><br></pre></td></tr></table></figure>

<h6 id="关于规则"><a href="#关于规则" class="headerlink" title="关于规则"></a>关于规则</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">对于ipvsadm来说，我们可以通过ipvsadm<span class="literal">-save</span>的命令来查看和保存lvs的相关规则。</span><br><span class="line">命令格式：ipvsadm<span class="literal">-save</span> [-<span class="type">n</span>]</span><br><span class="line">格式详解：</span><br><span class="line">    <span class="literal">-n</span> 以精确的数字格式打印出lvs规则，如果不加<span class="literal">-n</span>的话，他会基于域名解析，将相应的ip转换成主机名展示</span><br><span class="line">    使用 ipvsadm <span class="literal">-Sn</span> 可以实现同样的效果</span><br><span class="line">    </span><br><span class="line">保存规则</span><br><span class="line">通过 ipvsadm<span class="literal">-save</span> + &gt; 的方式实现 规则的保存</span><br><span class="line">使用两种风格保存规则</span><br><span class="line">ipvsadm<span class="literal">-save</span> <span class="literal">-n</span> &gt; n<span class="literal">-ipvsadm</span></span><br><span class="line">ipvsadm<span class="literal">-save</span> &gt; non<span class="literal">-ipvsadm</span></span><br><span class="line"></span><br><span class="line">清空规则</span><br><span class="line">命令格式：ipvsadm <span class="literal">-C</span></span><br><span class="line">格式详解：</span><br><span class="line"> <span class="literal">-C</span> 清空lvs服务集群规则</span><br></pre></td></tr></table></figure>

<h5 id="默认定制的规则会重启主机后丢失"><a href="#默认定制的规则会重启主机后丢失" class="headerlink" title="默认定制的规则会重启主机后丢失"></a><strong>默认定制的规则会重启主机后丢失</strong></h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">对于ipvsadm设置的规则来说，它是我们操作lvs规则的常见方法，而且是以命令行的方式来运行的，但是这种命令行编写的规则，好处就是灵活生效快，但是缺点就是重启主机后规则自动清空。</span><br><span class="line"></span><br><span class="line">我们可以通过规则保存服务来实现，规则的自动保存</span><br><span class="line">[<span class="type">root</span>@<span class="type">bogon</span> ~]<span class="variable">$</span> service ipvsadm save</span><br><span class="line"></span><br><span class="line">保存规则</span><br><span class="line">ipvsadm<span class="literal">-save</span> <span class="literal">-n</span> &gt; /etc/sysconfig/ipvsadm</span><br><span class="line">设置为开启自启</span><br><span class="line">systemctl enable ipvsadm.service</span><br></pre></td></tr></table></figure>

<h4 id="防火墙标识"><a href="#防火墙标识" class="headerlink" title="防火墙标识"></a>防火墙标识</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FWM：FireWall Mark</span><br><span class="line">LVS（Linux Virtual Server）的防火墙标记 FWM（Firewall Mark）是一种用于在 LVS 负载均衡环境中对报文进行分类和管理的技术。</span><br><span class="line"></span><br><span class="line">功能作用</span><br><span class="line">多应用合并调度：</span><br><span class="line">  可借助防火墙标记来分类报文，然后基于标记定义集群服务，能将多个不同的应用使用同一个集群服务进行调度。比如在搭建 Web 服务器负载均衡时，可把 HTTP 的 <span class="number">80</span> 端口和 HTTPS 的 <span class="number">443</span> 端口服务指向同一个集群，便于统一管理和调度。</span><br><span class="line"> </span><br><span class="line">解决轮询错乱问题：</span><br><span class="line">  以 HTTP 和 HTTPS 为例，若不使用 FWM，默认控制是分开轮询的，可能出现第一次访问 <span class="number">80</span> 端口被轮询到某台服务器，下次访问 <span class="number">443</span> 端口却被轮询到另一台服务器的情况，而使用 FWM 能确保相关服务的请求被分配到同一台真实服务器。</span><br><span class="line">  </span><br><span class="line">实现原理</span><br><span class="line">  在 Director 主机上，利用 iptables 工具在 mangle 表的 PREROUTING 链上对符合条件的报文打标记。</span><br><span class="line">  数据包进入系统时，先经过 PREROUTING 链，在这里根据定义的规则检查目标地址、协议、端口等信息，若符合条件则为数据包打上特定的标记，之后 IPVS（IP Virtual Server）根据这些标记来定义和管理集群服务，实现对不同端口服务的统一调度。</span><br></pre></td></tr></table></figure>

<p><strong>1.3.2.4.3.3</strong> <strong>部署<strong><strong>httpd</strong></strong>服务</strong></p>
<p><strong>1.3.3.2.2.3</strong> <strong>定制<strong><strong>lvs-route</strong></strong>主机****ip</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/" data-id="cmbof5pgd0008m0v60zqz9h55" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-企业级 NoSQL 数据库 Redis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Redis/" class="article-date">
  <time class="dt-published" datetime="2025-06-05T01:52:55.103Z" itemprop="datePublished">2025-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="企业级-NoSQL-数据库-Redis"><a href="#企业级-NoSQL-数据库-Redis" class="headerlink" title="企业级 NoSQL 数据库 Redis"></a>企业级 NoSQL 数据库 Redis</h1><h2 id="NoSQL-数据库"><a href="#NoSQL-数据库" class="headerlink" title="NoSQL 数据库"></a>NoSQL 数据库</h2><h4 id="什么是-NoSQL"><a href="#什么是-NoSQL" class="headerlink" title="什么是 NoSQL"></a>什么是 NoSQL</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据库主要分为两大类：关系型数据库与 NoSQL 数据库。</span><br><span class="line"></span><br><span class="line">关系型数据库，是建立在关系模型基础上的数据库，其借助于集合代数等数学概念和方法来处理数据库中的数据。主流的 MySQL、Oracle、MS SQL Server 和 DB2 都属于这类传统数据库。</span><br><span class="line"></span><br><span class="line">NoSQL 数据库，全称为 Not Only SQL，意思就是适用关系型数据库的时候就使用关系型数据库，不适用的时候可以考虑使用更加合适的数据存储。NoSQL 是对不同于传统的关系型数据库的数据库管理系统的统称。</span><br></pre></td></tr></table></figure>



<h4 id="RDBMS和NOSQL对比"><a href="#RDBMS和NOSQL对比" class="headerlink" title="RDBMS和NOSQL对比"></a>RDBMS和NOSQL对比</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RDBMS</span><br><span class="line">高度组织化结构化数据</span><br><span class="line">结构化查询语言（SQL）</span><br><span class="line">数据和关系都存储在单独的表中。</span><br><span class="line">数据操纵语言，数据定义语言</span><br><span class="line">严格的一致性</span><br><span class="line">基础事务</span><br><span class="line">NoSQL</span><br><span class="line">代表着不仅仅是SQL, 没有声明性查询语言</span><br><span class="line">没有预定义的模式</span><br><span class="line">最终一致性，而非ACID属性</span><br><span class="line">非结构化和不可预知的数据</span><br><span class="line">CAP定理</span><br><span class="line">高性能，高可用性和可伸缩性</span><br></pre></td></tr></table></figure>



<h4 id="NoSQL的优点-缺点"><a href="#NoSQL的优点-缺点" class="headerlink" title="NoSQL的优点&#x2F;缺点"></a>NoSQL的优点&#x2F;缺点</h4><table>
<thead>
<tr>
<th>对比维度</th>
<th>关系型数据库</th>
<th>NoSQL 数据库</th>
</tr>
</thead>
<tbody><tr>
<td>特点</td>
<td>- 数据关系模型基于关系模型，结构化存储，完整性约束 - 基于二维表及其之间的联系，需要连接、并、交、差、除等数据操作 - 采用结构化的查询语言（SQL）做数据读写 - 操作需要数据的一致性，需要事务甚至是强一致性</td>
<td>- 非结构化的存储 - 基于多维关系模型 - 具有特有的使用场景</td>
</tr>
<tr>
<td>优点</td>
<td>- 保持数据的一致性（事务处理） - 可以进行 join 等复杂查询 - 通用化，技术成熟</td>
<td>- 高并发，大数据下读写能力较强 - 基本支持分布式，易于扩展，可伸缩 - 简单，弱结构化存储</td>
</tr>
<tr>
<td>缺点</td>
<td>- 数据读写必须经过 sql 解析，大量数据、高并发下读写性能不足 - 对数据做读写，或修改数据结构时需要加锁，影响并发操作 - 无法适应非结构化存储 - 扩展困难 - 昂贵、复杂</td>
<td>- join 等复杂操作能力较弱 - 事务支持较弱 - 通用性差 - 无完整约束复杂业务场景支持较差</td>
</tr>
</tbody></table>
<h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">对于一个分布式计算系统，不可能同时满足以下三点:</span><br><span class="line">C：Consistency</span><br><span class="line">即一致性， 所有节点在同一时间具有相同的数据视图</span><br><span class="line"></span><br><span class="line">A：Availability</span><br><span class="line">即可用性，所有的节点都保持高可用性,要求服务在接收到客户端请求后，都能够给出响应</span><br><span class="line"></span><br><span class="line">P：Partiton tolerance</span><br><span class="line">分区是指系统中的节点由于网络故障无法相互通信，导致系统被分成多个孤立的子系统</span><br><span class="line"></span><br><span class="line">遵循CAP原理，一个数据分布式系统不可能同时满足C和A和P这<span class="number">3</span>个条件。</span><br><span class="line"></span><br><span class="line">在服务器之间的网络出现异常的情况下，一致性和可用性是不可能同时满足的，必须要放弃一个，来保证另一个。这也正是CAP定理所说的，在分布式系统中，P总是存在的。在P发生的前提下，C(一致性)和A（可用性）不能同时满足。这种情况在做架构设计的时候就要考虑到，要评估对业务的影响，进行权衡决定放弃哪一个。在通常的业务场景下，系统不可用是不能接受的，所以要优先保证可用性，暂时放弃一致性。</span><br><span class="line"></span><br><span class="line">根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 <span class="built_in">CP</span> 原则和满足 AP 原则三大类：</span><br><span class="line">CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统将不是一个标准的分布式系统</span><br><span class="line">比如:单一数据中心数据库,所有节点都位于同一个数据中心，并且节点之间的通信是高可靠的</span><br><span class="line"><span class="built_in">CP</span> - 满足一致性，分区容忍性的系统，通常性能不是特别高。 放弃可用性，追求强一致性和分区容错性</span><br><span class="line">例如: Zookeeper,ETCD,Consul,MySQL的PXC等集群就是追求的强一致，再比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。</span><br><span class="line">AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</span><br><span class="line">放弃一致性，追求分区容忍性和可用性。这是很多分布式系统设计时的选择。</span><br><span class="line">例如：MySQL主从复制，默认是异步机制就可以实现AP，但是用户接受所查询的到数据在一定时间内不是最新的.</span><br></pre></td></tr></table></figure>

<h4 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis (Remote Dictionary Server 远程字典服务)是一个遵循BSD MIT开源协议的高性能的NoSQL</span><br></pre></td></tr></table></figure>

<h4 id="Redis-特性"><a href="#Redis-特性" class="headerlink" title="Redis 特性"></a>Redis 特性</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">速度快: <span class="number">10</span>W QPS,基于内存,C语言实现</span><br><span class="line">单线程：引号的”单线程“</span><br><span class="line">     单线程为何如此快?</span><br><span class="line">       纯内存</span><br><span class="line">       非阻塞</span><br><span class="line">       避免线程切换和竞态消耗</span><br><span class="line">       基于Epoll实现IO多路复用</span><br><span class="line">持久化：RDB，AOF</span><br><span class="line">支持多种数据类型</span><br><span class="line">支持多种编程语言</span><br><span class="line">功能丰富: 支持Lua脚本,发布订阅,事务,pipeline等功能</span><br><span class="line">简单: 代码短小精悍(单机核心代码只有<span class="number">23000</span>行左右),单线程开发容易,不依赖外部库,使用简单</span><br><span class="line">主从复制</span><br><span class="line">支持高可用和分布式</span><br></pre></td></tr></table></figure>

<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一次只运行一条命令</span><br><span class="line">避免执行长(慢)命令:keys *, flushall, flushdb, slow lua script, mutil/exec, operate bigvalue(collection)</span><br><span class="line">其实不是单线程: 早期版本是单进程单线程,<span class="number">3.0</span> 版本后实际还有其它的线程, 实现特定功能,如: fysncfile descriptor,close file descriptor</span><br></pre></td></tr></table></figure>

<h4 id="Redis-对比-Memcached"><a href="#Redis-对比-Memcached" class="headerlink" title="Redis 对比 Memcached"></a>Redis 对比 Memcached</h4><table>
<thead>
<tr>
<th>比较类别</th>
<th>Redis</th>
<th>Memcached</th>
</tr>
</thead>
<tbody><tr>
<td>支持的数据结构</td>
<td>哈希、列表、集合、有序集合</td>
<td>纯 key-value</td>
</tr>
<tr>
<td>持久化支持</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>高可用支持</td>
<td>redis 支持集群功能，可以实现主动复制，读写分离。官方提供了 Sentinel 集群管理工具，能够实现主从服务监控，故障自动转移，这一切，对于客户端都是透明的，无需程序改动，也无需人工介入</td>
<td>需要二次开发</td>
</tr>
<tr>
<td>存储 value 容量</td>
<td>最大 512M</td>
<td>最大 1M</td>
</tr>
<tr>
<td>内存分配</td>
<td>临时申请空间，可能导致碎片</td>
<td>预分配内存池的方式管理内存，能够省去内存分配时间</td>
</tr>
<tr>
<td>虚拟内存使用</td>
<td>有自己的 VM 机制，理论上能够存储比物理内存更多的数据，当数据超量时，会引发 swap，把冷数据刷到磁盘上</td>
<td>所有的数据存储在物理内存里</td>
</tr>
<tr>
<td>网络模型</td>
<td>非阻塞 IO 复用模型，提供一些非 KV 存储之外的排序，聚合功能，在执行这些功能时，复杂的 CPU 计算，会阻塞整个 IO 调度</td>
<td>非阻塞 IO 复用模型</td>
</tr>
<tr>
<td>水平扩展的支持</td>
<td>redis cluster 可以横向扩展</td>
<td>暂无</td>
</tr>
<tr>
<td>多线程</td>
<td>Redis6.0 之前是只支持单线程</td>
<td>Memcached 支持多线程，CPU 利用方面 Memcache 优于 Redis</td>
</tr>
<tr>
<td>过期策略</td>
<td>有专门线程，清除缓存数据</td>
<td>懒淘汰机制：每次往缓存放入数据的时候，都会存一个时间，在读取的时候要和设置的时间做 TTL 比较来判断是否过期</td>
</tr>
<tr>
<td>单机 QPS</td>
<td>约 10W</td>
<td>约 60W</td>
</tr>
<tr>
<td>源代码可读性</td>
<td>代码清爽简洁</td>
<td>可能是考虑了太多的扩展性，多系统的兼容性，代码不清爽</td>
</tr>
<tr>
<td>适用场景</td>
<td>复杂数据结构、有持久化、高可用需求、value 存储内容较大</td>
<td>纯 KV，数据量非常大，并发量非常大的业务</td>
</tr>
</tbody></table>
<h4 id="Redis-常见应用场景"><a href="#Redis-常见应用场景" class="headerlink" title="Redis 常见应用场景"></a>Redis 常见应用场景</h4><p><img src="E:\biji\image\image-20250331195955711.png" alt="image-20250331195955711"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">缓存：缓存RDBMS中数据,比如网站的查询结果、商品信息、微博、新闻、消息</span><br><span class="line">Session 共享：实现Web集群中的多服务器间的 session 共享</span><br><span class="line">计数器：商品访问排行榜、浏览数、粉丝数、关注、点赞、评论等和次数相关的数值统计场景</span><br><span class="line">社交：朋友圈、共同好友、可能认识他们等</span><br><span class="line">地理位置: 基于地理信息系统GIS（Geographic Information System)实现摇一摇、附近的人、外卖等功能</span><br><span class="line">消息队列：ELK等日志系统缓存、业务的订阅/发布系统</span><br></pre></td></tr></table></figure>

<h3 id="缓存的实现流程"><a href="#缓存的实现流程" class="headerlink" title="缓存的实现流程"></a>缓存的实现流程</h3><h5 id="数据更新操作流程："><a href="#数据更新操作流程：" class="headerlink" title="数据更新操作流程："></a>数据更新操作流程：</h5><p><img src="E:\biji\image\image-20250331200116061.png" alt="image-20250331200116061"></p>
<h5 id="数据读操作流程："><a href="#数据读操作流程：" class="headerlink" title="数据读操作流程："></a>数据读操作流程：</h5><p><img src="E:\biji\image\image-20250331200133734.png" alt="image-20250331200133734"></p>
<h4 id="缓存穿透-缓存击穿和缓存雪崩"><a href="#缓存穿透-缓存击穿和缓存雪崩" class="headerlink" title="缓存穿透,缓存击穿和缓存雪崩"></a>缓存穿透,缓存击穿和缓存雪崩</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透 Cache Penetration</span><br><span class="line">缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，比如： 发起为id为 “<span class="literal">-1</span>” 的数据或id为特别大不存在的数据。</span><br><span class="line">这时的用户很可能是攻击者，攻击会导致数据库压力过大。</span><br><span class="line">解决方法：</span><br><span class="line">接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=<span class="number">0</span>的直接拦截</span><br><span class="line">从缓存取不到的数据，在数据库中也没有取到，这时也可以将key<span class="literal">-value</span>对写为key<span class="literal">-null</span>，缓存有效时间可以设置短点，如<span class="number">30</span>秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</span><br><span class="line"></span><br><span class="line">缓存击穿 Cache breakdown</span><br><span class="line">缓存击穿是指缓存中没有但数据库中有的数据，比如：热点数据的缓存时间到期后，这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</span><br><span class="line">解决方法：</span><br><span class="line">设置热点数据永远不过期。</span><br><span class="line"></span><br><span class="line">缓存雪崩 Thunder Hurd Problem</span><br><span class="line">缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</span><br><span class="line">解决方法：</span><br><span class="line">缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生</span><br><span class="line">如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中</span><br><span class="line">设置热点数据永远不过期</span><br></pre></td></tr></table></figure>

<h4 id="缓存-crash"><a href="#缓存-crash" class="headerlink" title="缓存 crash"></a>缓存 crash</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redis 缓存服务宕机，造成 缓存服务失效</span><br><span class="line">解决方法：Redis高可用集群</span><br></pre></td></tr></table></figure>

<h4 id="Pipeline-流水线"><a href="#Pipeline-流水线" class="headerlink" title="Pipeline 流水线"></a>Pipeline 流水线</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Redis 客户端执行一条命令分<span class="number">6</span>个过程：</span><br><span class="line">发送命令－-〉网络传输－-〉 命令排队－-〉命令执行－-〉网络传输－-〉 返回结果</span><br><span class="line">这个过程称为Round trip time(简称RTT, 往返时间)，mget,mset指令可以一次性的批量对多个数据的执</span><br><span class="line">行操作,所以有效节约了RTT</span><br><span class="line">但大部分命令（如hgetall）不支持批量操作，需要消耗N次RTT ，利用 Pipeline 技术可以解决这一问题</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="未使用pipeline执行N条命令如下图"><a href="#未使用pipeline执行N条命令如下图" class="headerlink" title="未使用pipeline执行N条命令如下图"></a>未使用pipeline执行N条命令如下图</h5><p><img src="E:\biji\image\image-20250331201524132.png" alt="image-20250331201524132"></p>
<h5 id="使用了pipeline执行N条命令如下图"><a href="#使用了pipeline执行N条命令如下图" class="headerlink" title="使用了pipeline执行N条命令如下图"></a>使用了pipeline执行N条命令如下图</h5><p><img src="E:\biji\image\image-20250331201544163.png" alt="image-20250331201544163"></p>
<h5 id="两者性能对比"><a href="#两者性能对比" class="headerlink" title="两者性能对比"></a>两者性能对比</h5><table>
<thead>
<tr>
<th>网络</th>
<th>延迟</th>
<th>非 Pipeline</th>
<th>Pipeline</th>
</tr>
</thead>
<tbody><tr>
<td>本机</td>
<td>0.17ms</td>
<td>573ms</td>
<td>134ms</td>
</tr>
<tr>
<td>内网服务器</td>
<td>0.41ms</td>
<td>1610ms</td>
<td>240ms</td>
</tr>
<tr>
<td>异地机房</td>
<td>7ms</td>
<td>80000ms</td>
<td>1104ms</td>
</tr>
</tbody></table>
<h4 id="Redis-安装"><a href="#Redis-安装" class="headerlink" title="Redis 安装"></a>Redis 安装</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">安装方法</span><br><span class="line">包安装</span><br><span class="line">源码编译</span><br><span class="line">容器运行</span><br></pre></td></tr></table></figure>

<h4 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Redis 是基于内存型的NoSQL, 和MySQL是不同的,使用内存进行数据保存</span><br><span class="line">如果想实现数据的持久化,Redis也也可支持将内存数据保存到硬盘文件中</span><br><span class="line">Redis支持两种数据持久化保存方法</span><br><span class="line">RDB:Redis DataBase</span><br><span class="line">AOF:AppendOnlyFile</span><br></pre></td></tr></table></figure>

<h5 id="RDB-工作原理"><a href="#RDB-工作原理" class="headerlink" title="RDB 工作原理"></a>RDB 工作原理</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是基于某个时间点的快照，注意RDB只保留当前最新版本的一个快照相当于MySQL中的完全备份</span><br><span class="line">RDB 持久化功能所生成的 RDB 文件是一个经过压缩的二进制文件，通过该文件可以还原生成该 RDB 文件时数据库的状态。因为 RDB 文件是保存在磁盘中的，所以即便 Redis 服务进程甚至服务器宕机，只要磁盘中 RDB 文件存在，就能将数据恢复</span><br><span class="line">RDB 支持save和bgsave两种命令实现数据文件的持久化</span><br><span class="line">注意： save 指令使用主进程进行备份，而不生成新的子进程，但是也会生成临时文件temp-&lt;主进程PID&gt;.rdb文件</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250402192923373.png" alt="image-20250402192923373"></p>
<h6 id="save-执行过程会使用主进程进行快照，并生成临时文件temp-rdb文件"><a href="#save-执行过程会使用主进程进行快照，并生成临时文件temp-rdb文件" class="headerlink" title="save 执行过程会使用主进程进行快照，并生成临时文件temp-&lt;主进程PID&gt;.rdb文件"></a>save 执行过程会使用主进程进行快照，并生成临时文件temp-&lt;主进程PID&gt;.rdb文件</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>]   Done                    redis<span class="literal">-cli</span> <span class="literal">-a</span> <span class="number">123456</span> save</span><br><span class="line">total <span class="number">1492</span></span><br><span class="line">drwxr<span class="literal">-xr-x</span> <span class="number">2</span> redis redis    <span class="number">4096</span> Apr  <span class="number">2</span> <span class="number">11</span>:<span class="number">41</span> ./</span><br><span class="line">drwxr<span class="literal">-xr-x</span> <span class="number">7</span> redis redis    <span class="number">4096</span> Apr  <span class="number">2</span> <span class="number">11</span>:<span class="number">38</span> ../</span><br><span class="line"><span class="literal">-rw-r--r--</span> <span class="number">1</span> redis redis <span class="number">1477877</span> Apr  <span class="number">2</span> <span class="number">11</span>:<span class="number">41</span> dump.rdb</span><br><span class="line"><span class="literal">-rw-r--r--</span> <span class="number">1</span> redis redis   <span class="number">40960</span> Apr  <span class="number">2</span> <span class="number">11</span>:<span class="number">41</span> temp<span class="literal">-7391</span>.rdb</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="RDB-bgsave-实现快照"><a href="#RDB-bgsave-实现快照" class="headerlink" title="RDB bgsave 实现快照"></a>RDB bgsave 实现快照</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先从redis 主进程先fork生成一个新的子进程,此子进程负责将Redis内存数据保存为一个临时文件tmp-</span><br><span class="line">&lt;子进程pid&gt;.rdb</span><br><span class="line">当数据保存完成后,再将此临时文件改名为RDB文件,如果有前一次保存的RDB文件则会被替换，最后关闭</span><br><span class="line">此子进程</span><br><span class="line">由于Redis只保留最后一个版本的RDB文件,如果想实现保存多个版本的数据,需要人为实现</span><br></pre></td></tr></table></figure>

<h4 id="实现-RDB-方法"><a href="#实现-RDB-方法" class="headerlink" title="实现 RDB 方法"></a>实现 RDB 方法</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save: 同步,不推荐使用，使用主进程完成快照，因此会阻塞其它命令执行</span><br><span class="line">bgsave: 异步后台执行,不影响其它命令的执行，会开启独立的子进程，因此不会阻赛其它命令执行</span><br><span class="line">配置文件实现自动保存: 在配置文件中制定规则,自动执行bgsave</span><br></pre></td></tr></table></figure>

<h4 id="RDB-模式的优缺点"><a href="#RDB-模式的优缺点" class="headerlink" title="RDB 模式的优缺点"></a>RDB 模式的优缺点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line">RDB快照只保存某个时间点的数据，恢复的时候直接加载到内存即可，不用做其他处理，这种文件适合用于做灾备处理.可以通过自定义时间点执行redis指令bgsave或者save保存快照，实现多个版本的备份</span><br><span class="line">比如: 可以在最近的<span class="number">24</span>小时内，每小时备份一次RDB文件，并且在每个月的每一天，也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到指定的不同的版本。</span><br><span class="line">RDB在大数据集时恢复的速度比AOF方式要快</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line">不能实时保存数据，可能会丢失自上一次执行RDB备份到当前的内存数据</span><br><span class="line">如果需要尽量避免在服务器故障时丢失数据，那么RDB并不适合。虽然Redis允许设置不同的保存点（save point）来控制保存RDB文件的频率，但是，因为RDB文件需要保存整个数据集的状态，所以它可能并不是一个非常快速的操作。因此一般会超过<span class="number">5</span>分钟以上才保存一次RDB文件。在这种情况下，一旦发生故障停机，就可能会丢失较长时间的数据。</span><br><span class="line">在数据集比较庞大时，fork()子进程可能会非常耗时，造成服务器在一定时间内停止处理客户端请求,如果数据集非常巨大，并且CPU时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒或更久。另外子进程完成生成RDB文件的时间也会花更长时间.</span><br></pre></td></tr></table></figure>

<h4 id="AOF-工作原理"><a href="#AOF-工作原理" class="headerlink" title="AOF 工作原理"></a>AOF 工作原理</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AOF 即 AppendOnlyFile，AOF 和 RDB 都采有COW机制</span><br><span class="line">AOF 可以指定不同的保存策略,默认为每秒钟执行一次 fsync,按照操作的顺序地将变更命令追加至指定的AOF日志文件尾部</span><br><span class="line">在第一次启用AOF功能时，会做一次完全备份，后续将执行增量性备份，相当于完全数据备份+增量变化</span><br><span class="line">如果同时启用RDB和AOF,进行恢复时,默认AOF文件优先级高于RDB文件,即会使用AOF文件进行恢复</span><br><span class="line">在第一次开启AOF功能时,会自动备份所有数据到AOF文件中,后续只会记录数据的更新指令</span><br><span class="line">注意: AOF 模式默认是关闭的,第一次开启AOF后,并重启服务生效后,会因为AOF的优先级高于RDB,而AOF默认没有数据文件存在,从而导致所有数据丢失</span><br></pre></td></tr></table></figure>

<h4 id="AOF-模式优缺点"><a href="#AOF-模式优缺点" class="headerlink" title="AOF 模式优缺点"></a>AOF 模式优缺点</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">优点:</span><br><span class="line">数据安全性相对较高，根据所使用的fsync策略(fsync是同步内存中redis所有已经修改的文件到存储设备)，默认是appendfsync everysec，即每秒执行一次 fsync,在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据( fsync会在后台线程执行，所以主线程可以继续努力地处理命令请求)</span><br><span class="line"></span><br><span class="line">由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中不需要seek, 即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，可以通过 redis<span class="literal">-check-aof</span> 工具来解决数据一致性的问题</span><br><span class="line"></span><br><span class="line">Redis可以在 AOF文件体积变得过大时，自动地在后台对AOF进行重写,重写后的新AOF文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的，因为Redis在创建新 AOF文件的过程中，append模式不断的将修改数据追加到现有的 AOF文件里面，即使重写过程中发生停机，现有的 AOF文件也不会丢失。而一旦新AOF文件创建完毕，Redis就会从旧AOF文件切换到新AOF文件，并开始对新AOF文件进行追加操作。</span><br><span class="line"></span><br><span class="line">AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，也可以通过该文件完成数据的重建</span><br><span class="line"></span><br><span class="line">AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以Redis协议的格式保存，因此 AOF文件的内容非常容易被人读懂，对文件进行分析(parse)也很轻松。导出（export)AOF文件也非常简单:举个例子，如果不小心执行了FLUSHALL.命令，但只要AOF文件未被重写，那么只要停止服务器，移除 AOF文件末尾的FLUSHAL命令，并重启Redis ,就可以将数据集恢复到FLUSHALL执行之前的状态。</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line">即使有些操作是重复的也会全部记录，AOF 的文件大小一般要大于 RDB 格式的文件</span><br><span class="line">AOF 在恢复大数据集时的速度比 RDB 的恢复速度要慢</span><br><span class="line">如果 fsync 策略是appendfsync no, AOF保存到磁盘的速度甚至会可能会慢于RDB</span><br><span class="line">bug 出现的可能性更多</span><br></pre></td></tr></table></figure>

<h4 id="RDB和AOF-的选择"><a href="#RDB和AOF-的选择" class="headerlink" title="RDB和AOF 的选择"></a>RDB和AOF 的选择</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果主要充当缓存功能,或者可以承受较长时间,比如数分钟数据的丢失, 通常生产环境一般只需启用RDB即可,此也是默认值</span><br><span class="line">如果一点数据都不能丢失,可以选择同时开启RDB和AOF</span><br><span class="line">一般不建议只开启AOF</span><br></pre></td></tr></table></figure>

<h4 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis 数据类型"></a>Redis 数据类型</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">![<span class="type">image</span>-<span class="number">20250403102953994</span>](E:\biji\image\image<span class="literal">-20250403102953994</span>.png)</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 字符串 string</span></span><br><span class="line"></span><br><span class="line">```powershell</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>set key value</td>
<td>设置 key-value</td>
<td>o(1)</td>
</tr>
<tr>
<td>get key</td>
<td>获取 key-value</td>
<td>o(1)</td>
</tr>
<tr>
<td>del key</td>
<td>删除 key-value</td>
<td>o(1)</td>
</tr>
<tr>
<td>setnx setxx</td>
<td>根据 key 是否存在设置 key-value</td>
<td>o(1)</td>
</tr>
<tr>
<td>Incr decr</td>
<td>计数</td>
<td>o(1)</td>
</tr>
<tr>
<td>mget mset</td>
<td>批量操作 key-value</td>
<td>o(n)</td>
</tr>
</tbody></table>
<h4 id="列表-list"><a href="#列表-list" class="headerlink" title="列表 list"></a>列表 list</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Redis列表实际就是简单的字符串数组，按照插入顺序进行排序.</span><br><span class="line">支持双向读写,可以添加一个元素到列表的头部（左边）或者尾部（右边），一个列表最多可以包含</span><br><span class="line"><span class="number">2</span>^<span class="number">32</span><span class="literal">-1</span>=<span class="number">4294967295</span>个元素</span><br><span class="line">每个列表元素用下标来标识,下标 <span class="number">0</span> 表示列表的第一个元素，以 <span class="number">1</span> 表示列表的第二个元素，以此类推。</span><br><span class="line">也可以使用负数下标，以 <span class="literal">-1</span> 表示列表的最后一个元素， <span class="literal">-2</span> 表示列表的倒数第二个元素，元素值可以重复，常用于存入日志等场景，此数据类型比较常用</span><br><span class="line">列表特点</span><br><span class="line">有序</span><br><span class="line">value可重复</span><br><span class="line">左右都可以操作</span><br></pre></td></tr></table></figure>

<h4 id="集合-set"><a href="#集合-set" class="headerlink" title="集合 set"></a>集合 set</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span> 是一个无序的字符串合集</span><br><span class="line">同一个集合中的每个元素是唯一无重复的</span><br><span class="line">支持在两个不同的集合中对数据进行逻辑处理，常用于取交集,并集,统计等场景,例如: 实现共同的朋友</span><br><span class="line">集合特点</span><br><span class="line">无序</span><br><span class="line">无重复</span><br><span class="line">集合间操作</span><br></pre></td></tr></table></figure>

<p>集合间操作</p>
<p><img src="E:\biji\image\image-20250403144145286.png" alt="image-20250403144145286"></p>
<h4 id="有序集合-sorted-set"><a href="#有序集合-sorted-set" class="headerlink" title="有序集合 sorted set"></a>有序集合 sorted set</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Redis有序集合和Redis集合类似，是不包含相同字符串的合集。</span><br><span class="line">它们的差别是，每个有序集合的成员都关联着一个双精度浮点型的评分</span><br><span class="line">这个评分用于把有序集合中的成员按最低分到最高分排序。</span><br><span class="line">有序集合的成员不能重复,但评分可以重复,一个有序集合中最多的成员数为 <span class="number">2</span>^<span class="number">32</span> - <span class="number">1</span>=<span class="number">4294967295</span>个，经常用于排行榜的场景</span><br><span class="line"></span><br><span class="line">有序集合特点</span><br><span class="line">有序</span><br><span class="line">无重复元素</span><br><span class="line">每个元素是由score和value组成</span><br><span class="line">score 可以重复</span><br><span class="line">value 不可以重复</span><br></pre></td></tr></table></figure>

<h4 id="哈希-hash"><a href="#哈希-hash" class="headerlink" title="哈希 hash"></a>哈希 hash</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hash 即字典, 用于保存字符串字段field和字符串值value之间的映射，即key/value做为数据部分</span><br><span class="line">hash特别适合用于存储对象场景.</span><br><span class="line">一个hash最多可以包含<span class="number">2</span>^<span class="number">32</span><span class="literal">-1</span> 个key/value键值对</span><br><span class="line">哈希特点</span><br><span class="line">无序</span><br><span class="line">K/V 对</span><br><span class="line">适用于存放相关的数据</span><br></pre></td></tr></table></figure>

<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">消息队列: 把要传输的数据放在队列中,从而实现应用之间的数据交换</span><br><span class="line">常用功能: 可以实现多个应用系统之间的解耦,异步,削峰/限流等</span><br><span class="line">常用的消息队列应用: Kafka,RabbitMQ,Redis</span><br><span class="line"></span><br><span class="line">消息队列分为两种</span><br><span class="line">生产者/消费者模式: Producer/Consumer</span><br><span class="line">发布者/订阅者模式: Publisher/Subscriber</span><br></pre></td></tr></table></figure>

<h4 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生产者消费者模式下，多个消费者同时监听一个频道(redis用队列实现)，但是生产者产生的一个消息只能被最先抢到消息的一个消费者消费一次,队列中的消息由可以多个生产者写入，也可以有不同的消费者取出进行消费处理.此模式应用广泛</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250403150503960.png" alt="image-20250403150503960"></p>
<p><img src="E:\biji\image\image-20250403150507961.png" alt="image-20250403150507961"></p>
<h4 id="发布者订阅模式"><a href="#发布者订阅模式" class="headerlink" title="发布者订阅模式"></a>发布者订阅模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在发布者订阅者Publisher/Subscriber模式下，发布者Publisher将消息发布到指定的频道channel，事先监听此channel的一个或多个订阅者Subscriber都会收到相同的消息。即一个消息可以由多个订阅者获取到. 对于社交应用中的群聊、群发、群公告等场景适用于此模式</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250403150805071.png" alt="image-20250403150805071"></p>
<h4 id="Redis-集群与高可用"><a href="#Redis-集群与高可用" class="headerlink" title="Redis 集群与高可用"></a>Redis 集群与高可用</h4><p><img src="E:\biji\image\image-20250403160351355.png" alt="image-20250403160351355"></p>
<h4 id="Redis-主从复制"><a href="#Redis-主从复制" class="headerlink" title="Redis 主从复制"></a>Redis 主从复制</h4><p><img src="E:\biji\image\image-20250403160414640.png" alt="image-20250403160414640"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">主从复制架构</span><br><span class="line">Redis和MySQL的主从模式类似，也支持主从模式（master/slave），可以实现Redis数据的跨主机的远程备份</span><br><span class="line">常见客户端连接主从的架构:</span><br><span class="line">程序APP先连接到高可用性 LB 集群提供的虚拟IP，再由LB调度将用户的请求至后端Redis 服务器来真正提供服务</span><br><span class="line"></span><br><span class="line">主从复制的特点:</span><br><span class="line">一个master可以有多个slave</span><br><span class="line">一个slave只能有一个master</span><br><span class="line">数据流向是从master到slave单向的</span><br><span class="line">master 可读可写</span><br><span class="line">slave 只读</span><br></pre></td></tr></table></figure>

<h4 id="主从复制实现"><a href="#主从复制实现" class="headerlink" title="主从复制实现"></a>主从复制实现</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当master出现故障后,可以自动提升一个slave节点变成新的Mster,因此Redis Slave 需要设置和master相同的连接密码</span><br><span class="line">此外当一个Slave提升为新的master时需要通过持久化实现数据的恢复</span><br><span class="line">当配置Redis复制功能时，强烈建议打开主服务器的持久化功能。否则主节点Redis服务应该要避免自动启动。</span><br></pre></td></tr></table></figure>

<h4 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用哨兵 Sentinel 只能解决Redis高可用问题，实现Redis的自动故障转移,但仍然无法解决Redis Master单节点的性能瓶颈问题</span><br><span class="line">为了解决单机性能的瓶颈，提高Redis 服务整体性能，可以使用分布式集群的解决方案</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Redis-Cluster-架构"><a href="#Redis-Cluster-架构" class="headerlink" title="Redis Cluster 架构"></a>Redis Cluster 架构</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Redis cluster 需要至少 <span class="number">3</span>个master节点才能实现,slave节点数量不限</span><br><span class="line">Master节点必须要超过半数以上可用,否则集群将不可用,即数据访问和选举将无法实现</span><br><span class="line">因此Master节点的数据一般为奇数</span><br><span class="line">当然一般每个master都至少对应的有一个slave节点</span><br><span class="line">如果有三个主节点采用哈希槽 hash slot 的方式来分配<span class="number">16384</span>个槽位 slot</span><br><span class="line">此三个节点分别承担的slot 区间可以是如以下方式分配</span><br><span class="line">节点M1 <span class="number">0</span>－<span class="number">5460</span></span><br><span class="line">节点M2 <span class="number">5461</span>－<span class="number">10922</span></span><br><span class="line">节点M3 <span class="number">10923</span>－<span class="number">16383</span></span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250408092030864.png" alt="image-20250408092030864"></p>
<h4 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果是单机存储的话，直接将数据存放在单机redis就行了。但是如果是集群存储，就需要考虑到数据分区了。</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250408092223317.png" alt="image-20250408092223317"></p>
<h5 id="虚拟槽分区"><a href="#虚拟槽分区" class="headerlink" title="虚拟槽分区"></a>虚拟槽分区</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis cluster设置有<span class="number">0</span>~<span class="number">16383</span>的槽，每个槽映射一个数据子集，通过hash函数，将数据存放在不同的槽位中，每个集群的节点保存一部分的槽。</span><br><span class="line">每个key存储时，先经过算法函数CRC16(key)得到一个整数，然后整数与<span class="number">16384</span>取余，得到槽的数值，然后找到对应的节点，将数据存放入对应的槽中。</span><br></pre></td></tr></table></figure>

<h4 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当有新的节点准备好加入集群时，这个新的节点还是孤立节点，加入有两种方式。一个是通过集群节点</span><br><span class="line">执行命令来和孤立节点握手，另一个则是使用脚本来添加节点。</span><br><span class="line"><span class="number">1</span>. cluster_node_ip:port: cluster meet ip port new_node_ip:port</span><br><span class="line"><span class="number">2</span>. redis<span class="literal">-trib</span>.rb <span class="built_in">add-node</span> new_node_ip:port cluster_node_ip:port</span><br><span class="line">通常这个新的节点有两种身份，要么作为主节点，要么作为从节点：</span><br><span class="line">主节点：分摊槽和数据</span><br><span class="line">从节点：作故障转移备份</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250408092613912.png" alt="image-20250408092613912"></p>
<h4 id="槽的迁移"><a href="#槽的迁移" class="headerlink" title="槽的迁移"></a>槽的迁移</h4><p><img src="E:\biji\image\image-20250408092629280.png" alt="image-20250408092629280"></p>
<h4 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h4><p><img src="E:\biji\image\image-20250408092647812.png" alt="image-20250408092647812"></p>
<h4 id="下线节点的流程"><a href="#下线节点的流程" class="headerlink" title="下线节点的流程"></a>下线节点的流程</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 判断该节点是否持有槽，如果未持有槽就跳转到下一步，持有槽则先迁移槽到其他节点</span><br><span class="line"><span class="number">2</span>. 通知其他节点（cluster forget）忘记该下线节点</span><br><span class="line"><span class="number">3</span>. 关闭下线节点的服务</span><br><span class="line"></span><br><span class="line">需要注意的是如果先下线主节点，再下线从节点，会进行故障转移，所以要先下线从节点。</span><br></pre></td></tr></table></figure>

<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">集群同样具备了自动转移故障的功能，和哨兵有些类似，在进行客观下线之后，就开始准备让故障节点的从节点“上任”了。</span><br><span class="line">首先是进行资格检查，只有具备资格的从节点才能参加选举：</span><br><span class="line">故障节点的所有从节点检查和故障主节点之间的断线时间</span><br><span class="line">超过cluster<span class="literal">-node-timeout</span> * cluster<span class="literal">-slave-validati-factor</span>(默认<span class="number">10</span>)则取消选举资格</span><br><span class="line">然后是准备选举顺序，不同偏移量的节点，参与选举的顺位不同。offset最大的slave节点，选举顺位最</span><br><span class="line">高，最优先选举。而offset较低的slave节点，要延迟选举。</span><br></pre></td></tr></table></figure>

<h4 id="Redis-Cluster-部署架构说明"><a href="#Redis-Cluster-部署架构说明" class="headerlink" title="Redis Cluster 部署架构说明"></a>Redis Cluster 部署架构说明</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意: 建立Redis Cluster 的节点需要清空数据，另外网络中不要有Redis哨兵的主从，否则也可能会干扰集群的创建及扩缩容</span><br></pre></td></tr></table></figure>

<h6 id="生产环境：6台服务器，分别是三组master-slave，适用于生产环境"><a href="#生产环境：6台服务器，分别是三组master-slave，适用于生产环境" class="headerlink" title="生产环境：6台服务器，分别是三组master&#x2F;slave，适用于生产环境"></a>生产环境：6台服务器，分别是三组master&#x2F;slave，适用于生产环境</h6><h4 id="集群扩容-1"><a href="#集群扩容-1" class="headerlink" title="集群扩容"></a>集群扩容</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前客户量激增，现有的Redis cluster架构已经无法满足越来越高的并发访问请求，为解决此问题,新购置两台服务器，要求将其动态添加到现有集群，但不能影响业务的正常访问。</span><br><span class="line">新版支持集群中有旧数据的情况进行扩容</span><br><span class="line">注意: 生产环境一般建议master节点为奇数个,比如:<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,以防止脑裂现象</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250408111540336.png" alt="image-20250408111540336"></p>
<p><img src="E:\biji\image\image-20250408111555862.png" alt="image-20250408111555862"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lx1me.github.io/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%20NoSQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%20Redis/" data-id="cmbof5pga0003m0v6h7mz9c55" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-高可用集群Keepalived" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/05/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4Keepalived/" class="article-date">
  <time class="dt-published" datetime="2025-06-05T01:52:55.103Z" itemprop="datePublished">2025-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="高可用集群Keepalived"><a href="#高可用集群Keepalived" class="headerlink" title="高可用集群Keepalived"></a>高可用集群Keepalived</h1><h4 id="集群简介"><a href="#集群简介" class="headerlink" title="集群简介"></a>集群简介</h4><p><img src="E:\biji\image\image-20250321113325305.png" alt="image-20250321113325305"></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>高扩展集群</td>
<td>在当前业务环境集群中，所有的主机节点都处于正常的工作活动状态，它们共同承担起用户的请求带来的工作负载压力，保证用户的正常访问。</td>
</tr>
<tr>
<td>高可用集群</td>
<td>将核心业务使用多台 (一般是 2 台) 主机共同工作，支撑并保障核心业务的正常运行，尤其是业务的对外不间断的对外提供服务。核心特点就是 “冗余”，它存在的目的就是为了解决单点故障 (Single Point of Failure) 问题。</td>
</tr>
<tr>
<td>高性能集群</td>
<td>基于前两种技术实现的集群基础上，高效利用这些主机资源，结合某些特有的技术方案，提供强大的计算能力，从而实现特定用户大型任务的高复杂度数据处理功能，比如生物计算、大场景模拟计算、预测计算等。</td>
</tr>
</tbody></table>
<h4 id="高可用指标"><a href="#高可用指标" class="headerlink" title="高可用指标"></a>高可用指标</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">高可用集群是基于高扩展基础上的一个更高层次的网站稳定性解决方案。网站的稳定性体现在两个方面：网站可用性和恢复能力</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>序号</th>
<th>描述</th>
<th>简称</th>
<th>可用性级别</th>
<th>年度停机时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>基本的可用性</td>
<td>2 个 9</td>
<td>99%</td>
<td>87.6 小时</td>
</tr>
<tr>
<td>2</td>
<td>较高的可用性</td>
<td>3 个 9</td>
<td>99.9%</td>
<td>8.8 小时</td>
</tr>
<tr>
<td>3</td>
<td>故障自动恢复的可用性</td>
<td>4 个 9</td>
<td>99.99%</td>
<td>53 分钟</td>
</tr>
<tr>
<td>4</td>
<td>极高可用性</td>
<td>5 个 9</td>
<td>99.999%</td>
<td>5 分钟</td>
</tr>
</tbody></table>
<h4 id="恢复能力"><a href="#恢复能力" class="headerlink" title="恢复能力"></a>恢复能力</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">所谓的恢复能力，指的是一个网站从发生故障到故障修复这个过程的能力，而这个能力涉及到两个子内容：数据恢复能力和业务恢复能力。</span><br><span class="line">数据恢复能力 RPO(Recovery Point Obejective)</span><br><span class="line"> 是指业务系统所允许的在灾难过程中的最大数据丢失量，用来衡量高可用系统的数据冗余备份能力。</span><br><span class="line"> 例如，恢复到灾难发生前最后一次数据备份的数据状态。</span><br><span class="line"> </span><br><span class="line">系统恢复能力 RTO(Recovery Time Objective)</span><br><span class="line"> 是指应用系统从灾难状态恢复到物理系统环境可运行状态所需的时间，用来衡量高可用系统的恢复能力。</span><br><span class="line"> 例如，服务器重启、数据库重启、数据恢复、应用回归正常运行。</span><br><span class="line"> </span><br><span class="line">网络恢复能力 NRO(Network Recovery Objective)</span><br><span class="line"> 是指网络系统从灾难状态恢复到网络可连接状态所需的时间，用来衡量高可用系统的网络恢复能力。</span><br><span class="line"> 例如，用户在灾难后可以连接到灾备中心的时间。</span><br><span class="line"> </span><br><span class="line">业务恢复能力 RAO(Recovery Access Objective)</span><br><span class="line"> 是指业务系统从灾难状态恢复到可运行状态所需的时间，用来衡量高可用系统的业务恢复能力。</span><br><span class="line"> 例如，用户在灾难后，可以感受到灾难前的业务应用状态。</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250321113635027.png" alt="image-20250321113635027"></p>
<h4 id="高可用方式"><a href="#高可用方式" class="headerlink" title="高可用方式"></a>高可用方式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于集群来说，高可用的最主要的目的就是保证网站接入口的稳定性，通过一个虚拟的接入口，将真实的请求转发到不同地址(一般是两个)的真实接入口出，进而将请求转发到后续高扩展集群主机中。</span><br><span class="line">这个虚拟的接入口，我们一般称之为VIP，这个VIP一般附加在后端的真实接入口，二这两个接入口一个做主一个做从，共同负担起VIP传输过来的信息。</span><br><span class="line">做主的接口主机我们一般称之为Master或者Active，做备的接口主机我们一般称之为Slave或者Passive。</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250321113724019.png" alt="image-20250321113724019"></p>
<h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><table>
<thead>
<tr>
<th>模式名称</th>
<th>模式解析</th>
</tr>
</thead>
<tbody><tr>
<td>主备模式 (Active&#x2F;Passive)</td>
<td>后端的高可用结点运行一致的服务实例，正常情况下，VIP 配置在主节点上，只有作为主的 Active 结点响应用户的请求，当主节点故障，备用结点 Passive 自动接管一切，当主节点恢复后，通过自动或者手动方式，用户的请求重新有主节点来接管，整个过程用户感受不到任何影响。</td>
</tr>
<tr>
<td>双主模式 (Active&#x2F;Active)</td>
<td>后端的高可用结点运行各自的服务实例，都可以正常接收用户访问请求，当 A 结点故障，他会将访问请求自动转移到正常运行的 B 结点上，从而保证不对用户产生影响。但是有可能在 A 节点出现异常的时候，有可能导致 B 节点因为负载的因素导致整体崩溃。</td>
</tr>
<tr>
<td>集群模式 (N+M)</td>
<td>在这种模式下，当主节点故障时候，后备结点主机会通过某些策略，从中选择一个结点，作为临时主节点，接管所有请求。原来的主节点恢复的时候，通过多种策略来响应。</td>
</tr>
</tbody></table>
<h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">为了实现高可用的效果，后端的高可用结点需要如下几种技术来保证：</span><br><span class="line"> 时间同步 和 心跳检测</span><br><span class="line"> </span><br><span class="line">时间同步</span><br><span class="line">   作为一个集群，他们彼此间进行信息通信的一个前提是，时间状态必须一致，如果出现一个主机在<span class="number">2018</span>年，一个在<span class="number">2020</span>年，这种情况下，集群的通信肯定会出现问题，甚至不会传输信息。</span><br><span class="line">    我们一般会采用时间协议，从一个专用的时间服务器上获取时间，从而保证同一个集群中的所有主机时间都是一致的，这个协议我们一般使用ntp协议。</span><br><span class="line">    </span><br><span class="line">心跳检测</span><br><span class="line">   对于高可用集群的各种模式来说，有一个关键的点就是：主节点故障了，从节点接管一切。这就涉及到了一种场景：高可用集群节点间需要知道彼此的状态，就类似于我们要知道一个人是否是活的，就看他有没有心跳。</span><br><span class="line">    所以我们需要通过一种专用的技术来时刻了解集群节点间的状态，我们一般称这种技术为<span class="string">&quot;心跳检测&quot;</span>，常见的软件有VRRP。</span><br></pre></td></tr></table></figure>







<h2 id="Keepalived基础"><a href="#Keepalived基础" class="headerlink" title="Keepalived基础"></a><strong>Keepalived</strong>基础</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vrrp 属于 网络层的一种 协议。</span><br><span class="line"></span><br><span class="line">工作流程</span><br><span class="line">keepalived部署在多台主机上(一般是两台)，keepalived服务启动后，会加载专用的配置文件，调用内核的LVS服务以创建虚拟服务器，并根据配置启用对外的统一访问接口，并且基于相关插件脚本对服务进行监控。</span><br><span class="line"> 为了保证服务对外的统一接口的高可用，VRRP协议将物理Router进行统一管理，并创建一个虚拟路由地址，作为外网的统一出口，物理Router内部通过VRRP机制进行内部通信，保证虚拟路由地址永远可用。</span><br><span class="line"> </span><br><span class="line">通过我们对keepalived软件的结构和官方的介绍，我们可以知道，Keepalived其实就是通过整合和加</span><br><span class="line">强LVS和VRRP软件，从而得到的一套适用于高扩展和高可用的软件整合解决方案。</span><br><span class="line"> 根据Keepalived软件的简单结构，我们可以了解到，我们要实现Keepalived的功能，需要在用户空间</span><br><span class="line">安装相应的软件才可以。</span><br></pre></td></tr></table></figure>

<h4 id="vrrp"><a href="#vrrp" class="headerlink" title="vrrp"></a>vrrp</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">虚拟路由冗余协议(Virtual Router Redundancy Protocol，简称VRRP)是由IETF提出的解决局域网中配置静态网关出现单点故障现象的路由协议，其本质上是一种路由容错协议。</span><br><span class="line"></span><br><span class="line">VRRP将局域网内的一组路由器虚拟为单个路由器。我们称该路由器组为VRRP备份组，它根据 <span class="string">&quot;优先级&quot;</span>选择一个Master主路由器，承担网关功能，其他路由器称为Backup从路由器。基于VRRP虚拟出来是路由我们称之为虚拟路由，该虚拟路由有独立的IP地址(VIP)。</span><br><span class="line"></span><br><span class="line">工作模式：</span><br><span class="line"> 主/备：单个虚拟路由器</span><br><span class="line"> 主/主：主/备（虚拟路由器<span class="number">1</span>），备/主（虚拟路由器<span class="number">2</span>）</span><br><span class="line"> </span><br><span class="line"> 局域网内主机不知道后端真实的路由器的ip地址，仅仅知道这个虚拟路由的ip地址，让后将VIP设定为其数据包的出网地址，通过该虚拟路由与外部的其他网络进行通信。</span><br><span class="line">    在整个过程中，如果Master路由器发生故障时，Backup取代Master继续履行网关职责，从而保证网络呢·`内的主机不间断地与外部网络进行通信。</span><br><span class="line">    </span><br><span class="line">虚拟路由器：Virtual Router </span><br><span class="line">虚拟路由器标识：VRID(<span class="number">0</span><span class="literal">-255</span>)，唯一标识虚拟路由器</span><br><span class="line">VIP：Virtual IP </span><br><span class="line">VMAC：Virutal MAC (<span class="number">00</span><span class="literal">-00-5e-00-01-VRID</span>)</span><br><span class="line">物理路由器：</span><br><span class="line">    master：主设备</span><br><span class="line">    backup：备用设备</span><br><span class="line">    priority：优先级</span><br><span class="line">    </span><br><span class="line">通告：心跳，优先级等；周期性</span><br><span class="line">工作方式：抢占式，非抢占式</span><br><span class="line">安全认证：</span><br><span class="line">    无认证 - 互相通信的时候，不需要任何认证信息</span><br><span class="line">    简单字符认证：预共享密钥，通信双方使用简单字符进行基本的认证</span><br><span class="line"> MD5：通信双方使用md5的方式传输认证信息。</span><br><span class="line">工作模式：</span><br><span class="line">    主/备：单个虚拟路由器</span><br><span class="line">    主/主：主/备（虚拟路由器<span class="number">1</span>），备/主（虚拟路由器<span class="number">2</span>）</span><br></pre></td></tr></table></figure>

<h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Keepalived 是一个基于 VRRP 协议的实现高可用的软件，在 Keepalived 中，抢占式和非抢占式是两种重要的工作模式</span><br><span class="line"></span><br><span class="line">抢占式</span><br><span class="line">工作原理</span><br><span class="line">在抢占式模式下，优先级最高的主服务器会一直处于 Master 状态，只要它处于正常运行状态且网络连接正常。当主服务器出现故障或网络问题时，备份服务器会接管其工作，成为 Master 状态。一旦主服务器恢复正常，它会立即抢占回 Master 角色，重新接管工作。</span><br><span class="line"></span><br><span class="line">优缺点</span><br><span class="line">快速恢复：主服务器恢复后能迅速重新承担主要工作，确保服务的连续性和稳定性。</span><br><span class="line">    资源利用高效：高优先级的服务器能及时获取控制权，充分发挥其性能优势。</span><br><span class="line">缺点：</span><br><span class="line"> 频繁的抢占可能会导致网络抖动或服务短暂中断，对一些对稳定性要求极高的服务可能产生一定影响。</span><br><span class="line"> </span><br><span class="line">适用场景</span><br><span class="line">适用于对主服务器性能要求较高，且能容忍短暂服务中断的场景，如一些非关键业务的负载均衡场景。</span><br><span class="line"></span><br><span class="line">非抢占式</span><br><span class="line">工作原理</span><br><span class="line">在非抢占式模式下，当主服务器出现故障时，备份服务器会接管成为 Master 状态。即使主服务器恢复正常，它也不会主动抢占 Master 角色，而是继续由备份服务器提供服务，直到备份服务器出现故障或其他异常情况，主服务器才会再次成为 Master。</span><br><span class="line"></span><br><span class="line">优缺点</span><br><span class="line">优点</span><br><span class="line">    稳定性高：避免了频繁抢占带来的网络抖动和服务中断风险，能保持服务的稳定运行。</span><br><span class="line">    减少切换次数：减少了服务器角色的切换频率，有利于延长服务器硬件的使用寿命。</span><br><span class="line">缺点：</span><br><span class="line">    主服务器恢复后不能及时发挥作用，可能造成资源浪费，特别是当主服务器性能远高于备份服务器</span><br><span class="line">    </span><br><span class="line">适用场景</span><br><span class="line">  适用于对服务稳定性要求极高，不容许有任何短暂中断的关键业务场景，如金融交易系统、大型数据库系统等。</span><br></pre></td></tr></table></figure>

<h4 id="非抢占模式"><a href="#非抢占模式" class="headerlink" title="非抢占模式"></a>非抢占模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：要关闭 VIP抢占，必须将各 Keepalived 服务器 state 配置为 BACKUP</span><br></pre></td></tr></table></figure>

<h4 id="nopreempt-属性解析"><a href="#nopreempt-属性解析" class="headerlink" title="nopreempt****属性解析"></a><strong>nopreempt****属性解析</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在 Keepalived 配置文件的 VRRP 实例部分使用nopreempt参数，就是明确将该 VRRP 实例设置为非抢占式模式。在这种模式下，如果主服务器（具有较高优先级的设备）出现故障，备份服务器会接管并承担起主服务器的工作，转变为 Master 状态来提供服务。</span><br><span class="line"> 当原本的主服务器恢复正常后，由于nopreempt的设置，它不会主动抢占回 Master 角色，而是继续让备份服务器（当前的 Master）提供服务，直到备份服务器出现故障或其他异常情况，原主服务器才会再次成为 Master。</span><br><span class="line"> nopreempt的主要目的是为了保持服务的稳定性和连续性，避免由于主服务器的频繁恢复和抢占导致的</span><br><span class="line">服务中断和网络抖动。</span><br><span class="line"> 应用场景</span><br><span class="line">nopreempt通常应用于对服务连续性和稳定性要求极高的场景，如金融交易系统、大型数据库系统、电信核心网等关键业务领域。在这些场景中，任何短暂的服务中断都可能导致严重的后果，因此采用非抢占式模式可以确保在主服务器故障恢复后，不会因为抢占操作而引发潜在的服务中断风险，从而保障业务的稳定运行。 </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="非抢占延迟模式"><a href="#非抢占延迟模式" class="headerlink" title="非抢占延迟模式"></a>非抢占延迟模式</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">工作原理</span><br><span class="line">在非抢占延时模式下，当主服务器出现故障时，备份服务器会在等待一个特定的延时时间后，才会接管成为 Master 状态来提供服务。</span><br><span class="line"> 同样，当主服务器恢复正常后，它也不会立即抢占 Master 角色，而是要等待一段预先设置好的延时时间，确认当前的 Master（即原备份服务器）确实出现异常或故障，或者经过延时后网络状况等条件满足切换要求，才会重新成为 Master。这个延时时间可以通过配置参数来设定，一般以秒为单位。</span><br><span class="line"> </span><br><span class="line">优缺点</span><br><span class="line">优点:</span><br><span class="line">    增强稳定性：进一步减少了不必要的切换操作，避免因网络瞬间波动或主服务器短暂故障恢复等情况导致的频繁切换，使系统更加稳定。</span><br><span class="line">    避免资源浪费：可以防止备份服务器在主服务器只是短暂故障，很快就能恢复的情况下，不必要地接管服务，从而避免了资源的浪费和可能出现的服务质量下降。</span><br><span class="line">缺点:</span><br><span class="line">    响应速度相对较慢：由于增加了延时等待，在主服务器出现故障时，备份服务器不能立即接管服务，可能会导致服务中断时间相对较长。</span><br><span class="line">    配置复杂：需要合理设置延时时间，若设置不当，可能无法达到预期效果，甚至可能影响系统的正常运行。</span><br><span class="line">    </span><br><span class="line">适用场景</span><br><span class="line">适用于对稳定性要求极高，且能容忍一定服务中断时间的场景。例如大型数据中心的核心服务，数据同步和一致性要求很高，不希望因为偶尔的网络波动或服务器小故障就进行切换，通过设置非抢占延时模式，可以在确保服务稳定的前提下，减少不必要的切换带来的风险和数据不一致问题。还有一些工业控制系统，对可靠性要求高，但对实时性要求不是特别苛刻，也可以采用这种模式来保证系统的稳定运行。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="消息传播"><a href="#消息传播" class="headerlink" title="消息传播"></a>消息传播</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">单播和多播</span><br><span class="line">单播：</span><br><span class="line"> 是一种点到点的通信方式，数据从发送方发送到特定的一个接收方。就像打电话时，通话双方是一对一的关系，信息只在这两者之间传递。</span><br><span class="line">多播：</span><br><span class="line"> 是一种点到多点的通信方式，数据从发送方发送到一组特定的接收方，这些接收方构成一个多播组。类似于在一个群组通话中，说话者的声音可以同时被群组中的多个成员听到。</span><br><span class="line"> </span><br><span class="line">地址类型</span><br><span class="line">单播：</span><br><span class="line"> 使用单播地址来标识网络中的单个主机。每个主机都有唯一的单播地址，如 IPv4 或 IPv6 地址，数据根据目标单播地址进行精确传输。 </span><br><span class="line">多播：</span><br><span class="line"> 使用多播地址来标识一组接收者。多播地址是一个特殊的地址范围，用于标识不同的多播组，发送到多播地址的数据会被该组内的所有成员接收。</span><br><span class="line"> </span><br><span class="line">网络资源占用</span><br><span class="line">单播：</span><br><span class="line"> 当需要向多个目标发送相同数据时，发送方需要为每个目标单独发送一份数据，会占用较多的网络带宽和服务器资源。比如服务器向 <span class="number">10</span> 个客户端发送相同的文件，就需要发送 <span class="number">10</span> 次。</span><br><span class="line">多播：</span><br><span class="line"> 发送方只需发送一份数据，网络中的路由器会根据多播组的成员信息，在必要的节点处对数据进行复制和转发，从而节省了网络带宽和服务器资源。同样是服务器向 <span class="number">10</span> 个客户端发送相同文件，采用多播只需发送一次数据。</span><br><span class="line"> </span><br><span class="line">应用场景</span><br><span class="line">单播：</span><br><span class="line"> 适用于需要一对一精确通信的场景，如远程登录、文件传输、视频点播等，这些应用需要确保数据准确无误地传输到特定的接收方。 </span><br><span class="line">多播：</span><br><span class="line"> 适用于一对多或多对多的通信场景，如在线直播、视频会议、网络游戏中的多人对战、网络电视等，这些应用需要将相同的数据同时发送给多个接收方</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://lx1me.github.io/2025/06/05/%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4Keepalived/" data-id="cmbof5pgi000cm0v691v0acu4" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-毕业设计进度" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/05/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E8%BF%9B%E5%BA%A6/" class="article-date">
  <time class="dt-published" datetime="2025-06-05T01:52:55.098Z" itemprop="datePublished">2025-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>毕业设计进度</p>
<p>硬件模块列表</p>
<table>
<thead>
<tr>
<th>模块类型</th>
<th>型号&#x2F;名称</th>
<th>用途&#x2F;备注</th>
</tr>
</thead>
<tbody><tr>
<td>单片机</td>
<td>STM32F103C8T6</td>
<td>主控芯片</td>
</tr>
<tr>
<td>显示屏</td>
<td>OLED</td>
<td>显示传感器数据</td>
</tr>
<tr>
<td>温湿度传感器</td>
<td>DHT11</td>
<td>测量环境温度和湿度</td>
</tr>
<tr>
<td>光照传感器</td>
<td>BH1750</td>
<td>测量环境光照强度</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>烟雾传感器</td>
<td>MQ-2</td>
<td>检测烟雾浓度（MQ 系列）</td>
</tr>
<tr>
<td>蜂鸣器</td>
<td>蜂鸣器（有源&#x2F;无源蜂鸣器）</td>
<td>报警提示</td>
</tr>
<tr>
<td>WS2812 灯带</td>
<td>WS2812</td>
<td>可编程 LED 灯带，用于灯光效果展示</td>
</tr>
<tr>
<td>风扇</td>
<td>直流风扇 &#x2F; PWM 控制风扇</td>
<td>散热、环境通风</td>
</tr>
<tr>
<td>人体红外传感器</td>
<td>HC-SR501</td>
<td>人体运动检测，用于安防报警或智能家居控制</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>针脚连接图(目前完成的模块)</p>
<p><img src="E:\biji\image\image-20250320142606305.png" alt="image-20250320142606305"></p>
<p><img src="E:\biji\image\image-20250320143804526.png" alt="image-20250320143804526"></p>
<p><img src="E:\biji\image\image-20250320143822241.png" alt="image-20250320143822241"></p>
<p>目前完成了温湿度传感器  烟雾传感器  人体检测传感器  光照传感器的连接和代码编译  将读数显示在oled模块上</p>
<p>编译代码主函数截图</p>
<p><img src="E:\biji\image\image-20250320142746091.png" alt="image-20250320142746091"></p>
<p><img src="E:\biji\image\image-20250320142754074.png" alt="image-20250320142754074"></p>
<p>下来的阶段 我将加入 蜂鸣器  风扇 灯带   整合起来 完成我的毕业设计</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lx1me.github.io/2025/06/05/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E8%BF%9B%E5%BA%A6/" data-id="cmbof5pgd0009m0v6grid3k50" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-版本管理系统 Git 和 GitLab" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/05/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%20Git%20%E5%92%8C%20GitLab/" class="article-date">
  <time class="dt-published" datetime="2025-06-05T01:52:55.093Z" itemprop="datePublished">2025-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="版本管理系统-Git-和-GitLab"><a href="#版本管理系统-Git-和-GitLab" class="headerlink" title="版本管理系统 Git 和 GitLab"></a>版本管理系统 Git 和 GitLab</h1><h3 id="DevOps-简介"><a href="#DevOps-简介" class="headerlink" title="DevOps 简介"></a>DevOps 简介</h3><h4 id="软件开发生命周期"><a href="#软件开发生命周期" class="headerlink" title="软件开发生命周期"></a>软件开发生命周期</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">软件开发生命周期SDLC (Software Development Life Cycle)由计划,分析,设计,实现,测试集成和维护组成</span><br><span class="line"></span><br><span class="line">阶段<span class="number">1</span>: 计划和需求分析 (Planning and Requirement Analysis)</span><br><span class="line">每个软件开发生命周期模型都从分析开始，过程的利益相关者讨论对最终产品的要求。此阶段的目标是系统要求的详细定义。此外，还需要确保所有流程参与者都清楚地了解任务以及每个需求将如何实施。通常，讨论涉及质量保证专家，如果有必要，他们甚至可以在开发阶段干预过程中的添加。</span><br><span class="line"></span><br><span class="line">阶段<span class="number">2</span>: 设计项目架构 (Project Architecture)</span><br><span class="line">在软件开发生命周期的第二阶段，开发人员实际上正在设计架构。所有利益相关者（包括客户）都会讨论此阶段可能出现的所有不同技术问题。此外，还定义了项目中使用的技术，团队负载，限制，时间范围和预算。最合适的项目决策是根据定义的要求做出的。</span><br><span class="line"></span><br><span class="line">阶段<span class="number">3</span>: 开发和编程 (Development and Coding)</span><br><span class="line">在批准要求后，该过程进入下一阶段 - 实际开发。程序员从这里开始编写源代码，同时牢记先前定义的需求。系统管理员调整软件环境，前端程序员开发程序的用户界面以及与服务器交互的逻辑。编程本身一般会用四个阶段:算法开发,源代码编写,编译,测试和调试</span><br><span class="line"></span><br><span class="line">阶段<span class="number">4</span>: 测试 (Testing)</span><br><span class="line">测试阶段包括调试过程。开发过程中遗漏的所有代码缺陷都会在此处检测到，记录下来并传回给开发人员进行修复。重复测试过程，直到删除所有关键问题并且软件工作流程稳定。</span><br><span class="line"></span><br><span class="line">阶段<span class="number">5</span>: 部署 (Deployment)</span><br><span class="line">当程序最终确定并且没有关键问题时 - 是时候为最终用户启动它了。新程序版本发布后，技术支持团队加入。该部门提供用户反馈; 在利用期间咨询和支持用户。此外，此阶段还包括所选组件的更新，以确保软件是最新的，并且不会受到安全漏洞的影响。</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250419091050092.png" alt="image-20250419091050092"></p>
<h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">该SDLC模型包括完全逐步执行每个阶段。该过程严格记录并预定义，具有该软件开发生命周期模型的每个阶段所期望的功能。</span><br><span class="line">类似工厂中流水线的传送带，加工的产品只能按照一道一道的工序向下不断前进，不能后退。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250419091231420.png" alt="image-20250419091231420"></p>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>简单易用和理解</td>
<td>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量</td>
</tr>
<tr>
<td>当前一阶段完成后，只需要去关注后续阶段</td>
<td>由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发风险</td>
</tr>
<tr>
<td>为项目提供了按阶段划分的检查节点</td>
<td>不适应用户需求的变化</td>
</tr>
</tbody></table>
<h4 id="V-形模型"><a href="#V-形模型" class="headerlink" title="V 形模型"></a>V 形模型</h4><p><img src="E:\biji\image\image-20250419091550881.png" alt="image-20250419091550881"></p>
<h4 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Agile Model 敏捷开发的核心是迭代开发(lterative Development)与增量(IncrementalDevelopment) </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250419091508872.png" alt="image-20250419091508872"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">迭代开发:</span><br><span class="line">对于大型软件项目，传统的开发方式是采用一个大周期(比如一年或数年)进行开发，整个过程就是一次<span class="string">&quot;大开发&quot;</span></span><br><span class="line">迭代开发的方式则不一样，它将开发过程拆分成多个小周期，即一次<span class="string">&quot;大开发&quot;</span>变成多次<span class="string">&quot;小开发&quot;</span>，每次小开发都是同样的流程，所以看上去就好像重复在做同样的步骤</span><br><span class="line"></span><br><span class="line">增量开发:</span><br><span class="line">软件的每个版本，都会新增一个可以被用户感知到的完整功能。也就是说，按照新增功能来划分迭代。</span><br></pre></td></tr></table></figure>

<h4 id="DevOps-介绍"><a href="#DevOps-介绍" class="headerlink" title="DevOps 介绍"></a>DevOps 介绍</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DevOps 即开发 Development 和 Operations运维的缩写。</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250419091807419.png" alt="image-20250419091807419"></p>
<h4 id="持续集成、持续交付和持续部署-CICD"><a href="#持续集成、持续交付和持续部署-CICD" class="headerlink" title="持续集成、持续交付和持续部署 CICD"></a>持续集成、持续交付和持续部署 CICD</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">持续集成 (CI<span class="literal">-Continuous</span> Integration)</span><br><span class="line">持续集成是指多名开发者在开发不同功能代码的过程当中，可以频繁的将代码行合并到一起并切相互不影响工作。很多情况下每天都要进行几次，主要目的是尽早发现集成错误，使团队更加紧密结合，更好地协作。</span><br><span class="line">持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试。</span><br><span class="line"></span><br><span class="line">持续交付(<span class="built_in">CD</span><span class="literal">-Continuous</span> Delivery)</span><br><span class="line">持续交付的目标是拥有一个可随时部署到生产环境的代码库。</span><br><span class="line">持续交付完成了构建和测试过程细致的自动化，但是如何发布以及发布什么仍然是需要人工操作，持续部署可以改变这一点。</span><br><span class="line"></span><br><span class="line">持续部署(<span class="built_in">CD</span><span class="literal">-Continuous</span> Deployment)</span><br><span class="line">持续部署可以自动将应用发布到生产环境</span><br></pre></td></tr></table></figure>

<h4 id="版本控制系统-VCS"><a href="#版本控制系统-VCS" class="headerlink" title="版本控制系统 VCS"></a>版本控制系统 VCS</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">版本控制（Version control）是维护工程蓝图的标准做法，能追踪工程蓝图从诞生一直到定案的过程</span><br><span class="line">版本控制也是一种软件工程技巧，借此能在软件开发的过程中，确保由不同人所编辑的同一程序文件都得到同步</span><br><span class="line">软件工程师常利用版本控制来跟踪、维护原始码、文档以及配置文件等的改动</span><br><span class="line"></span><br><span class="line">软件版本控制的方法</span><br><span class="line">最简单的情况下，软件设计师可以自己保留一个程序的许多不同版本，并且为它们做适当的编号</span><br><span class="line">这种简单的方法曾被用在很多大型的软件项目中</span><br><span class="line">虽然可行，但效率较低</span><br><span class="line">必须同时维护很多几乎一样的原始码备份，而且极度依赖软件设计师的自我修养与开发纪律</span><br><span class="line">使用版本控制系统（Version Control System，VCS），实现部分或全部版本控制工作的自动化，版本控制系统是一种软件，可以帮助软件团队的开发人员协同工作，并存档他们工作的完整历史记录。</span><br><span class="line"></span><br><span class="line">为什么使用 VCS ?</span><br><span class="line">在实际开发过程中，经常会有这种需求或问题</span><br><span class="line">代码可能被破坏,比如误删除等,希望还能找回</span><br><span class="line">代码出现了严重的Bug,希望回滚至数周前的旧代码</span><br><span class="line">需要在已经发布的程序中添加新的功能，如果测试验证后没有问题，才会使用新的代码，而在测试验证期间，不能影响原来的代码</span><br><span class="line">同一个软件需要有多个版本并行开发,满足不同的应用需求</span><br><span class="line">实际项目开发基本都是多个人合作完成，在多个人同时修改同一个源代码文件时可能会发生冲突，如何跟踪记录这些冲突</span><br><span class="line">异地源代码备份，使用 VCS 时，需要创建一个 VCS 的远程实例，以在开发人员之间共享更改，这个远程 VCS 实例可以由值得信赖的第三方（如GitHub）进行异地托管；然后，它就会成为安全的异地备份</span><br></pre></td></tr></table></figure>

<h4 id="版本控制系统分类"><a href="#版本控制系统分类" class="headerlink" title="版本控制系统分类"></a>版本控制系统分类</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本地版本(单机版)控制系统</span><br><span class="line">第一代版本控制系统被称为本地版本控制系统。通过加锁将并发执行转换成顺序执行。 一次只能有一个人处理文件。</span><br></pre></td></tr></table></figure>

<h6 id="集中式版本控制系统"><a href="#集中式版本控制系统" class="headerlink" title="集中式版本控制系统"></a>集中式版本控制系统</h6><p><img src="E:\biji\image\image-20250419100744098.png" alt="image-20250419100744098"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">想要完成任何提交和回滚都依赖于连接集中的代码服务器才能实现,如果无法连接至代码的服务器,比如下班回家后将无法提交代码</span><br><span class="line">此外此集中式服务器还存在单点问题，在集中式实例的不可用期间，开发人员就无法推送、合并或回滚代码</span><br><span class="line">此方式可以更好的实现软件仓库的安全访问限制和控制</span><br></pre></td></tr></table></figure>

<h6 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h6><p><img src="E:\biji\image\image-20250419101327917.png" alt="image-20250419101327917"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在每个用户都有一个完整的服务器，用于保存软件的完整版本，然后再部署一个中央服务器用户可以先将代码提交到本地，没有网络也可以先提交到本地，然后在有网络的时候再提交到中央服务器，这样就大大方便了开发者</span><br><span class="line">相比集中式的版本控制系统，工作的时候需要先从中央服务器获取最新的代码，改完之后需要提交，如果是一个比较大的文件则需要足够快的网络才能快速提交完成</span><br><span class="line">而使用分布式的版本控制系统，每个用户都是一个完整的版本库，即使没有中央服务器也可以提交代码或者回滚，最终再把改好的代码提交至中央服务器进行合并即可。</span><br><span class="line">此方式不容易实现软件仓库的安全访问限制和控制 </span><br></pre></td></tr></table></figure>

<h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git 重要特性:</span><br><span class="line">在本地就可以完成提交,因此不需要网络,提交完成后,可以有网络环境时,再同步到远程仓库服务器</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>适合分布式开发，强调个体</td>
<td>不符合常规思维</td>
</tr>
<tr>
<td>公共服务器压力和数据量都不会太大</td>
<td>学习难度大，学习周期相对较长</td>
</tr>
<tr>
<td>速度快、灵活</td>
<td>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息</td>
</tr>
<tr>
<td>任意两个开发者之间可以很容易地解决冲突</td>
<td>无力支持大型二进制文件</td>
</tr>
<tr>
<td>支持离线工作</td>
<td>具有大量历史记录的超大型存储库会降低交互速度</td>
</tr>
</tbody></table>
<p>GitLab 网站和软件</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GitLab 官方网站: https://about.gitlab.com/</span><br><span class="line"></span><br><span class="line">Gitlab 的优势</span><br><span class="line">开源免费，搭建简单、维护成本较低、可适用于中小型公司内部项目使用。</span><br><span class="line">权限管理功能强大灵活，能实现代码对部分人可见，确保项目的安全性。</span><br><span class="line">支持离线提交，基于git实现,可以不在实时依赖网络环境进行代码提交。</span><br></pre></td></tr></table></figure>

<h4 id="常见的软件部署模式"><a href="#常见的软件部署模式" class="headerlink" title="常见的软件部署模式"></a>常见的软件部署模式</h4><h6 id="蓝绿部署-Blue-green-Deployments"><a href="#蓝绿部署-Blue-green-Deployments" class="headerlink" title="蓝绿部署 Blue-green Deployments"></a>蓝绿部署 Blue-green Deployments</h6><p><img src="E:\biji\image\image-20250419101906101.png" alt="image-20250419101906101"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">蓝绿部署指的是不停止老版本代码(不影响上一个版本访问)，而是在另外一套环境部署新版本然后进行测试，测试通过后将用户流量切到新版本，其特点为业务无中断，升级风险相对较小。但本方式成本较高,一般小公司较少使用</span><br><span class="line"></span><br><span class="line">蓝绿色部署是一种部署策略，利用两种相同的环境，即<span class="string">&quot;蓝色&quot;</span>（又名预发布）环境和<span class="string">&quot;绿色&quot;</span>（又名生产）环境，具有不同版本的应用程序或服务。质量保证和用户接受度测试通常在承载新版本或更改的蓝色环境中进行。一旦蓝色环境中测试并接受新的变化，用户流量就会从绿色环境切换为蓝色环境。然后，一旦部署成功，您可以切换到新环境。</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">具体过程：</span><br><span class="line"><span class="number">1</span>、当前版本(V1)业务正常访问</span><br><span class="line"><span class="number">2</span>、在另外一套环境部署新代码版本(V2)，代码可能是增加了功能或者是修复了某些bug</span><br><span class="line"><span class="number">3</span>、测试通过之后将用户请求流量切到新版本环境</span><br><span class="line"><span class="number">4</span>、观察一段时间，如有异常直接切换旧版本</span><br><span class="line"><span class="number">5</span>、下次升级，将旧版本(V2)升级到新版本(V3)</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">蓝绿部署适用的场景：</span><br><span class="line"><span class="number">1</span>、不停止老版本，额外部署一套新版本，等测试确认新版本正常后，才将用户请求切换至新版本，如果有问题，切换回老版本</span><br><span class="line"><span class="number">2</span>、蓝绿发布是一种用于升级与更新的发布策略，部署的最小维度是容器，而发布的最小维度是应用。</span><br><span class="line"><span class="number">3</span>、蓝绿发布对于增量升级有比较好的支持，但是对于涉及数据表结构变更等等不可逆转的升级，并不完全合适用蓝绿发布来实现，需要结合一些业务的逻辑以及数据迁移与回滚的策略才可以完全满足需求。</span><br></pre></td></tr></table></figure>

<h6 id="金丝雀-灰度-发布-Canary-Deployment"><a href="#金丝雀-灰度-发布-Canary-Deployment" class="headerlink" title="金丝雀(灰度)发布 Canary Deployment"></a>金丝雀(灰度)发布 Canary Deployment</h6><p><img src="E:\biji\image\image-20250419102239034.png" alt="image-20250419102239034"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">金丝雀发布也叫灰度发布，是指在黑与白之间，能够平滑过渡的一种发布方式，灰度发布是增量发布（例如：<span class="number">2</span>%、<span class="number">25</span>%、<span class="number">75</span>%、<span class="number">100</span>%）进行更新)的一种类型，灰度发布是在原有版本可用的情况下，同时部署一个新版本应用作为“金丝雀”(小白鼠)，测试新版本的性能和表现，以保障整体系统稳定的情况下，尽早发现、调整问题。因此，灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</span><br><span class="line">此方式在实际生产中使用较为普遍</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">金丝雀/灰度发布步骤组成：</span><br><span class="line"><span class="number">1</span>、准备好部署各个阶段的工件，包括：构建组件，测试脚本，配置文件和部署清单文件。</span><br><span class="line"><span class="number">2</span>、从负载均衡列表中移除掉“金丝雀”服务器（选择全部服务器中的一部分）。</span><br><span class="line"><span class="number">3</span>、升级“金丝雀”应用（排掉原有流量并进行部署）。</span><br><span class="line"><span class="number">4</span>、对应用进行自动化测试。</span><br><span class="line"><span class="number">5</span>、将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）。</span><br><span class="line"><span class="number">6</span>、如果“金丝雀”在线使用测试成功，升级剩余的其他服务器。否则就回滚回旧版本</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">金丝雀/灰度发布部署适用的场景：</span><br><span class="line"><span class="number">1</span>、不停止老版本，额外搞一套新版本，不同版本应用共存。</span><br><span class="line"><span class="number">2</span>、灰度发布中，常常按照用户设置路由权重，例如<span class="number">90</span>%的用户维持使用老版本，<span class="number">10</span>%的用户尝鲜新版本。</span><br><span class="line"><span class="number">3</span>、经常与A/B测试一起使用，用于测试选择多种方案。</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">灰度发布可以在发布新版本应用时:</span><br><span class="line">自定义控制新版本应用流量比重</span><br><span class="line">渐进式完成新版本应用的全量上线</span><br><span class="line">最大限度地控制新版本发布带来的业务风险</span><br><span class="line">降低故障带来的影响</span><br><span class="line">同时支持快速回滚</span><br></pre></td></tr></table></figure>

<h6 id="滚动发布-更新"><a href="#滚动发布-更新" class="headerlink" title="滚动发布(更新)"></a>滚动发布(更新)</h6><p><img src="E:\biji\image\image-20250419102419650.png" alt="image-20250419102419650"></p>
<p>红色：正在更新的实例，正在升级过程中间状态<br>蓝色：更新完成并加入集群的实例,升级完成的新版本<br>绿色：正在运行的实例，升级前的旧版本</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">滚动发布即逐步升级服务中的节点</span><br><span class="line">滚动发布是指每次只升级一个或多个服务实例，升级完成后加入生产环境，不断执行这个过程，直到集群中的全部旧版本升级新版本。</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">滚动发布过程</span><br><span class="line"><span class="number">1</span>. 先升级<span class="number">1</span>个服务实例，主要做部署验证</span><br><span class="line"><span class="number">2</span>. 每次升级<span class="number">1</span>个服务实例，自动从LB上摘掉，升级成功后自动加入集群</span><br><span class="line"><span class="number">3</span>. 事先需要有自动更新策略，分为若干次，每次数量/百分比可配置</span><br><span class="line"><span class="number">4</span>. 回滚是发布的逆过程，先从LB摘掉新版本，再升级老版本，这个过程一般时间比较长</span><br><span class="line"><span class="number">5</span>. 自动化要求高</span><br></pre></td></tr></table></figure>

<h6 id="A-B测试-A-B-Testing"><a href="#A-B测试-A-B-Testing" class="headerlink" title="A&#x2F;B测试 A&#x2F;B Testing"></a>A&#x2F;B测试 A&#x2F;B Testing</h6><p><img src="E:\biji\image\image-20250419102554252.png" alt="image-20250419102554252"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A/B测试即同时对外提供两个APP运行环境，这和蓝绿部署的同时只有一个版本在线是不同的</span><br><span class="line">A/B 测试是用来测试应用功能表现的方法，例如可用性、受欢迎程度、可见性等等</span><br><span class="line">蓝绿部署和A/B测试是不同的,蓝绿部署的目的是安全稳定地发布新版本应用，并在必要时回滚</span><br><span class="line">即蓝绿部署是同一时间只有一套正式环境在线，而A/B测试是两套正式环境同时在线，一般用于多个产品竟争时使用</span><br></pre></td></tr></table></figure>

<h4 id="版本控制系统-Git"><a href="#版本控制系统-Git" class="headerlink" title="版本控制系统 Git"></a>版本控制系统 Git</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="Git-相关概念和原理"><a href="#Git-相关概念和原理" class="headerlink" title="Git 相关概念和原理"></a>Git 相关概念和原理</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git 的数据存储从物理上分为当前项目目录和当前项目目录下的隐藏子目录.git，分别称为工作区和版本库</span><br><span class="line">Git 版本库逻辑上又分为暂存区和本地仓库</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250419113319864.png" alt="image-20250419113319864"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">工作区 Workspace：</span><br><span class="line">工作区是你当前正在编辑和修改文件的地方。它是你的项目目录 ，通常是对应于&lt;项目目录&gt;在这里你可以添加、修改或删除文件。工作区中的文件可以是已被Git跟踪的文件，也可以是未被跟踪的文件。</span><br><span class="line">工作区中的文件的变更不受Git的跟踪和管理，无法实现版本回滚等功能</span><br><span class="line">需要将工作的的变更，通过 git add 命令加入暂存区后，才可纳入Git 的版本管理控制的范畴</span><br><span class="line"></span><br><span class="line">暂存区 Staging Area/Index/Cached：</span><br><span class="line">也称为索引区,缓存区，用于存储在工作区中对代码进行修改后的文件所保存的地方，只有放入此区的文件才能被git进行管理,使用 git add添加,对应为&lt;项目目录&gt;/.git/index文件</span><br><span class="line">暂存区主要用于临时保存文件少量变更，类似于邮件中的草稿箱</span><br><span class="line">当变更累积到一定阶段，希望生成里程碑式的结果时，会使用commit，将暂存区的变更一次性的批量提交到本地仓库</span><br><span class="line"></span><br><span class="line">本地仓库 Local Repository：</span><br><span class="line">用于存储在工作区和暂存区中改过并提交的文件地方，使用 git commit 提交,对应于/&lt;项目目录&gt;/.git/</span><br><span class="line">每一次commit 会生成一个唯一的ID，通常用于表示一个阶段性的新的版本</span><br><span class="line">checkout命令执行了同commit命令相反的操作，它将版本中存储的commit所代表着的某个版本恢复至工作区中</span><br><span class="line">checkout命令完成后，工作区中的文件内容与其检出的提交那一刻的状态相同</span><br><span class="line">若工作区中存储此前未被提交的新文件，这些文件的未被提交的新的更改会被存储仓库的旧内容覆盖</span><br><span class="line">当然，用户也可以暂存这些新文件，并将带有新文件的工作区提交到版本库中，这将是新的暂存和提交循环</span><br><span class="line"></span><br><span class="line">远程仓库 Remote Repository ：</span><br><span class="line">多个开发人员共同协作提交代码的仓库，即私有 gitlab 服务器或公有云github,gitee网站等</span><br><span class="line">利用远程仓库，可以实现异地备份和远程协作</span><br></pre></td></tr></table></figure>

<p><img src="E:\biji\image\image-20250419135734948.png" alt="image-20250419135734948"></p>
<h4 id="Git-文件的状态变化周期"><a href="#Git-文件的状态变化周期" class="headerlink" title="Git 文件的状态变化周期"></a>Git 文件的状态变化周期</h4><p><img src="E:\biji\image\image-20250419135803736.png" alt="image-20250419135803736"></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">untracked: 在工作目录下创建的新文件，这个时候本地git仓库不知道,不能对其进行版本跟踪管理</span><br><span class="line">unmodified: 添加到暂存区的文件未修改,把文件从暂存区推动到本地仓库</span><br><span class="line">modified: 已经添加到暂存区的文件,在本地工作区的文件被修改了 ,需要重新添加至暂存区</span><br><span class="line">staged: 文件添加到了暂存区</span><br><span class="line">unstaged: 已被跟踪的工作区的文件发生更新，但还没有存入暂存区中</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://lx1me.github.io/2025/06/05/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%20Git%20%E5%92%8C%20GitLab/" data-id="cmbof5pge000am0v6cfyh4mpq" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL 数据库-1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/05/MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93-1/" class="article-date">
  <time class="dt-published" datetime="2025-06-05T01:52:55.088Z" itemprop="datePublished">2025-06-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL-数据库-1"><a href="#MySQL-数据库-1" class="headerlink" title="MySQL 数据库-1"></a><strong>MySQL</strong> <strong>数据库</strong>-1</h1><h2 id="MySQL-架构和性能优化"><a href="#MySQL-架构和性能优化" class="headerlink" title="MySQL 架构和性能优化"></a><strong>MySQL</strong> <strong>架构和性能优化</strong></h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">mysql的查询过程</span><br><span class="line"><span class="number">1</span> 客户端发送查询请求：</span><br><span class="line">  用户通过客户端（如命令行工具、数据库管理工具等）发送SQL查询语句到MySQL服务器。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 服务器接收并处理连接：</span><br><span class="line">  MySQL服务器通过连接器接收客户端的连接请求，并进行身份认证和权限验证。</span><br><span class="line">  如果验证成功，服务器为客户端分配一个独立的线程来处理后续的查询请求。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> 查询缓存（MySQL <span class="number">8.0</span>后已移除该功能）：</span><br><span class="line">  在早期版本的MySQL中，服务器会检查查询缓存，看是否存在已经执行过且结果未过期的相同查询。</span><br><span class="line">  如果缓存命中，则直接返回缓存的结果，跳过后续的解析和执行步骤。</span><br><span class="line">注意：</span><br><span class="line">  由于查询缓存的局限性（如更新操作会导致缓存失效），在MySQL <span class="number">8.0</span>及以后版本中，查询缓存功能已被移除。</span><br><span class="line"> 原因：</span><br><span class="line">  维护成本高：在早期版本中，每当数据发生变化，如执行插入、更新或删除操作时，相关的查询缓存就可能会失效，需要进行清理或更新。随着数据量和更新频率的增加，这种维护操作的开销会变得非常大，甚至可能超过查询缓存带来的性能提升。</span><br><span class="line">  缓存命中率不稳定：查询缓存的效果依赖于查询的重复性和数据的稳定性。在实际应用中，如果查询语句变化多样，或者数据更新频繁，查询缓存的命中率可能会很低，导致查询缓存占用了内存资源却不能有效提高性能。</span><br><span class="line">  内存管理复杂：管理查询缓存需要额外的内存空间，并且要解决内存碎片等问题。在高并发环境下，内存管理的复杂性会进一步增加，可能导致性能问题和内存泄漏等风险。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span> SQL解析：</span><br><span class="line">    服务器对接收到的SQL查询语句进行解析，生成解析树（或称为语法树）。</span><br><span class="line">    解析过程包括词法分析和语法分析，确保SQL语句的语法正确，并识别出SQL语句中的关键字、表名、列名等。</span><br><span class="line">    随后进行语义分析，检查表名、列名是否存在，以及用户是否有相应的权限。</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> 查询优化optimizer：</span><br><span class="line">    优化器对解析后的查询语句进行优化，生成最优的执行计划。</span><br><span class="line">    优化过程包括选择最佳的索引、确定表的连接顺序、重写查询等，以提高查询效率。</span><br><span class="line">    优化器会计算不同执行计划的预测成本值，并选择成本最小的计划作为最终执行计划。</span><br><span class="line"></span><br><span class="line"><span class="number">6</span> 执行计划生成：</span><br><span class="line">    根据优化器生成的执行计划，服务器确定具体的查询执行步骤。</span><br><span class="line">    执行计划包括选择索引、读取顺序、数据过滤、排序、聚合等操作。</span><br><span class="line"></span><br><span class="line"><span class="number">7</span> 执行查询并返回结果：</span><br><span class="line">    执行器根据执行计划调用存储引擎的API来执行查询操作。</span><br><span class="line">    存储引擎负责具体的数据存储和读取操作，根据执行计划读取数据并返回给执行器。</span><br><span class="line">    执行器对读取到的数据进行处理（如过滤、排序、聚合等），然后生成结果集。</span><br><span class="line"></span><br><span class="line">最终，服务器将处理后的结果集返回给客户端。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="mysql组件"><a href="#mysql组件" class="headerlink" title="mysql组件"></a>mysql组件</h2><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">连接器对  Native，JDBC，ODBC，NET，PHP，Perl，Python，Ruby，Cobol 等客户端工具或编程语言的 API 对MySQL 的连接功能进行管理。连接器是 Server 端的第一个模块。</span><br><span class="line"> 每种编程语言软件几乎都有适合自己的连接器软件插件。</span><br></pre></td></tr></table></figure>



<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MySQL的线程池是一种重要的技术，旨在提高数据库的性能和资源利用效率。</span><br><span class="line">作用</span><br><span class="line">MySQL的线程池在提高资源利用效率、减少线程创建和销毁的开销、实现负载均衡以及提高并发处理能力等方面发挥着重要作用。它是数据库性能优化的重要手段之一，特别适用于高并发环境下的数据库访问。同时，线程池还可以与连接池结合使用，以进一步提高数据库性能。</span><br><span class="line"><span class="number">1</span> 资源复用：</span><br><span class="line">    线程池复用线程，减少了线程的创建和销毁开销。</span><br><span class="line">    连接池复用连接，减少了连接的创建和销毁开销。</span><br><span class="line"><span class="number">2</span> 提高并发处理能力：</span><br><span class="line">    线程池可以处理多个并发请求，而不需要为每个请求创建新的线程。</span><br><span class="line">    连接池可以管理多个数据库连接，确保在高并发情况下，应用程序能够迅速获取到数据库连接。</span><br><span class="line"><span class="number">3</span> 优化资源分配：</span><br><span class="line"> 通过线程池和连接池的结合使用，可以更合理地分配系统资源。例如，可以根据系统的负载情况动态调整线程池和连接池的大小，以平衡性能和资源利用率。</span><br><span class="line"><span class="number">4</span> 简化管理：</span><br><span class="line"> 线程池和连接池都提供了对资源和连接的管理功能，使得开发人员可以更加专注于业务逻辑的实现，而不需要过多关注底层资源的管理。</span><br></pre></td></tr></table></figure>

<h4 id="SQL语句解析"><a href="#SQL语句解析" class="headerlink" title="SQL语句解析"></a>SQL语句解析</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SQL Interface：SQL 语句接口</span><br><span class="line">  完整的 sql 命令的解释器，对 SQL 语句进行检查，是否有错误，并且进行词法分析，语法分析，识别出具体操作，对象，参数等。 </span><br><span class="line"></span><br><span class="line">Parser：查询解析器 </span><br><span class="line">  解析器会根据己经检查过的SQL语句生成一个数据结构，一般是树形结构，我们称其为解析树。在这个过程中也会校验当前连接的客户端是否有权限操作库和表等。</span><br><span class="line">  在 MySQL 中，语法树（Syntax Tree），更准确地说是抽象语法树（Abstract Syntax Tree，AST），是对 SQL 语句进行解析后得到的一种树形结构表示.</span><br><span class="line">  当你向 MySQL 服务器发送一条 SQL 语句时，服务器首先会对该语句进行词法分析和语法分析。词法分析将 SQL 语句拆分成一个个的词法单元（Token），例如关键字、标识符、操作符等；语法分析则根据 SQL 的语法规则，将这些词法单元组织成一个树形结构，即抽象语法树。</span><br><span class="line"></span><br><span class="line">Optimizer：查询优化器</span><br><span class="line">  优化器可以通过分析抽象语法树来理解 SQL 语句的逻辑结构和语义，从而确定如何以最有效的方式执行查询。例如，它可以识别出哪些条件可以提前过滤数据，哪些表连接可以采用更高效的算法</span><br><span class="line">  根据解析器生成的解析树中的各个节点，生成不同的执行计划，然后决定一个最优的执行顺序路径，Mysql里面使用基于开销的优化器，哪种计划开销最小，就用哪种，从而保证在使用最少的开销的情况下返回正确的结果。</span><br><span class="line">  SQL语句在执行的时候，会先判断一下连接用户是否对特定表具有查询的权限，然后根据表的引擎定义，去使用这个引擎提供的接口。  </span><br></pre></td></tr></table></figure>

<h4 id="其它组件"><a href="#其它组件" class="headerlink" title="其它组件"></a>其它组件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存储引擎</span><br><span class="line">  存储引擎其实就是对于数据库文件的一种存取机制，如何实现存储数据，如何为存储的数据建立索引以及如何更新，查询数据等技术实现的方法。</span><br><span class="line">  MySQL 数据库中的数据，本质上来讲，是存在于硬盘上的物理文件，不同的存储引擎有不同的特性，实际上就是使用不同的技术和方式来管理文件中的数据。</span><br><span class="line">  存储引擎将存于硬盘上的物理文件，加载到内存中，然后再有上面的语句对内存中的数据，进行各种各样</span><br><span class="line">的操作。  </span><br></pre></td></tr></table></figure>

<h2 id="存储引擎-默认是InnoDB"><a href="#存储引擎-默认是InnoDB" class="headerlink" title="存储引擎(默认是InnoDB)"></a>存储引擎(默认是InnoDB)</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力，此种技术称为存储引擎，MySQL 支持多种存储引擎，其中目前应用最广泛的是 InnoDB 和 MyISAM 两种。</span><br><span class="line"></span><br><span class="line">存储引擎决定了数据如何存储在磁盘上，以及如何被访问。它提供了数据的存储机制、索引技巧、锁定水平，并最终提供不同的功能和能力。具体的数据库里面的输入，如何存储到物理的数据文件里面，是由存储引擎来实现的。</span><br><span class="line"></span><br><span class="line">在 MySQL5.<span class="number">5</span> 之后默认存储引擎是 InnoDB，在之前是 MyISAM。</span><br><span class="line"></span><br><span class="line">Mysql<span class="literal">-server</span> <span class="number">8.0</span> 默认情况下存储引擎有 <span class="number">9</span>个，Mariadb <span class="number">10</span> 默认情况下存储引擎数量有 <span class="number">11</span>个。</span><br></pre></td></tr></table></figure>

<h4 id="MyISAM-存储引擎"><a href="#MyISAM-存储引擎" class="headerlink" title="MyISAM 存储引擎"></a><strong>MyISAM</strong> <strong>存储引擎</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">MyISAM 存储引擎特点</span><br><span class="line">- 不支持事务</span><br><span class="line">- 表级锁定</span><br><span class="line">- 读写相互阻塞，写入不能读，读时不能写</span><br><span class="line">- 只缓存索引</span><br><span class="line">- 不支持外键约束</span><br><span class="line">- 不支持聚簇索引</span><br><span class="line">- 支持全文索引</span><br><span class="line">- 读取数据较快，占用资源较少</span><br><span class="line">- 不支持MVCC（多版本并发控制机制）高并发</span><br><span class="line">- 崩溃恢复性较差</span><br><span class="line">- MySQL5.<span class="number">5.5</span> 前默认的数据库引擎</span><br><span class="line"></span><br><span class="line">MyISAM 存储引擎适用场景</span><br><span class="line">- 读多写少的业务（或者只读的业务）</span><br><span class="line">- 不需要事务支持的业务（比如转账，充值这种业务就不行）</span><br><span class="line">- 并发访问低的业务</span><br><span class="line">- 对数据一致性要求不高的业务</span><br><span class="line">- 表较小（可以接受长时间进行修复操作）</span><br><span class="line"></span><br><span class="line">MyISAM 存储引擎相关文件</span><br><span class="line">- tbl_name.frm 表格式定义</span><br><span class="line">- tbl_name.sdi 表格式定义（mysql8.<span class="number">0</span>开始，但是MariaDB目前依然在使用frm）</span><br><span class="line">- tbl_name.MYD 数据文件</span><br><span class="line">- tbl_name.MYI 索引文件</span><br></pre></td></tr></table></figure>

<h4 id="InnoDB-存储引擎"><a href="#InnoDB-存储引擎" class="headerlink" title="InnoDB 存储引擎"></a><strong>InnoDB</strong> <strong>存储引擎</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">InnoDB 存储引擎特点</span><br><span class="line">- 支持事务，适合处理大量短期事务</span><br><span class="line">- 行级锁定</span><br><span class="line">- 读写阻塞与事务隔离级别相关</span><br><span class="line">- 可缓存数据和索引</span><br><span class="line">- 支持聚簇索引</span><br><span class="line">- 崩溃恢复性更好</span><br><span class="line">- 支持MVCC高并发</span><br><span class="line">- 支持表分区，支持表空间</span><br><span class="line">- 从MySQL5.<span class="number">5</span> 后支持全文索引</span><br><span class="line">- 从MySQL5.<span class="number">5.5</span> 开始为默认的数据库引擎</span><br><span class="line"></span><br><span class="line">InnoDB 存储引擎适用场景</span><br><span class="line">- 数据读写都较为频繁的业务</span><br><span class="line">- 需要事务支持的业务</span><br><span class="line">- 对并发要求较高的业务</span><br><span class="line">- 对数据一致性要求较高的业务</span><br><span class="line"></span><br><span class="line">InnoDB 存储引擎相关文件</span><br><span class="line">- tbl_name.frm 表格式定义</span><br><span class="line">- tbl_name.ibd 数据和索引文件</span><br></pre></td></tr></table></figure>





<p><strong>MySQL****中常见的存储引擎特性说明</strong></p>
<table>
<thead>
<tr>
<th>特性（Feature）</th>
<th>MyISAM 存储引擎</th>
<th>Memory 存储引擎</th>
<th>InnoDB 存储引擎</th>
<th>Archive 存储引擎</th>
<th>NDB 存储引擎</th>
</tr>
</thead>
<tbody><tr>
<td>B 树索引（B - tree indexes）</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>备份时间点恢复（Backup&#x2F;point - in - time recovery）</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>集群模式（Cluster database support）</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>聚集索引（Clustered indexes）</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>数据压缩（Compressed data）</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>数据缓存（Data caches）</td>
<td>No</td>
<td>N&#x2F;A</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>数据加密（Encrypted data）</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>外键（Foreign key support）</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>全文检索（Full - text search indexes）</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>地理空间数据类型（Geospatial data type support）</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>地理空间数据索引（Geospatial indexing support）</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>HASH 索引（Hash indexes）</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>索引缓存（Index caches）</td>
<td>Yes</td>
<td>N&#x2F;A</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>锁颗粒度（Locking granularity）</td>
<td>Table</td>
<td>Table</td>
<td>Row</td>
<td>Row</td>
<td>Row</td>
</tr>
<tr>
<td>多版本并发控制（MVCC）</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>数据同步（Replication support）</td>
<td>Yes</td>
<td>Limited</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>表空间上限（Storage limits）</td>
<td>256TB</td>
<td>RAM</td>
<td>64TB</td>
<td>None</td>
<td>384EB</td>
</tr>
<tr>
<td>T 树索引（T - tree indexes）</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>事务（Transactions）</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>元数据静态更新（Update statistics for data dictionary）</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<h4 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">锁是计算机协调多个进程或线程并发访问某一资源的机制。</span><br><span class="line">在关系型数据库中，按数据操作的颗粒度划分，分为表锁，行锁和页锁</span><br><span class="line"></span><br><span class="line">表锁：</span><br><span class="line">  表锁是 MySQL 中锁定粒度最大的一种锁，表示对当前操作的整张表加锁（哪怕只操作表里面的一行数据），它实现简单，消耗资源少，被大部份 MySQL 存储引擎支持，MyISAM 存储引擎使用表锁，表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</span><br><span class="line">  表锁的特点是开销小，加锁快，不会出现死锁，锁定颗粒度大，发生锁冲突的概率高，并发性差。</span><br><span class="line"></span><br><span class="line">行锁：</span><br><span class="line">  行锁是 MySQL 中锁定粒度最小的一种锁，表示只对当前操作的行加锁，行锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。InnoDB存储引擎默认采用行锁。</span><br><span class="line">  行锁的特点是开销大，加锁慢，会出现死锁，锁定颗粒度最小，发生锁冲突的概率最低，并发性好。</span><br></pre></td></tr></table></figure>

<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">共享表空间</span><br><span class="line">  共享表空间是指表结构文件单独放在以数据命名的文件夹中，格式为 tbl_name.frm，所有 InnoDB 引擎表的数据都放在一个文件中 (ibdata1,ibdata2,...)。</span><br><span class="line">  </span><br><span class="line">独立表空间</span><br><span class="line">  独立表空间是指用独立文件存放每个表的表结构 tbl_name.frm 和数据及索引  tbl_name.ibd，在独立表空间的前提下，共享表空间中的 ibdata 文件还是存在，独立表空间文件只存储该表的数据，索引和插入缓冲的BITMAP等信息，其它信息还是存放在共享表空间中。</span><br></pre></td></tr></table></figure>

<h4 id="表结构与数据存储的分离"><a href="#表结构与数据存储的分离" class="headerlink" title="表结构与数据存储的分离"></a>表结构与数据存储的分离</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表结构存储：</span><br><span class="line">   在 MySQL 数据库中，对于使用 InnoDB 引擎的表，其表结构文件是以.frm为后缀的，并且单独存放在以数据库名命名的文件夹中。比如有一个数据库叫mydb，里面有一张表mytable，那么mytable的表结构文件mytable.frm就会存放在mydb这个文件夹下。这种存储方式使得表结构的管理和维护相对独立，便于数据库系统快速定位和读取表的定义信息，比如表的列结构、索引结构等。</span><br><span class="line">数据存储：</span><br><span class="line">   所有 InnoDB 引擎表的数据并没有跟随各自的表结构文件分散存储，而是集中存放在ibdata1、ibdata2等这样的文件中。这意味着不同表的数据在物理存储上是聚合在一起的，形成了一个共享的空间来存储所有相关表的数据。</span><br></pre></td></tr></table></figure>

<h4 id="InnoDB-存储引擎中的-MVCC"><a href="#InnoDB-存储引擎中的-MVCC" class="headerlink" title="InnoDB 存储引擎中的 MVCC"></a><strong>InnoDB</strong> <strong>存储引擎中的</strong> <strong>MVCC</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MVCC（Multi<span class="literal">-Version</span> Concurrency Control）：多版本并发控制</span><br><span class="line">MVCC 是一种实现并发控制的方法，一般用在数据库管理系统中，实现对数据库的并发访问。</span><br><span class="line">    MVCC 使得大部份支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，而是把数据库的行锁与数据版本结合起来，只需要很小的开销，就可以实现非锁定读，从而大大提高了数据库系统的并发性能。</span><br></pre></td></tr></table></figure>

<h5 id="InnoDB-中的-MVCC"><a href="#InnoDB-中的-MVCC" class="headerlink" title="InnoDB 中的 MVCC"></a>InnoDB 中的 MVCC</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在MySQL中，使用 InnoDB 存储引擎的表，在创建时，系统会自动给表加上两个版本控制字段，这是两个隐藏列，这两个字段不显示在表结构中。</span><br><span class="line">其中一个字段保存了行的创建时间，一个保存了行的过期时间（或删除时间），（实际上存储的并不是时间，而是版本号，为了方便理解，我们认为记录的是时间）。</span><br><span class="line">当客户端要执行SQL语句时，会根据当前的时间与数据表中记录的时间进行比较，确保不会让客户端得到非法数据。</span><br></pre></td></tr></table></figure>

<h2 id="数据库服务配置"><a href="#数据库服务配置" class="headerlink" title="数据库服务配置"></a>数据库服务配置</h2><h3 id="数据库基本信息"><a href="#数据库基本信息" class="headerlink" title="数据库基本信息"></a>数据库基本信息</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql 数据库</span><br><span class="line">类似于Sql Server中的master库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。</span><br><span class="line"></span><br><span class="line">information_schema 数据库</span><br><span class="line"></span><br><span class="line">performance_schema 数据库</span><br><span class="line">主要用于收集数据库服务器性能参数，库里表的存储引擎均为PERFORMANCE_SCHEMA，用户不能创建存储引擎为 PERFORMANCE_SCHEMA 的表</span><br></pre></td></tr></table></figure>

<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="1-服务器系统变量"><a href="#1-服务器系统变量" class="headerlink" title="1 服务器系统变量"></a><strong>1</strong> <strong>服务器系统变量</strong></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">服务器系统变量分为全局变量和会话变量两种，全局变量表示可以影响到所有连接终端，所有会话，会话变量只影响当前会话。</span><br><span class="line"></span><br><span class="line">全局变量在MySQL服务器启动时被初始化，并且对所有会话都有效。全局变量的值可以被所有会话共享，并且可以通过<span class="built_in">SET</span> GLOBAL语句进行修改（需要适当的权限）。一些全局变量定义了服务器的属性、特征，例如max_connections用于限制服务器的最大连接数。</span><br><span class="line"></span><br><span class="line">会话变量是特定于当前会话（连接）的变量。每个会话都有自己的一组会话变量，这些变量的值在会话期间是有效的，并且对其他会话是不可见的。会话变量可以通过<span class="built_in">SET</span> SESSION语句或<span class="built_in">SET</span>（不带GLOBAL或SESSION关键字，默认为会话级别）语句进行修改。一些会话变量可以复制全局变量的值作为其初始值，但之后可以在会话中独立修改。</span><br><span class="line"></span><br><span class="line">全局变量：数量相对较少，因为它们定义了服务器的整体行为和属性。</span><br><span class="line">会话变量：数量可能更多，因为每个会话都可以有自己的会话变量集合，并且这些变量可以在会话期间被动态创建和修改。</span><br></pre></td></tr></table></figure>

<h4 id="查看变量"><a href="#查看变量" class="headerlink" title="查看变量"></a>查看变量</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看全局所有变量</span><br><span class="line">show global status\G</span><br><span class="line"></span><br><span class="line">查看指定变量</span><br><span class="line">show status like <span class="string">&#x27;Com_select&#x27;</span>;</span><br><span class="line"></span><br><span class="line">查看全局变量</span><br><span class="line">show global status like <span class="string">&#x27;Com_select&#x27;</span>;</span><br></pre></td></tr></table></figure>





<h4 id="会话变量修改"><a href="#会话变量修改" class="headerlink" title="会话变量修改"></a><strong>会话变量修改</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修改会话变量：仅对当前会话有影响</span><br><span class="line"><span class="built_in">SET</span> [<span class="type">SESSION</span>] system_var_name=value;</span><br><span class="line"><span class="built_in">SET</span> <span class="selector-tag">@</span><span class="selector-tag">@</span>[<span class="type">session.</span>]system_var_name=value;</span><br><span class="line"></span><br><span class="line">只读变量无法修改</span><br><span class="line">变量无法实现永久保存，重启服务后会被重置</span><br></pre></td></tr></table></figure>

<h3 id="服务器状态变量"><a href="#服务器状态变量" class="headerlink" title="服务器状态变量"></a>服务器状态变量</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务器状态变量：分全局和会话两种，其中许多变量有双重域，既是全局变量，也是会话变量，有相同的名字</span><br><span class="line">状态变量用于保存 MySQL 运行中的统计数据的变量，只读，不可修改。</span><br></pre></td></tr></table></figure>

<h4 id="服务器变量-sql-mode"><a href="#服务器变量-sql-mode" class="headerlink" title="服务器变量 sql_mode"></a><strong>服务器变量</strong> <strong>sql_mode</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sql_mode 是服务器选项，也是变量，其值会影响 SQL 语句执行的工作模式。</span><br><span class="line"></span><br><span class="line">服务器变量 sql_mode 是 MySQL 数据库中的一个重要系统变量，它用于控制 MySQL 如何处理 SQL 语句和数据校验。sql_mode 可以看作是一组约束和规范，用于确保数据的准确性、完整性和一致性。</span><br><span class="line">通过设置不同的 sql_mode 选项，可以改变 MySQL 的执行和处理方式，以适应不同的需求或标准。</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">控制数据的插入、更新和删除操作，确保数据符合表的定义。</span><br><span class="line">对插入数据进行校验，如日期格式、数据类型长度等。</span><br><span class="line">改变 MySQL 对于字符串和数字之间的隐式转换规则。</span><br><span class="line">使 MySQL 的语法更加严格，符合 ANSI SQL 标准。</span><br><span class="line">提高 MySQL 的安全性，避免一些潜在的安全漏洞。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="INDEX-索引"><a href="#INDEX-索引" class="headerlink" title="INDEX 索引"></a><strong>INDEX</strong> <strong>索引</strong></h2><h3 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">索引是 帮助 MySQL高效获取数据的 数据结构</span><br><span class="line">MySQL索引是一种特殊的数据库结构，由数据库表中一列或多列组合而成，主要用于加快数据的查询和检索速度。它类似于书籍的目录或字典的音序表，可以帮助数据库系统快速定位和获取所需的数据，从而提高查询性能。</span><br><span class="line"></span><br><span class="line">优点</span><br><span class="line">- 大大加快数据的检索速度;</span><br><span class="line">- 创建唯一性索引，保证数据库表中每一行数据的唯一性;</span><br><span class="line">- 加速表和表之间的连接;</span><br><span class="line">- 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。</span><br><span class="line"></span><br><span class="line">缺点</span><br><span class="line">- 索引需要占物理空间。</span><br><span class="line">- 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a><strong>索引数据结构</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">MySQL索引的算法和结构主要取决于存储引擎。对于InnoDB存储引擎，最常用的索引结构是B+树索引。</span><br><span class="line">B+树索引具有以下特点：</span><br><span class="line">    所有数据都会出现在叶子节点：叶子节点形成一个单向链表，便于范围搜索和排序。</span><br><span class="line">    非叶子节点仅起到索引数据作用：不存储实际数据，只存储索引，使得树的层级更低，性能更高。</span><br><span class="line"></span><br><span class="line">索引结构-树</span><br><span class="line">树的分类</span><br><span class="line">- 无序树：树中任意节点的子结点之间没有顺序关系</span><br><span class="line">- 有序树：树中任意节点的子结点之间有顺序关系</span><br><span class="line"></span><br><span class="line">- 二叉树：每个节点最多含有两个子树的树称为二叉树</span><br><span class="line">- 二叉查找树：</span><br><span class="line"> 首先它是一颗二叉树，</span><br><span class="line"> - 若左子树不空，则左子树上所有结点的值均小于它的根结点的值，</span><br><span class="line"> - 若右子树不空，则右子树上所有结点的值均大于它的根结点的值，</span><br><span class="line"> - 左、右子树也分别为二叉排序树</span><br><span class="line">- 满二叉树：叶节点除外的所有节点均含有两个子树的树被称为满二叉树</span><br><span class="line">- 完全二叉树：如果一颗二叉树除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布</span><br><span class="line">- 霍夫曼树：带权路径最短的二叉树</span><br><span class="line">- 红黑树：</span><br><span class="line"> 红黑树是一颗特殊的二叉查找树，</span><br><span class="line"> - 每个节点都是黑色或者红色，根节点、叶子节点是黑色。</span><br><span class="line"> - 如果一个节点是红色的，则它的子节点必须是黑色的</span><br><span class="line">- 平衡二叉树(AVL)：一 棵空树或它的左右两个子树的高度差的绝对值不超过<span class="number">1</span>，并且左右两个子树都是一棵平衡二叉树</span><br></pre></td></tr></table></figure>

<h4 id="B-树"><a href="#B-树" class="headerlink" title="**B-**树"></a>**B-**树</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B-树，读作B树，中间的横线是连字符，不是减号，B树将一个节点的大小设置为每个数据页(Page，也可以称为块，block)的大小，一般是<span class="number">16</span>KB，并且，B树中是将数据和索引放在一起的，以减少IO次数，加快查询速度，一个节点能放多少数据，通常取决于一条数据占用的空间大小。</span><br></pre></td></tr></table></figure>

<h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="**B+**树索引"></a>**B+**树索引</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">B+树是B-树的变体，也是一棵多路搜索树，MySQL普遍使用B+树来实现索引。</span><br><span class="line"></span><br><span class="line">B+树和B-树的主要区别：</span><br><span class="line">B-树内部节点是保存数据的，而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保存数据。</span><br><span class="line">B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。</span><br><span class="line">查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束</span><br><span class="line">B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。</span><br></pre></td></tr></table></figure>

<h4 id="B-树和B-树的主要区别"><a href="#B-树和B-树的主要区别" class="headerlink" title="B+树和B-树的主要区别"></a>B+树和B-树的主要区别</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B-树内部节点是保存数据的，而B+树内部节点是不保存数据的，只作索引作用，它的叶子节点才保</span><br><span class="line">存数据。</span><br><span class="line">B+树相邻的叶子节点之间是通过链表指针连起来的，B-树却不是。</span><br><span class="line">查找过程中，B-树在找到具体的数值以后就结束，而B+树则需要通过索引找到叶子结点中的数据才结束</span><br><span class="line">B-树中任何一个关键字出现且只出现在一个结点中，而B+树可以出现多次。</span><br></pre></td></tr></table></figure>

<h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a><strong>查看索引</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM [<span class="type">db_name.</span>]tbl_name;</span><br></pre></td></tr></table></figure>

<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE [<span class="type">UNIQUE</span>] INDEX index_name ON tbl_name (index_col_name[(<span class="type">length</span>)],...);</span><br><span class="line">ALTER TABLE tbl_name ADD INDEX index_name(index_col_name[(<span class="type">length</span>)]);</span><br><span class="line"></span><br><span class="line">语法示例：</span><br><span class="line"> CREATE INDEX idx_name ON student(name); </span><br><span class="line"> 创建一个索引，该索引包含 name 列的完整值。</span><br><span class="line"> 这意味着，无论 name 列中的字符串有多长，整个字符串都会被包含在索引中。</span><br><span class="line"> </span><br><span class="line"> CREATE INDEX idx_name ON student(name(<span class="number">10</span>)); </span><br><span class="line"> 创建一个前缀索引，该索引仅包含 name 列的前 <span class="number">10</span> 个字符。</span><br><span class="line"> 这意味着，索引是基于 name 列值的前 <span class="number">10</span> 个字符创建的</span><br></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON tbl_name;</span><br><span class="line">ALTER TABLE tbl_name DROP INDEX index_name(index_col_name);</span><br></pre></td></tr></table></figure>

<h4 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所谓并发控制：是指多个进程同时读写一条数据的时候数据库对此情况的处理方式。</span><br><span class="line"></span><br><span class="line">锁机制</span><br><span class="line">读锁   共享锁，也称为 S 锁，只读不可写（包括当前事务），多个读互不阻塞</span><br><span class="line">写锁   独占锁，排它锁，也称为 X 锁，写锁会阻塞其它事务（不包括当前事务）的读和写</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">锁是加在索引上的,不是加在数据上的.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th>类别</th>
<th>详情</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>存储引擎</td>
<td>锁粒度</td>
<td>锁的实现</td>
<td>锁类型</td>
<td>说明</td>
</tr>
<tr>
<td>MyISAM</td>
<td>表级锁</td>
<td>存储引擎自行实现该引擎的锁策略和锁粒度</td>
<td>隐式锁</td>
<td>由存储引擎自动施加锁</td>
</tr>
<tr>
<td>MyISAM</td>
<td>表级锁</td>
<td>自行实现（在程序中或命令行下用命令显式实现）</td>
<td>显式锁</td>
<td>用户手动请求</td>
</tr>
<tr>
<td>InnoDB</td>
<td>行级锁</td>
<td>存储引擎自行实现该引擎的锁策略和锁粒度</td>
<td>隐式锁</td>
<td>由存储引擎自动施加锁</td>
</tr>
<tr>
<td>InnoDB</td>
<td>行级锁</td>
<td>自行实现（在程序中或命令行下用命令显式实现）</td>
<td>显式锁</td>
<td>用户手动请求</td>
</tr>
</tbody></table>
<h4 id="锁命令"><a href="#锁命令" class="headerlink" title="锁命令"></a>锁命令</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">加读锁</span><br><span class="line">MariaDB [<span class="type">testdb</span>]&gt; lock tables student read;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">释放读锁</span><br><span class="line">MariaDB [<span class="type">testdb</span>]&gt; unlock tables;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)</span><br><span class="line"></span><br><span class="line">加写锁</span><br><span class="line">MariaDB [<span class="type">testdb</span>]&gt; lock table student <span class="built_in">write</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">释放写锁</span><br><span class="line">连接或进程只能释放其自身施加的锁。一个session只能为自己获取锁和释放锁，不能为其他session获取锁，也不能释放由其他session保持的锁。</span><br><span class="line">MariaDB [<span class="type">testdb</span>]&gt; unlock tables ;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">关闭正在打开的表（清除查询缓存），通常在备份前加全局读锁</span><br><span class="line">FLUSH TABLES [<span class="type">tb_name</span>[,<span class="type">...</span>]] [<span class="type">WITH</span> <span class="type">READ</span> <span class="type">LOCK</span>]</span><br><span class="line"></span><br><span class="line">关闭所有打开的表，强制关闭所有正在使用的表，并刷新查询缓存和预准备语句缓存，不会刷新脏块</span><br><span class="line">FLUSH TABLES</span><br><span class="line"></span><br><span class="line">关闭所有打开的表并使用全局读锁锁定所有数据库的所有表，不会刷新脏块,也不阻塞日志表写入，例如查询日志，慢日志等</span><br><span class="line">FLUSH TABLES WITH READ LOCK</span><br><span class="line"></span><br><span class="line">操作指定表</span><br><span class="line">FLUSH TABLES tbl_name tb_name[,<span class="type">...</span>] WITH READ LOCK</span><br><span class="line"></span><br><span class="line">刷新脏块, 脏块也称为脏页，当内存数据页和磁盘数据页上的内容不一致时，我们称这个内存页为脏页</span><br><span class="line">FLUSH TABLES tbl_name [<span class="type">tb_name</span>[,<span class="type">...</span>]] <span class="keyword">FOR</span> EXPORT</span><br></pre></td></tr></table></figure>

<h4 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">事务</span><br><span class="line">事务是一组具有原子性的 SQL 语句，或者说一个独立单元。可以理解为一个事务对应的是一组完整的业务，这个业务有一条或多条 SQL 语句组成。所谓原子性是指，这一组业务中的 SQL 语句不可分割，所以，要么全部 SQL 语句都执行成功，事务也就执行成功；只要有一条 SQL 语句执行失败，则整个事务都要回滚到事务开始前。</span><br><span class="line"></span><br><span class="line">事务特性</span><br><span class="line">原子性( Atomicity )</span><br><span class="line">  原子性又称不可分割性。一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</span><br><span class="line"></span><br><span class="line">一致性( Consistency )</span><br><span class="line">   事务的执行结果，必须是符合预期的，这表示在事务中进行的数据读写，完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</span><br><span class="line"></span><br><span class="line">隔离性( Isolation )</span><br><span class="line">  隔离性又称独立性。MySQL 允许多个事务并发，同时进行写操作，隔离性用于实现事务的并发控制，防止多个事务并发执行时的交叉执行而导致的数据不一致。</span><br><span class="line">  事务的隔离分为不同的级别，包括读未提交( Read uncommitted )，读提交( read committed )，可重复读( repeatable read )，串行化( Serializable )。</span><br><span class="line">  </span><br><span class="line">持久性( Durability )</span><br><span class="line">事务执行成功后，其对于数据的修改会永久保存于数据库中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">显式启动事务 语法解读</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">BEGIN</span> WORK</span><br><span class="line"><span class="built_in">START</span> TRANSACTION</span><br><span class="line"></span><br><span class="line">结束事务</span><br><span class="line"><span class="comment">#提交执行</span></span><br><span class="line">COMMIT</span><br><span class="line"><span class="comment">#回滚</span></span><br><span class="line">ROLLBACK</span><br></pre></td></tr></table></figure>

<h4 id="自动提交能力"><a href="#自动提交能力" class="headerlink" title="自动提交能力"></a><strong>自动提交能力</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">对于mysql来说，每一个对于数据的增删改的动作，都是一个事务，为什么我们操作过数据之后，另外的终端可以立刻生效呢？</span><br><span class="line">原因是，mysql对于这种操作，启用了 自动提交的能力。</span><br><span class="line"></span><br><span class="line">默认开始自动提交</span><br><span class="line">MariaDB [<span class="type">testdb</span>]&gt; <span class="built_in">select</span> <span class="selector-tag">@</span>@autocommit;</span><br><span class="line">+<span class="literal">--------------</span>+</span><br><span class="line">| <span class="selector-tag">@</span>@autocommit |</span><br><span class="line">+<span class="literal">--------------</span>+</span><br><span class="line">|            <span class="number">1</span> |</span><br><span class="line">+<span class="literal">--------------</span>+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">关闭自动提交</span><br><span class="line">MariaDB [<span class="type">testdb</span>]&gt; <span class="built_in">set</span> autocommit=<span class="number">0</span>;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [<span class="type">testdb</span>]&gt; <span class="built_in">select</span> <span class="selector-tag">@</span>@autocommit;</span><br><span class="line">+<span class="literal">--------------</span>+</span><br><span class="line">| <span class="selector-tag">@</span>@autocommit |</span><br><span class="line">+<span class="literal">--------------</span>+</span><br><span class="line">|            <span class="number">0</span> |</span><br><span class="line">+<span class="literal">--------------</span>+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看事务"><a href="#查看事务" class="headerlink" title="查看事务"></a>查看事务</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前正在进行的事务</span></span><br><span class="line"><span class="built_in">SELECT</span> * FROM INFORMATION_SCHEMA.INNODB_TRX;</span><br></pre></td></tr></table></figure>

<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等的进程称为死锁进程。</span><br><span class="line"></span><br><span class="line">死锁语法解析</span><br><span class="line">查看innodb状态，可以查看锁信息</span><br><span class="line">show engine innodb status;</span><br><span class="line">查看正在进行中的事务</span><br><span class="line"><span class="built_in">SELECT</span> * FROM information_schema.INNODB_TRX;</span><br><span class="line">查看锁</span><br><span class="line"><span class="built_in">SELECT</span> * FROM information_schema.INNODB_LOCKS;</span><br><span class="line">MySQL8.<span class="number">0.13</span> 及以后使用此语句查看锁</span><br><span class="line"><span class="built_in">SELECT</span> * FROM performance_schema.data_locks;</span><br><span class="line">查看锁等待</span><br><span class="line"><span class="built_in">SELECT</span> * FROM information_schema.INNODB_LOCK_WAITS;</span><br><span class="line">MySQL8.<span class="number">0.13</span>及以后使用此语句查看锁等待</span><br><span class="line"><span class="built_in">SELECT</span> * FROM performance_schema.data_lock_waits;</span><br></pre></td></tr></table></figure>

<h4 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MySQL 的事务隔离级别一共有四个，分别是 读未提交、读已提交、可重复读 以及 可串行化。MySQL 的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。</span><br><span class="line"></span><br><span class="line">读未提交（READ UNCOMMITTED）</span><br><span class="line">  在读未提交隔离级别下，事务A可以读取到事务B修改过但未提交的数据。可能发生 脏读、不可重复读和 幻读问题，一般很少使用此隔离级别。</span><br><span class="line">  简单来说：你没有提交的时候，我就看到你修改的数据</span><br><span class="line"></span><br><span class="line">读已提交（READ COMMITTED）</span><br><span class="line">  在读已提交隔离级别下，事务B只能在事务A修改过并且已提交后才能读取到事务B修改的数据。读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。</span><br><span class="line">  简单来说：你提交后，我才可以看到你修改的数据。</span><br><span class="line"></span><br><span class="line">可重复读（REPEATABLE READ）</span><br><span class="line">  在可重复读隔离级别下，事务B只能在事务A修改过数据并提交后，自己也提交事务后，才能读取到事务B修改的数据。可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。</span><br><span class="line">  简单来说，你提交了，我也提交了，我才有能力读自己的数据。</span><br><span class="line"></span><br><span class="line">可串行化（SERIALIZABLE）</span><br><span class="line">  可串行化，又称序列化。各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。</span><br><span class="line">  简单来说；咱们俩，谁先开始【另外一个人处于等待状态】，谁后开始的问题。</span><br><span class="line">  </span><br><span class="line">以上四种隔离级别，从上往下，隔离强度逐渐增强，性能逐渐变差，需要消耗的 MySQL 的资源越多，</span><br><span class="line">所以并不是隔离强度越高越好，采用哪种隔离级别要根据系统需求权衡决定，MySQL 中默认的隔离级</span><br><span class="line">别是可重复读。</span><br></pre></td></tr></table></figure>

<h4 id="事务并发中可能出现的问题"><a href="#事务并发中可能出现的问题" class="headerlink" title="事务并发中可能出现的问题"></a><strong>事务并发中可能出现的问题</strong></h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">脏读（Dirty Read） - 只在 读未提交 隔离级别才会出现</span><br><span class="line">脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并不一定最终存在的数据，这就是脏读。</span><br><span class="line"></span><br><span class="line">不可重复读（Non<span class="literal">-Repeatable</span> Read） - 在 读未提交 和 读已提交 隔离级别都可能会出现</span><br><span class="line">不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。</span><br><span class="line"></span><br><span class="line">幻读（Phantom）-在 读未提交、读已提交、可重复读 隔离级别都可能会出现</span><br><span class="line">一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。</span><br></pre></td></tr></table></figure>

<h4 id="MVCC和事务的隔离级别"><a href="#MVCC和事务的隔离级别" class="headerlink" title="MVCC和事务的隔离级别"></a><strong>MVCC</strong>和事务的隔离级别</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MVCC（多版本并发控制机制）只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><h4 id="MySQL的日志类型"><a href="#MySQL的日志类型" class="headerlink" title="MySQL的日志类型"></a><strong>MySQL</strong>的日志类型</h4><p>MySQL 支持丰富的日志类型，主要有以下六种：</p>
<table>
<thead>
<tr>
<th>日志类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>事务日志</td>
<td>记录 InnoDB 等支持事务的存储引擎执行事务时产生的日志，其写入类型为顺序 IO</td>
</tr>
<tr>
<td>错误日志</td>
<td>记录 MySQL 服务的启动、运行或停止 MySQL 服务时出现的问题，通常也会记录 Warning</td>
</tr>
<tr>
<td>通用日志</td>
<td>又称查询日志，记录建立的客户端连接和执行的语句</td>
</tr>
<tr>
<td>慢查询日志</td>
<td>记录所有执行时间超过 long_query_time 的所有查询或不使用索引的查询，有助于定位性能问题</td>
</tr>
<tr>
<td>二进制日志</td>
<td>记录所有更改数据的语句，主要用于复制和即时点恢复</td>
</tr>
<tr>
<td>中继日志</td>
<td>从主服务器的二进制日志文件中复制而来的事件，并保存为的日志文件，与二进制日志几乎相同</td>
</tr>
</tbody></table>
<h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Mariadb 查看日志信息</span><br><span class="line"><span class="comment">#MariaDB中的相关变量</span></span><br><span class="line">MariaDB [<span class="type">testdb</span>]&gt; show variables like <span class="string">&#x27;%innodb_log%&#x27;</span>;</span><br><span class="line">+<span class="literal">-----------------------------</span>+<span class="literal">-----------</span>+</span><br><span class="line">| Variable_name               | Value     |</span><br><span class="line">+<span class="literal">-----------------------------</span>+<span class="literal">-----------</span>+</span><br><span class="line">| innodb_log_buffer_size      | <span class="number">16777216</span>  |</span><br><span class="line">| innodb_log_checksums        | ON        |</span><br><span class="line">| innodb_log_compressed_pages | ON        |</span><br><span class="line">| innodb_log_file_size        | <span class="number">100663296</span> |</span><br><span class="line">| innodb_log_files_in_group   | <span class="number">1</span>         |</span><br><span class="line">| innodb_log_group_home_dir   | ./        |</span><br><span class="line">| innodb_log_optimize_ddl     | OFF       |</span><br><span class="line">| innodb_log_write_ahead_size | <span class="number">8192</span>      |</span><br><span class="line">+<span class="literal">-----------------------------</span>+<span class="literal">-----------</span>+</span><br><span class="line"><span class="number">8</span> rows <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.001</span> sec)</span><br><span class="line"></span><br><span class="line">确认日志所处的位置</span><br><span class="line">MariaDB [<span class="type">testdb</span>]&gt; show variables like <span class="string">&#x27;%datadir%&#x27;</span>;</span><br><span class="line">+<span class="literal">---------------</span>+<span class="literal">-------------------</span>+</span><br><span class="line">| Variable_name | Value             |</span><br><span class="line">+<span class="literal">---------------</span>+<span class="literal">-------------------</span>+</span><br><span class="line">| datadir       | /mysql/<span class="number">3306</span>/<span class="keyword">data</span>/ |</span><br><span class="line">+<span class="literal">---------------</span>+<span class="literal">-------------------</span>+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.001</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="事务日志性能优化"><a href="#事务日志性能优化" class="headerlink" title="事务日志性能优化"></a>事务日志性能优化</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redo log 包含日志缓冲（redo log buffer）和磁盘上的日志文件（redo logfile）两部分。</span><br><span class="line">MySQL 每执行新一条 DML 语句都会先将日志记录在 redo log buffer 中，然后再根据不同的配置项，使用不同的规则将 redo log buffer 中的数据落盘（写入到 redo log file）。</span><br><span class="line">但是，redo log buffer 是用户空间的数据，无法直接写入磁盘，中间必须经过操作系统缓冲区（OS Buffer），因此，从 redo log buffer 到 redo log file，实际上会先写 OS Buffer，再调用fsync() 将其刷人入到 redo log file 中。</span><br></pre></td></tr></table></figure>

<h4 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MySQL 中错误日志中记录的主要内容</span><br><span class="line">- mysqld 启动和关闭过程中输出的事件信息</span><br><span class="line">- mysqld 运行中产生的错误信息</span><br><span class="line">- event scheduler 运行一个 event 时产生的日志信息</span><br><span class="line">- 在主从复制架构中的从服务器上启动从服务器线程时产生的信息</span><br></pre></td></tr></table></figure>

<h4 id="通用日志"><a href="#通用日志" class="headerlink" title="通用日志"></a>通用日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通用日志</span><br><span class="line">  通用日志，又称通用查询日志（General Query Log），用来记录对数据库的所有操作，包括启动和关闭 MySQL 服务、更新语句和查询语句等。默认情况下，通用查询日志功能是关闭的。</span><br><span class="line">  可以通过配置开启此日志，并决定将日志存储到文件或数据表中。如果选择记录到数据表中，则具体的表是 mysql.general_log</span><br></pre></td></tr></table></figure>

<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  慢查询日志用来记录在 MySQL 中执行时间超过指定时间的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率低，以便进行优化。</span><br><span class="line">  慢查询日志默认不开启。</span><br><span class="line"></span><br><span class="line">Mariadb环境查看</span><br><span class="line">MariaDB [<span class="type">mysql</span>]&gt; <span class="built_in">select</span> <span class="selector-tag">@</span>@slow_query_log,<span class="selector-tag">@</span>@slow_query_log_file,<span class="selector-tag">@</span>@long_query_time;</span><br><span class="line">+<span class="literal">------------------</span>+<span class="literal">-----------------------</span>+<span class="literal">-------------------</span>+</span><br><span class="line">| <span class="selector-tag">@</span>@slow_query_log | <span class="selector-tag">@</span>@slow_query_log_file | <span class="selector-tag">@</span>@long_query_time |</span><br><span class="line">+<span class="literal">------------------</span>+<span class="literal">-----------------------</span>+<span class="literal">-------------------</span>+</span><br><span class="line">|                <span class="number">0</span> | bogon<span class="literal">-slow</span>.log        |         <span class="number">10.000000</span> |</span><br><span class="line">+<span class="literal">------------------</span>+<span class="literal">-----------------------</span>+<span class="literal">-------------------</span>+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">开启慢查询日志</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   二进制日志（Binary Log）也可叫作变更日志（Update Log），是 MySQL 中非常重要的日志。主要用于记录数据库的变化情况，即 SQL 语句的 DDL 和 DML 语句，但不包含查询操作语句，因为查询语句并不会改变数据库中的数据。</span><br><span class="line">   如果 MySQL 数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。</span><br><span class="line">   </span><br><span class="line">事务日志和二进制区别</span><br><span class="line">- 事务日志可以看作是在线日志，二进制日志可以看作是离线日志</span><br><span class="line">- 事务日志记录事务执行的过程，包括提交和未提交，二进制日志记录只记提交的过程</span><br><span class="line">- 事务日志只支持 InnoDB 存储引擎，二进制支持 InnoDB 和 MyISAM 存储引擎</span><br><span class="line">- 事务日志的容量是<span class="number">100</span>M的大小，会滚动覆盖式更新，二进制的容量大小没有限制。</span><br><span class="line"></span><br><span class="line">二进制日志记录三种格式</span><br><span class="line">- Statement：基于语句的记录模式，日志中会记录原生执行的 SQL 语句，对于某些函数或变量，不会替换。</span><br><span class="line">- Row：基于行的记录模式，会将 SQL 语句中的变量和函数进行替换后再记录。</span><br><span class="line">- Mixed：混合记录模式，在此模式下，MySQL 会根据具体的 SQL 语句来分析采用哪种模式记录日志。</span><br></pre></td></tr></table></figure>

<h4 id="查看二进制文件"><a href="#查看二进制文件" class="headerlink" title="查看二进制文件"></a>查看二进制文件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [<span class="type">db2</span>]&gt; <span class="built_in">select</span> <span class="selector-tag">@</span>@binlog_format;</span><br><span class="line">+<span class="literal">-----------------</span>+</span><br><span class="line">| <span class="selector-tag">@</span>@binlog_format |</span><br><span class="line">+<span class="literal">-----------------</span>+</span><br><span class="line">| MIXED           |</span><br><span class="line">+<span class="literal">-----------------</span>+</span><br><span class="line"><span class="number">1</span> row <span class="keyword">in</span> <span class="built_in">set</span> (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">查看当前服务的二进制文件列表</span><br><span class="line">SHOW &#123;BINARY | MASTER&#125; LOGS</span><br><span class="line">查看正在使用的二进制文件</span><br><span class="line">SHOW MASTER STATUS</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="https://lx1me.github.io/2025/06/05/MySQL%20%E6%95%B0%E6%8D%AE%E5%BA%93-1/" data-id="cmbof5pg80001m0v6g12d289k" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/05/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%20ZABBIX/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%20Docker/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%A0%A1%E5%9E%92%E6%9C%BA%20JumpServer/">(no title)</a>
          </li>
        
          <li>
            <a href="/2025/06/05/%E4%BC%81%E4%B8%9A%E7%BA%A7%E8%B0%83%E5%BA%A6%E5%99%A8LVS/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>